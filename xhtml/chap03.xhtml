<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><title>How to Think Like a Computer Scientist: 3. Functions</title><link href="stylesheet.css" type="text/css" rel="stylesheet" /></head><body bgcolor="white"><h1 class="title">3. Functions</h1><div class="toc"><ol><li><a href="#auto0">Definitions and use</a></li><li><a href="#auto1">Flow of execution</a></li><li><a href="#auto2">Parameters, arguments, and the import statement</a></li><li><a href="#auto3">Composition</a></li><li><a href="#auto4">Variables and parameters are local</a></li><li><a href="#auto5">Stack diagrams</a></li><li><a href="#auto6">Glossary</a></li><li><a href="#auto7">Exercises</a></li></ol></div><div class="content"><span></span><a name="floatchap"></a><h2>3.1 Definitions and use<a name="auto0"></a></h2><a name="functionchap"></a><a name="index01"></a><a name="index02"></a><a name="index03"></a><p>In the context of programming, a <b>function</b> is a named sequence of
statements that performs a desired operation.  This operation is specified in a 
<b>function definition</b>. In Python, the syntax for a function definition is:
</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">NAME</span>( <span class="py-src-parameter">LIST</span> <span class="py-src-parameter">OF</span> <span class="py-src-parameter">PARAMETERS</span> ):
    <span class="py-src-variable">STATEMENTS</span>
</pre><p>You can make up any names you want for the functions you create, except that
you can't use a name that is a Python keyword.  The list of parameters
specifies what information, if any, you have to provide in order to use the new 
function.</p><p>There can be any number of statements inside the function, but they have to
be indented from the <code>def</code>.  In the examples in this book, we will
use the standard indentation of four spaces. Function definitions are the first
of several <b>compound statements</b> we will see, all of which have the
same pattern:</p><ol><li>A <b>header</b>, which begins with a keyword and ends with a colon.</li><li>A <b>body</b> consisting of one or more Python statements, each
  indented the same amount -- <em>4 spaces is the Python standard</em> -- from
  the header.</li></ol><p>In a function definition, the keyword in the header is <code>def</code>,
which is followed by the name of the function and a list of <em>parameters</em>
enclosed in parentheses. The parameter list may be empty, or it may contain any 
number of parameters.  In either case, the parentheses are required.</p><p>The first couple of functions we are going to write have no parameters,
so the syntax looks like this:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">new_line</span>():
    <span class="py-src-keyword">print</span>          <span class="py-src-comment"># a print statement with no arguments prints a new line</span>
</pre><p>This function is named <code>new_line</code>.  The empty parentheses
indicate that it has no parameters.  Its body contains only a single statement, 
which outputs a newline character. (That's what happens when you use a
<code>print</code> command without any arguments.)</p><p>Defining a new function does not make the function run.  To do that we
need a <b>function call</b>.  Function calls contain the name of the
function being executed followed by a list of values, called <em>arguments</em>,
which are assigned to the parameters in the function definition.  Our first
examples have an empty parameter list, so the function calls do not take
any arguments.  Notice, however, that the <em>parentheses are required
in the function call</em>:</p><pre class="python">
<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;First Line.&quot;</span>
<span class="py-src-variable">new_line</span>()
<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Second Line.&quot;</span>
</pre><p>The output of this program is:</p><pre class="shell">
First line.

Second line.
</pre><p>The extra space between the two lines is a result of the
<code>new_line()</code> function call.  What if we wanted more space
between the lines?  We could call the same function repeatedly:</p><pre class="python">
<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;First Line.&quot;</span>
<span class="py-src-variable">new_line</span>()
<span class="py-src-variable">new_line</span>()
<span class="py-src-variable">new_line</span>()
<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Second Line.&quot;</span>
</pre><p>Or we could write a new function named <code>three_lines</code> that prints
three new lines:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">three_lines</span>():
    <span class="py-src-variable">new_line</span>()
    <span class="py-src-variable">new_line</span>()
    <span class="py-src-variable">new_line</span>()

<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;First Line.&quot;</span>
<span class="py-src-variable">three_lines</span>()
<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Second Line.&quot;</span>
</pre><p>This function contains three statements, all of which are indented by four 
spaces.  Since the next statement is not indented, Python knows that it is
not part of the function.</p><p>You should notice a few things about this program:</p><ul><li>You can call the same procedure repeatedly.  In fact, it is quite common
and useful to do so.</li><li>You can have one function call another function; in this case
<code>three_lines</code> calls <code>new_line</code>.</li></ul><p>So far, it may not be clear why it is worth the trouble to create all of
these new functions.  Actually, there are a lot of reasons, but this example
demonstrates two:</p><ol><li>Creating a new function gives you an opportunity to name a group of
statements.  Functions can simplify a program by hiding a complex computation
behind a single command and by using English words in place of arcane code.
</li><li>Creating a new function can make a program smaller by eliminating
repetitive code.  For example, a short way to print nine consecutive new lines
is to call <code>three_lines</code> three times.</li></ol><p>Pulling together the code fragments from the previous section into a
script named <code>tryme1.py</code>, the whole program looks like this:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">new_line</span>():
    <span class="py-src-keyword">print</span>

<span class="py-src-keyword">def</span> <span class="py-src-identifier">three_lines</span>():
    <span class="py-src-variable">new_line</span>()
    <span class="py-src-variable">new_line</span>()
    <span class="py-src-variable">new_line</span>()

<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;First Line.&quot;</span>
<span class="py-src-variable">three_lines</span>()
<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Second Line.&quot;</span>
</pre><p>This program contains two function definitions: <code>new_line</code> and
<code>three_lines</code>.  Function definitions get executed just like other
statements, but the effect is to create the new function.  The statements
inside the function do not get executed until the function is called, and
the function definition generates no output.</p><p>As you might expect, you have to create a function before you can execute
it.  In other words, the function definition has to be executed before the
first time it is called.</p><h2>3.2 Flow of execution<a name="auto1"></a></h2><a name="index04"></a><p>In order to ensure that a function is defined before its first use, you have 
to know the order in which statements are executed, which is called the
<b>flow of execution</b>.</p><p>Execution always begins at the first statement of the program.  Statements
are executed one at a time, in order from top to bottom.</p><p>Function definitions do not alter the flow of execution of the program, but
remember that statements inside the function are not executed until the
function is called.  Although it is not common, you can define one function
inside another.  In this case, the inner definition isn't executed until the
outer function is called.</p><p>Function calls are like a detour in the flow of execution. Instead of going
to the next statement, the flow jumps to the first line of the called function,
executes all the statements there, and then comes back to pick up where it left
off.</p><p>That sounds simple enough, until you remember that one function can call
another.  While in the middle of one function, the program might have to
execute the statements in another function. But while executing that new
function, the program might have to execute yet another function!</p><p>Fortunately, Python is adept at keeping track of where it is, so each time a
function completes, the program picks up where it left off in the function that
called it.  When it gets to the end of the program, it terminates.</p><p>What's the moral of this sordid tale?  When you read a program, don't read
from top to bottom.  Instead, follow the flow of execution.</p><h2>3.3 Parameters, arguments, and the <code>import</code> statement<a name="auto2"></a></h2><a name="parameters"></a><a name="index05"></a><a name="index06"></a><a name="index07"></a><a name="index08"></a><a name="index09"></a><a name="index10"></a><p>Most functions require arguments, values that control how the function does
its job.  For example, if you want to find the absolute value of a number, you
have to indicate what the number is.  Python has a built-in function for
computing the absolute value:</p><pre class="python-interpreter">
&gt;&gt;&gt; abs(5)
5
&gt;&gt;&gt; abs(-5)
5
</pre><p>In this example, the arguments to the <code>abs</code> function are 5 and
-5.</p><p>Some functions take more than one argument. For example the built-in
function <code>pow</code> takes two arguments, the base and the exponent.
Inside the function, the values that are passed get assigned to variables
called <b>parameters</b>.</p><pre class="python-interpreter">
&gt;&gt;&gt; pow(2, 3)
8
&gt;&gt;&gt; pow(7, 4)
2401
</pre><p>Another built-in function that takes more than one argument is
<code>max</code>.</p><pre class="python-interpreter">
&gt;&gt;&gt; max(7, 11)
11
&gt;&gt;&gt; max(4, 1, 17, 2, 12)
17
&gt;&gt;&gt; max(3*11, 5**3, 512-9, 1024**0)
503
</pre><p><code>max</code> can be sent any number of arguments, separated by commas,
and will return the maximum value sent.  The arguments can be either simple
values or expressions.  In the last example, 503 is returned, since it is
larger than 33, 125, and 1.</p><p>Here is an example of a user-defined function that has a parameter:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">print_twice</span>(<span class="py-src-parameter">bruce</span>):
    <span class="py-src-keyword">print</span> <span class="py-src-variable">bruce</span>, <span class="py-src-variable">bruce</span>
</pre><p>This function takes a single <b>argument</b> and assigns it to the parameter 
named <code>bruce</code>.  The value of the parameter (at this point we have no 
idea what it will be) is printed twice, followed by a newline.  The name
<code>bruce</code> was chosen to suggest that the name you give a parameter is
up to you, but in general, you want to choose something more illustrative than
<code>bruce</code>.</p><p>The interactive Python shell provides us with a convenient way to test
our functions.  We can use the <b>import statement</b> to bring the functions
we have defined in a script into the interpreter session.  To see how this
works, assume the <code>print_twice</code> function is defined in a script
named <code>chap03.py</code>.  We can now test it interactively by
<em>importing</em> it into our Python shell session:</p><pre class="python-interpreter">
&gt;&gt;&gt; from chap03 import *
&gt;&gt;&gt; print_twice('Spam')
Spam Spam
&gt;&gt;&gt; print_twice(5)
5 5
&gt;&gt;&gt; print_twice(3.14159)
3.14159 3.14159
</pre><p>In a function call, the value of the argument is assigned to the
corresponding parameter in the function definition.  In effect, it is if
<code>bruce = 'Spam'</code> is executed when <code>print_twice('Spam')</code>
is called, <code>bruce = 5</code> in <code>print_twice(5)</code>, and
<code>bruce = 3.14159</code> in <code>print_twice(3.14159)</code>.
</p><p>Any type of argument that can be printed can be sent to
<code>print_twice</code> In the first function call, the argument is a string.
In the second, it's an integer. In the third, it's a <code>float</code>.</p><p>As with built-in functions, we can use an expression as an argument for
<code>print_twice</code>:</p><pre class="python-interpreter">
&gt;&gt;&gt; print_twice('Spam'*4)
SpamSpamSpamSpam SpamSpamSpamSpam
</pre><p><code>'Spam'*4</code> is first evaluated to <code>'SpamSpamSpamSpam'</code>,
which is then passed as an argument to <code>print_twice</code>.</p><h2>3.4 Composition<a name="auto3"></a></h2><a name="index11"></a><a name="index12"></a><p>Just as with mathematical functions, Python functions can be <b>composed</b>,
meaning that you use the result of one function as the input to another.</p><pre class="python-interpreter">
&gt;&gt;&gt; print_twice(abs(-7))
7 7
&gt;&gt;&gt; print_twice(max(3, 1, abs(-11), 7))
11 11
</pre><p>In the first example, <code>abs(-7)</code> evaluates to 7, which then
becomes the argument to <code>print_twice</code>.  In the second example we
have two levels of composition, since <code>abs(-11)</code> is first evaluated
to 11 before <code>max(3, 1, 11, 7)</code> is evaluated to 11 and
<code>print_twice(11)</code> then displays the result.</p><p>We can also use a variable as an argument:</p><pre class="python-interpreter">
&gt;&gt;&gt; michael = 'Eric, the half a bee.'
&gt;&gt;&gt; print_twice(michael)
Eric, the half a bee. Eric, the half a bee.
</pre><p>Notice something very important here. The name of the variable we pass
as an argument (<code>michael</code>) has nothing to do with the name of the
parameter (<code>bruce</code>).  It doesn't matter what the value was
called back home (in the caller); here in <code>print_twice</code>, we call
everybody <code>bruce</code>.</p><h2>3.5 Variables and parameters are local<a name="auto4"></a></h2><a name="index13"></a><a name="index14"></a><p>When you create a <b>local variable</b> inside a function, it only 
exists inside the function, and you cannot use it outside.  For example:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">cat_twice</span>(<span class="py-src-parameter">part1</span>, <span class="py-src-parameter">part2</span>):
    <span class="py-src-variable">cat</span> = <span class="py-src-variable">part1</span> + <span class="py-src-variable">part2</span>
    <span class="py-src-variable">print_twice</span>(<span class="py-src-variable">cat</span>)
</pre><p>This function takes two arguments, concatenates them, and then prints the
result twice.  We can call the function with two strings:</p><pre class="python-interpreter">
&gt;&gt;&gt; chant1 = &quot;Pie Jesu domine, &quot;
&gt;&gt;&gt; chant2 = &quot;Dona eis requiem.&quot;
&gt;&gt;&gt; cat_twice(chant1, chant2)
Pie Jesu domine, Dona eis requiem. Pie Jesu domine, Dona eis requiem.
</pre><p>When <code>cat_twice</code> terminates, the variable <code>cat</code> is
destroyed.  If we try to print it, we get an error:</p><pre class="python-interpreter">
&gt;&gt;&gt; print cat
NameError: name 'cat' is not defined
</pre><p>Parameters are also local.  For example, outside the function
<code>print_twice</code>, there is no such thing as <code>bruce</code>.  If you
try to use it, Python will complain.</p><h2>3.6 Stack diagrams<a name="auto5"></a></h2><a name="stackdiagram"></a><a name="index15"></a><a name="index16"></a><a name="index17"></a><p>To keep track of which variables can be used where, it is sometimes useful
to draw a <b>stack diagram</b>.  Like state diagrams, stack diagrams
show the value of each variable, but they also show the function to which each
variable belongs.</p><p>Each function is represented by a <b>frame</b>.  A frame is a box
with the name of a function beside it and the parameters and variables of the
function inside it.  The stack diagram for the previous example looks like
this:</p><p><img src="illustrations/stack.png" /></p><p>The order of the stack shows the flow of execution.  <code>print_twice</code>
was called by <code>cat_twice</code>, and <code>cat_twice</code> was called by
<code>__main__</code>, which is a special name for the topmost function.  When
you create a variable outside of any function, it belongs to
<code>__main__</code>.</p><p>Each parameter refers to the same value as its corresponding argument.  So,
<code>part1</code> has the same value as <code>chant1</code>,
<code>part2</code> has the same value as <code>chant2</code>,
and <code>bruce</code> has the same value as <code>cat</code>.</p><p>If an error occurs during a function call, Python prints the name of the
function, and the name of the function that called it, and the name of the
function that called <em>that</em>, all the way back to the top most function.
</p><p>To see how this works, create a Python script named <code>tryme2.py</code>
that looks like this:
</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">print_twice</span>(<span class="py-src-parameter">bruce</span>):
    <span class="py-src-keyword">print</span> <span class="py-src-variable">bruce</span>, <span class="py-src-variable">bruce</span>
    <span class="py-src-keyword">print</span> <span class="py-src-variable">cat</span>

<span class="py-src-keyword">def</span> <span class="py-src-identifier">cat_twice</span>(<span class="py-src-parameter">part1</span>, <span class="py-src-parameter">part2</span>):
    <span class="py-src-variable">cat</span> = <span class="py-src-variable">part1</span> + <span class="py-src-variable">part2</span>
    <span class="py-src-variable">print_twice</span>(<span class="py-src-variable">cat</span>)

<span class="py-src-variable">chant1</span> = <span class="py-src-string">&quot;Pie Jesu domine, &quot;</span>
<span class="py-src-variable">chant2</span> = <span class="py-src-string">&quot;Dona eis requim.&quot;</span>
<span class="py-src-variable">cat_twice</span>(<span class="py-src-variable">chant1</span>, <span class="py-src-variable">chant2</span>)
</pre><p>We've added the statement, <code>print cat</code> inside the
<code>print_twice</code> function, but <code>cat</code> is not defined there.
Running this script will produce an error message like this:</p><pre class="shell">
Traceback (innermost last):
  File &quot;tryme2.py&quot;, line 11, in &lt;module&gt;
    cat_twice(chant1, chant2)
  File &quot;tryme2.py&quot;, line 7, in cat_twice
    print_twice(cat)
  File &quot;tryme2.py&quot;, line 3, in print_twice
    print cat
NameError: global name 'cat' is not defined
</pre><p>This list of functions is called a <b>traceback</b>.  It tells
you what program file the error occurred in, and what line, and what functions
were executing at the time.  It also shows the line of code that caused the
error.</p><a name="index18"></a><p>Notice the similarity between the traceback and the stack diagram.  It's
not a coincidence.</p><h2>3.7 Glossary<a name="auto6"></a></h2><a name="index19"></a><a name="index20"></a><a name="index21"></a><a name="index22"></a><a name="index23"></a><a name="index24"></a><a name="index25"></a><a name="index26"></a><a name="index27"></a><a name="index28"></a><a name="index29"></a><a name="index30"></a><a name="index31"></a><a name="index32"></a><a name="index33"></a><a name="index34"></a><a name="index35"></a><a name="index36"></a><dl><dt>function:</dt><dd>A named sequence of statements that performs some useful operation.
Functions may or may not take parameters and may or may not produce a result.
</dd><dt>function definition:</dt><dd>A statement that creates a new function, specifying its name, parameters,
and the statements it executes.</dd><dt>compound statement:</dt><dd>A statement that consists of two parts:
<ol><li>header - which begins with a keyword determining the statement type,
    and ends with a colon.</li><li>body - containing one or more statements indented the same amount from
    the header.</li></ol>
The syntax of a compound statement looks like this:
<pre>
keyword expression :
    statement
    statement ...
</pre></dd><dt>header:</dt><dd>The first part of a compound statement.  Headers begin with a keyword
and end with a colon (:)</dd><dt>body:</dt><dd>The second part of a compound statement.  The body consists of a
sequence of statements all indented the same amount from the beginning
of the header.  The standard amount of indentation used within the Python
community is 4 spaces.</dd><dt>function call:</dt><dd>A statement that executes a function. It consists of the name of the
function followed by a list of arguments enclosed in parentheses.</dd><dt>flow of execution:</dt><dd>The order in which statements are executed during a program run.</dd><dt>parameter:</dt><dd>A name used inside a function to refer to the value passed as an argument.
</dd><dt>import:</dt><dd><p>A statement which permits functions and variables defined in a Python
script to be brought into the environment of another script or a running
Python shell.
</p><p>For example, assume the following is in a script named
<code>tryme.py</code>:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">print_thrice</span>(<span class="py-src-parameter">thing</span>):
    <span class="py-src-keyword">print</span> <span class="py-src-variable">thing</span>, <span class="py-src-variable">thing</span>, <span class="py-src-variable">thing</span>

<span class="py-src-variable">n</span> = <span class="py-src-number">42</span>
<span class="py-src-variable">s</span> = <span class="py-src-string">&quot;And now for something completely different...&quot;</span>
</pre><p>Now begin a python shell from within the same directory where
<code>tryme.py</code> is located:</p><pre class="boxed">
$ ls
tryme.py  &lt;and other stuff...&gt;
$ python
&gt;&gt;&gt;
</pre><p>Three names are defined in <code>tryme.py</code>:
<code>print_thrice</code>, <code>n</code>, and <code>s</code>.  If we try
to access any of these in the shell without first importing, we get an
error:</p><pre class="python-interpreter">
&gt;&gt;&gt; n
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'n' is not defined
&gt;&gt;&gt; print_thrice(&quot;ouch!&quot;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'print_thrice' is not defined
</pre><p>If we import everything from <code>tryme.py</code>, however, we can use
everything defined in it:</p><pre class="python-interpreter">
&gt;&gt;&gt; from tryme import *
&gt;&gt;&gt; n
42
&gt;&gt;&gt; s
'And now for something completely different...'
&gt;&gt;&gt; print_thrice(&quot;Yipee!&quot;)
Yipee! Yipee! Yipee!
&gt;&gt;&gt;
</pre><p>Note that you do not include the <code>.py</code> from the script name
in the import statement.</p></dd><dt>argument:</dt><dd>A value provided to a function when the function is called.  This value is
assigned to the corresponding parameter in the function.</dd><dt>function composition:</dt><dd>Using the output from one function call as the input to another.</dd><dt>local variable:</dt><dd>A variable defined inside a function.  A local variable can only be used
inside its function.</dd><dt>stack diagram:</dt><dd>A graphical representation of a stack of functions, their variables, and
the values to which they refer.</dd><dt>frame:</dt><dd>A box in a stack diagram that represents a function call.  It contains the
local variables and parameters of the function.</dd><dt>traceback:</dt><dd>A list of the functions that are executing, printed when a runtime error
occurs.</dd></dl><h2>3.8 Exercises<a name="auto7"></a></h2><ol><li><div class="exercise">
Using a text editor, create a Python script named <code>tryme3.py</code> .
Write a function in this file called <code>nine_lines</code> that uses
<code>three_lines</code> to print nine blank lines.  Now add a function named
<code>clear_screen</code> that prints out twenty-five blank lines.  The last
line of your program should be a <em>call</em> to <code>clear_screen</code>.
</div></li><li><div class="exercise">
Move the last line of <code>tryme3.py</code> to the top of the program,
so the <em>function call</em> to <code>clear_screen</code> appears before the
<em>function definition</em>. Run the program and record what error message
you get.  Can you state a rule about <em>function definitions</em> and
<em>function calls</em> which describes where they can appear relative to each
other in a program?
</div></li><li><div class="exercise">
Starting with a working version of <code>tryme3.py</code> , move the definition
of <code>new_line</code> after the definition of <code>three_lines</code>.
Record what happens when you run this program.  Now move the definition of
<code>new_line</code> below a call to <code>three_lines()</code>. Explain how
this is an example of the rule you stated in the previous exercise.
</div></li><li><div class="exercise"><p>Fill in the <em>body</em> of the <em>function definition</em> for
<code>cat_n_times</code> so that it will print the string, s, n times:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">cat_n_times</span>(<span class="py-src-parameter">s</span>, <span class="py-src-parameter">n</span>):
    &lt;<span class="py-src-variable">fill</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">your</span> <span class="py-src-variable">code</span> <span class="py-src-variable">here</span>&gt;
</pre><p>Save this function in a script named <code>import_test.py</code>.
Now at a unix prompt, make sure you are in the same directory where
the <code>import_test.py</code> is located (<code>ls</code> should
show <code>import_test.py</code>).  Start a Python shell and try the
following:</p><pre class="python-interpreter">
&gt;&gt;&gt; from import_test import *
&gt;&gt;&gt; cat_n_times('Spam', 7)
SpamSpamSpamSpamSpamSpamSpam
</pre><p>If all is well, your session should work the same as this one.  Experiment
with other calls to <code>cat_n_times</code> until you feel comfortable with
how it works.</p></div></li></ol></div><p><a href="index.xhtml">Table of Contents</a> |
    <a href="dex.xhtml">Index</a></p></body></html>