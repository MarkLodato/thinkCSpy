<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><title>How to Think Like a Computer Scientist: 10. Modules and files</title><link href="stylesheet.css" type="text/css" rel="stylesheet" /></head><body bgcolor="white"><h1 class="title">10. Modules and files</h1><div class="toc"><ol><li><a href="#auto0">Modules</a></li><li><a href="#auto1">pydoc</a></li><li><a href="#auto2">Creating modules</a></li><li><a href="#auto3">Namespaces</a></li><li><a href="#auto4">Attributes and the dot operator</a></li><li><a href="#auto5">String and list methods</a></li><li><a href="#auto6">Reading and writing text files</a></li><li><a href="#auto7">Text files</a></li><li><a href="#auto8">Directories</a></li><li><a href="#auto9">Counting Letters</a></li><li><a href="#auto10">Glossary</a></li><li><a href="#auto11">Exercises</a></li></ol></div><div class="content"><span></span><h2>10.1 Modules<a name="auto0"></a></h2><a name="index01"></a><a name="index02"></a><a name="index03"></a><a name="index04"></a><p>A <b>module</b> is a file containing Python definitions and statements
intended for use in other Python programs.  There are many Python modules that
come with Python as part of the <b>standard library</b>.  We have seen two of
these already, the <code>doctest</code> module and the <code>string</code>
module.</p><h2>10.2 pydoc<a name="auto1"></a></h2><a name="index05"></a><a name="index06"></a><p>You can use <b>pydoc</b> to search through the Python libraries installed on
your system.  At the <b>command prompt</b> type the following:</p><pre class="shell">
$ pydoc -g
</pre><p>and the following will appear:</p><p><img src="illustrations/pydoc_tk.png" /></p><p>(<em>note</em>: see exercise 2 if you get an error)</p><p>Click on the <q>open browser</q> button to launch a web browser window
containing the documentation generated by <code>pydoc</code>:</p><p><img src="illustrations/pydoc_firefox.png" /></p><p>This is a listing of all the python libraries found by Python on your
system.  Clicking on a module name opens a new page with documenation for
that module.  Clicking <code>keyword</code>, for example, opens the following
page:</p><p><img src="illustrations/pydoc_keyword_firefox.png" /></p><p>Documentation for most modules contains three color coded sections:</p><ul><li><em>Classes</em> in pink</li><li><em>Functions</em> in orange</li><li><em>Data</em> in green</li></ul><p>Classes will be discussed in later chapters, but for now we can use pydoc
to see the functions and data contained within modules.</p><p>The <code>keyword</code> module contains a single function,
<code>iskeyword</code>, which as its name suggests is a boolean function
that returns <code>True</code> if a string passed to it is a keyword:</p><pre class="python-interpreter">
&gt;&gt;&gt; from keyword import *
&gt;&gt;&gt; iskeyword('for')
True
&gt;&gt;&gt; iskeyword('all')
False
&gt;&gt;&gt;
</pre><p>The data item, <code>kwlist</code> contains a list of all the current
keywords in Python:</p><pre class="python-interpreter">
&gt;&gt;&gt; from keyword import *
&gt;&gt;&gt; print kwlist
['and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif',
'else', 'except', 'exec', 'finally', 'for', 'from', 'global', 'if', 'import',
'in', 'is', 'lambda', 'not', 'or', 'pass', 'print', 'raise', 'return', 'try',
'while', 'with', 'yield']
&gt;&gt;&gt;
</pre><p>We encourage you to use <code>pydoc</code> to explore the extensive
libraries that come with Python.  There are so many treasures to discover!</p><h2>10.3 Creating modules<a name="auto2"></a></h2><a name="index07"></a><p>All we need to create a module is a text file with a <code>.py</code>
extension on the filename:</p><pre class="python">
<span class="py-src-comment">#  seqtools.py
</span><span class="py-src-comment">#
</span><span class="py-src-keyword">def</span> <span class="py-src-identifier">remove_at</span>(<span class="py-src-parameter">pos</span>, <span class="py-src-parameter">seq</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">seq</span>[:<span class="py-src-variable">pos</span>] + <span class="py-src-variable">seq</span>[<span class="py-src-variable">pos</span>+<span class="py-src-number">1</span>:]
</pre><p>We can now use our module in both scripts and the Python shell.  To do so,
we must first <em>import</em> the module.  There are two ways to do this:</p><pre class="python-interpreter">
&gt;&gt;&gt; from seqtools import remove_at
&gt;&gt;&gt; s = &quot;A string!&quot;
&gt;&gt;&gt; remove_at(4, s)
'A sting!'
</pre><p>and:</p><pre class="python-interpreter">
&gt;&gt;&gt; import seqtools
&gt;&gt;&gt; s = &quot;A string!&quot;
&gt;&gt;&gt; seqtools.remove_at(4, s)
'A sting!'
</pre><p>In the first example, <code>remove_at</code> is called just like the 
functions we have seen previously.  In the second example the name of the
module and a dot (.) are written before the function name.</p><p>Notice that in either case we do not include the <code>.py</code> file
extension when importing.  Python expects the file names of Python modules to
end in <code>.py</code>, so the file extention is not included in the
<b>import statement</b>.</p><p>The use of modules makes it possible to break up very large programs into
managable sized parts, and to keep related parts together.</p><h2>10.4 Namespaces<a name="auto3"></a></h2><a name="index08"></a><a name="index09"></a><p>A <b>namespace</b> is a syntactic container which permits the same name
to be used in different modules or functions (and as we will see soon, in
classes and methods).</p><p>Each module determines its own namespace, so we can use the same name
in multiple modules without causing an identification problem.</p><pre class="python">
<span class="py-src-comment"># module1.py
</span>
<span class="py-src-variable">question</span> = <span class="py-src-string">&quot;What is the meaning of life, the Universe, and everything?&quot;</span>
<span class="py-src-variable">answer</span> = <span class="py-src-number">42</span>
</pre><pre class="python">
<span class="py-src-comment"># module2.py
</span>
<span class="py-src-variable">question</span> = <span class="py-src-string">&quot;What is your quest?&quot;</span>
<span class="py-src-variable">answer</span> = <span class="py-src-string">&quot;To seek the holy grail.&quot;</span>
</pre><p>We can now import both modules and access <code>question</code> and
<code>answer</code> in each:</p><pre class="python-interpreter">
&gt;&gt;&gt; import module1
&gt;&gt;&gt; import module2
&gt;&gt;&gt; print module1.question
What is the meaning of life, the Universe, and everything?
&gt;&gt;&gt; print module2.question
What is your quest?
&gt;&gt;&gt; print module1.answer
42
&gt;&gt;&gt; print module2.answer
To seek the holy grail.
&gt;&gt;&gt;
</pre><p>If we had used <code>from module1 import *</code> and
<code>from module2 import *</code> instead, we would have a
<b>naming collision</b> and would not be able to access <code>question</code>
and <code>answer</code> from <code>module1</code>.</p><p>Functions also have their own namespace:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">f</span>():
    <span class="py-src-variable">n</span> = <span class="py-src-number">7</span>
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;printing n inside of f: %d&quot;</span>  % <span class="py-src-variable">n</span>

<span class="py-src-keyword">def</span> <span class="py-src-identifier">g</span>():
    <span class="py-src-variable">n</span> = <span class="py-src-number">42</span>
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;printing n inside of g: %d&quot;</span>  % <span class="py-src-variable">n</span>

<span class="py-src-variable">n</span> = <span class="py-src-number">11</span>
<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;printing n before calling f: %d&quot;</span>  % <span class="py-src-variable">n</span>
<span class="py-src-variable">f</span>()
<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;printing n after calling f: %d&quot;</span>  % <span class="py-src-variable">n</span>
<span class="py-src-variable">g</span>()
<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;printing n after calling g: %d&quot;</span>  % <span class="py-src-variable">n</span>
</pre><p>Running this program produces the following output:</p><pre class="shell">
printing n before calling f: 11
printing n inside of f: 7
printing n after calling f: 11
printing n inside of g: 42
printing n after calling g: 11
</pre><p>The three <code>n</code>'s here do not collide since they are each in a
different namepace.</p><p>Namespaces permit several programmers to work on the same project without
having naming collisions.</p><h2>10.5 Attributes and the dot operator<a name="auto4"></a></h2><a name="index10"></a><a name="index11"></a><a name="index12"></a><a name="index13"></a><a name="index14"></a><p>Variables defined inside a module are called <b>attributes</b> of the
module.  They are accessed by using the <b>dot operator</b> (<code>.</code>).
The <code>question</code> attribute of <code>module1</code> and
<code>module2</code> are accessed using <code>module1.question</code> and
<code>module2.question</code>.</p><p>Modules contain functions as well as attributes, and the dot operator is
used to access them in the same way. <code>seqtools.remove_at</code> refers to
the <code>remove_at</code> function in the <code>seqtools</code> module.</p><p>In Chapter 7 we introduced the <code>find</code> function from the
<code>string</code> module.  The <code>string</code> module contains many
other useful functions:</p><pre class="python-interpreter">
&gt;&gt;&gt; import string
&gt;&gt;&gt; string.capitalize('maryland')
'Maryland'
&gt;&gt;&gt; string.capwords(&quot;what's all this, then, amen?&quot;)
&quot;What's All This, Then, Amen?&quot;
&gt;&gt;&gt; string.center('How to Center Text Using Python', 70)
'                   How to Center Text Using Python                    '
&gt;&gt;&gt; string.upper('angola')
'ANGOLA'
&gt;&gt;&gt; 
</pre><p>You should use pydoc to browse the other functions and attributes in the
string module.</p><h2>10.6 String and list methods<a name="auto5"></a></h2><a name="index15"></a><a name="index16"></a><a name="index17"></a><a name="index18"></a><p>As the Python language developed, most of functions from the
<code>string</code> module have also been added as <b>methods</b> of string
objects.  A method acts much like a function, but the syntax for calling
it is a bit different:</p><pre class="python-interpreter">
&gt;&gt;&gt; 'maryland'.capitalize()
'Maryland'
&gt;&gt;&gt; &quot;what's all this, then, amen?&quot;.title()
&quot;What'S All This, Then, Amen?&quot;
&gt;&gt;&gt; 'How to Center Text Using Python'.center(70)
'                   How to Center Text Using Python                    '
&gt;&gt;&gt; 'angola'.upper()
'ANGOLA'
&gt;&gt;&gt;
</pre><p>String methods are built into string objects, and they are <em>invoked</em>
(called) by following the object with the dot operator and the method name.</p><p>We will be learning how to create our own objects with their own methods in
later chapters.  For now we will only be using methods that come with Python's
built-in objects.</p><p>The dot operator can also be used to access built-in methods of list
objects:</p><pre class="python-interpreter">
&gt;&gt;&gt; mylist = []
&gt;&gt;&gt; mylist.append(5)
&gt;&gt;&gt; mylist.append(27)
&gt;&gt;&gt; mylist.append(3)
&gt;&gt;&gt; mylist.append(12)
&gt;&gt;&gt; mylist
[5, 27, 3, 12]
&gt;&gt;&gt;
</pre><p><code>append</code> is a list method which adds the argument passed to it to 
the end of the list.  Continuing with this example, we several other list
methods:</p><pre class="python-interpreter">
&gt;&gt;&gt; mylist.insert(1, 12)
&gt;&gt;&gt; mylist
[5, 12, 27, 3, 12]
&gt;&gt;&gt; mylist.count(12)
2
&gt;&gt;&gt; mylist.extend([5, 9, 5, 11])
&gt;&gt;&gt; mylist
[5, 12, 27, 3, 12, 5, 9, 5, 11])
&gt;&gt;&gt; mylist.index(9)
6
&gt;&gt;&gt; mylist.count(5)
3
&gt;&gt;&gt; mylist.reverse()
&gt;&gt;&gt; mylist
[11, 5, 9, 5, 12, 3, 27, 12, 5]
&gt;&gt;&gt; mylist.sort()
&gt;&gt;&gt; mylist
[3, 5, 5, 5, 9, 11, 12, 12, 27]
&gt;&gt;&gt; mylist.remove(12)
&gt;&gt;&gt; mylist
[3, 5, 5, 5, 9, 11, 12, 27]
&gt;&gt;&gt;
</pre><p>Experiment with the list methods in this example until you feel confident
that you understand how they work.</p><h2>10.7 Reading and writing text files<a name="auto6"></a></h2><a name="index19"></a><a name="index20"></a><a name="index21"></a><p>While a program is running, its data is stored in
<em>random access memory</em> (RAM).  RAM is fast and inexpensive, but it is
also <b>volatile</b>, which means that when the program ends, or the computer
shuts down, data in RAM disappears.  To make data available the next time you
turn on your computer and start your program, you have to write it to a
<b>non-volatile</b> storage medium, such a hard drive, usb drive, or CD-RW.</p><p>Data on non-volatile storage media is stored in named locations on the
media called <b>files</b>.  By reading and writing files, programs can save
information between program runs.</p><p>Working with files is a lot like working with a notebook.  To use a
notebook, you have to open it.  When you're done, you have to close it.  While
the notebook is open, you can either write in it or read from it.  In either
case, you know where you are in the notebook.  You can read the whole notebook
in its natural order or you can skip around.</p><p>All of this applies to files as well.  To open a file, you specify its name
and indicate whether you want to read or write.</p><p>Opening a file creates a file object.  In this example, the variable
<code>myfile</code> refers to the new file object.</p><pre class="python-interpreter">
&gt;&gt;&gt; myfile = open('test.dat', 'w')
&gt;&gt;&gt; print myfile
&lt;open file 'test.dat', mode 'w' at 0x2aaaaab80cd8&gt;
</pre><p>The open function takes two arguments.  The first is the name of the file,
and the second is the <b>mode</b>.  Mode <code>'w'</code> means that we are
opening the file for writing.</p><p>If there is no file named <code>test.dat</code>, it will be created.  If
there already is one, it will be replaced by the file we are writing.</p><p>When we print the file object, we see the name of the file, the mode, and
the location of the object.</p><p>To put data in the file we invoke the <code>write</code> method on the file
object:</p><pre class="python-interpreter">
&gt;&gt;&gt; myfile.write(&quot;Now is the time&quot;)
&gt;&gt;&gt; myfile.write(&quot;to close the file&quot;)
</pre><p>Closing the file tells the system that we are done writing and makes the
file available for reading:</p><pre class="python-interpreter">
&gt;&gt;&gt; myfile.close()
</pre><p>Now we can open the file again, this time for reading, and read the contents 
into a string.  This time, the mode argument is <code>'r'</code> for reading:
</p><pre class="python-interpreter">
&gt;&gt;&gt; myfile = open('test.dat', 'r')
</pre><p>If we try to open a file that doesn't exist, we get an error:</p><a name="index22"></a><pre class="python-interpreter">
&gt;&gt;&gt; myfile = open('test.cat', 'r')
IOError: [Errno 2] No such file or directory: 'test.cat'
</pre><p>Not surprisingly, the <code>read</code> method reads data from the file.
With no arguments, it reads the entire contents of the file into a single
string:</p><pre class="python-interpreter">
&gt;&gt;&gt; text = myfile.read()
&gt;&gt;&gt; print text
Now is the timeto close the file
</pre><p>There is no space between <q>time</q> and <q>to</q> because we did not write 
a space between the strings.</p><p><code>read</code> can also take an argument that indicates how many
characters to read:</p><pre class="python-interpreter">
&gt;&gt;&gt; myfile = open('test.dat', 'r')
&gt;&gt;&gt; print myfile.read(5)
Now i
</pre><p>If not enough characters are left in the file, <code>read</code> returns the 
remaining characters.  When we get to the end of the file, <code>read</code>
returns the empty string:</p><pre class="python-interpreter">
&gt;&gt;&gt; print myfile.read(1000006)
s the timeto close the file
&gt;&gt;&gt; print myfile.read()
   
&gt;&gt;&gt;
</pre><p>The following function copies a file, reading and writing up to fifty
characters at a time.  The first argument is the name of the original file; the 
second is the name of the new file:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">copy_file</span>(<span class="py-src-parameter">oldfile</span>, <span class="py-src-parameter">newfile</span>):
    <span class="py-src-variable">infile</span> = <span class="py-src-variable">open</span>(<span class="py-src-variable">oldfile</span>, <span class="py-src-string">'r'</span>)
    <span class="py-src-variable">outfile</span> = <span class="py-src-variable">open</span>(<span class="py-src-variable">newfile</span>, <span class="py-src-string">'w'</span>)
    <span class="py-src-keyword">while</span> <span class="py-src-variable">True</span>:
        <span class="py-src-variable">text</span> = <span class="py-src-variable">infile</span>.<span class="py-src-variable">read</span>(<span class="py-src-number">50</span>)
        <span class="py-src-keyword">if</span> <span class="py-src-variable">text</span> == <span class="py-src-string">&quot;&quot;</span>:
            <span class="py-src-keyword">break</span>
        <span class="py-src-variable">outfile</span>.<span class="py-src-variable">write</span>(<span class="py-src-variable">text</span>)
    <span class="py-src-variable">infile</span>.<span class="py-src-variable">close</span>()
    <span class="py-src-variable">outfile</span>.<span class="py-src-variable">close</span>()
    <span class="py-src-keyword">return</span>
</pre><p>This functions continues looping, reading 50 characters from
<code>infile</code> and writing the same 50 charaters to <code>outfile</code>
until the end of <code>infile</code> is reached, at which point
<code>text</code> is empty and the <code>break</code> statement is executed.
</p><h2>10.8 Text files<a name="auto7"></a></h2><a name="index23"></a><a name="index24"></a><a name="index25"></a><a name="index26"></a><p>A <b>text file</b> is a file that contains printable characters and
whitespace, organized into lines separated by newline characters.  Since Python 
is specifically designed to process text files, it provides methods that make
the job easy.</p><p>To demonstrate, we'll create a text file with three lines of text separated
by newlines:</p><pre class="python-interpreter">
&gt;&gt;&gt; outfile = open(&quot;test.dat&quot;,&quot;w&quot;)
&gt;&gt;&gt; outfile.write(&quot;line one\nline two\nline three\n&quot;)
&gt;&gt;&gt; outfile.close()
</pre><p>The <code>readline</code> method reads all the characters up to and
including the next newline character:</p><pre class="python-interpreter">
&gt;&gt;&gt; infile = open(&quot;test.dat&quot;,&quot;r&quot;)
&gt;&gt;&gt; print inf.readline()
line one
   
&gt;&gt;&gt;
</pre><p><code>readlines</code> returns all of the remaining lines as a list of
strings:</p><pre class="python-interpreter">
&gt;&gt;&gt; print infile.readlines()
['line two\012', 'line three\012']
</pre><p>In this case, the output is in list format, which means that the strings
appear with quotation marks and the newline character appears as the escape
sequence <code>\\012</code>.</p><p>At the end of the file, <code>readline</code> returns the empty string
and <code>readlines</code> returns the empty list:</p><pre class="python-interpreter">
&gt;&gt;&gt; print infile.readline()
   
&gt;&gt;&gt; print infile.readlines()
[]
</pre><p>The following is an example of a line-processing program.
<code>filter</code> makes a copy of <code>oldfile</code>, omitting any
lines that begin with <code>#</code>:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">filter</span>(<span class="py-src-parameter">oldfile</span>, <span class="py-src-parameter">newfile</span>):
    <span class="py-src-variable">infile</span> = <span class="py-src-variable">open</span>(<span class="py-src-variable">oldfile</span>, <span class="py-src-string">'r'</span>)
    <span class="py-src-variable">outfile</span> = <span class="py-src-variable">open</span>(<span class="py-src-variable">newfile</span>, <span class="py-src-string">'w'</span>)
    <span class="py-src-keyword">while</span> <span class="py-src-variable">True</span>:
        <span class="py-src-variable">text</span> = <span class="py-src-variable">infile</span>.<span class="py-src-variable">readline</span>()
        <span class="py-src-keyword">if</span> <span class="py-src-variable">text</span> == <span class="py-src-string">&quot;&quot;</span>:
           <span class="py-src-keyword">break</span>
        <span class="py-src-keyword">if</span> <span class="py-src-variable">text</span>[<span class="py-src-number">0</span>] == <span class="py-src-string">'#'</span>:
           <span class="py-src-keyword">continue</span>
        <span class="py-src-variable">outfile</span>.<span class="py-src-variable">write</span>(<span class="py-src-variable">text</span>)
    <span class="py-src-variable">infile</span>.<span class="py-src-variable">close</span>()
    <span class="py-src-variable">outfile</span>.<span class="py-src-variable">close</span>()
    <span class="py-src-keyword">return</span>
</pre><p>The <b>continue statement</b> ends the current iteration of the loop,
but continues looping.  The flow of execution moves to the top of the loop,
checks the condition, and proceeds accordingly.</p><p>Thus, if <code>text</code> is the empty string, the loop exits.  If the
first character of <code>text</code> is a hash mark, the flow of execution goes 
to the top of the loop.  Only if both conditions fail do we copy
<code>text</code> into the new file.</p><h2>10.9 Directories<a name="auto8"></a></h2><a name="index27"></a><a name="index28"></a><a name="index29"></a><a name="index30"></a><p>Files on non-volatile storage media are organized by a set of rules known
as a <b>file system</b>.  File systems are made up of files and
<b>directories</b>, which are containers for both files and other directories.
</p><p>When you create a new file by opening it and writing, the new file goes in
the current directory (wherever you were when you ran the program).  Similarly, 
when you open a file for reading, Python looks for it in the current directory.
</p><p>If you want to open a file somewhere else, you have to specify the
<b>path</b> to the file, which is the name of the directory (or folder) where
the file is located:</p><pre class="python-interpreter">
&gt;&gt;&gt; wordsfile = open('/usr/share/dict/words', 'r')
&gt;&gt;&gt; wordlist = wordsfile.readlines()
&gt;&gt;&gt; print wordlist[:5]
['\n', 'A\n', &quot;A's\n&quot;, 'AOL\n', &quot;AOL's\n&quot;, 'Aachen\n']
</pre><p>This example opens a file named <code>words</code> that resides in a
directory named <code>dict</code>, which resides in <code>share</code>, which
resides in <code>usr</code>, which resides in the top-level directory of the
system, called <code>/</code>.  It then reads in each line into a list using
<code>readlines</code>, and prints out the first 5 elements from that list.</p><p>You cannot use <code>/</code> as part of a filename; it is reserved as a
<b>delimiter</b> between directory and filenames.</p><p>The file <code>/usr/share/dict/words</code> should exist on unix based
systems, and contains a list of words in alphabetical order.</p><h2>10.10 Counting Letters<a name="auto9"></a></h2><a name="index31"></a><a name="index32"></a><a name="index33"></a><a name="index34"></a><p>The <code>ord</code> function returns the integer representation of a
character:</p><pre class="python-interpreter">
&gt;&gt;&gt; ord('a')
97
&gt;&gt;&gt; ord('A')
65
&gt;&gt;&gt;
</pre><p>This example explains why <code>'Apple' &lt; 'apple'</code> evaluates to
<code>True</code>.</p><p>The <code>chr</code> function is the inverse of <code>ord</code>.  It
takes an integer as an argument and returns its character representation:</p><pre class="python-interpreter">
&gt;&gt;&gt; for i in range(65, 71):
...     print chr(i)
...
A
B
C
D
E
F
&gt;&gt;&gt;
</pre><p>The following program, <code>countletters.py</code> counts the number of
times each character occurs in the book
<a href="resources/ch10/alice_in_wonderland.txt">Alice in Wonderland</a>:</p><pre class="python">
<span class="py-src-comment">#
</span><span class="py-src-comment"># countletters.py
</span><span class="py-src-comment">#
</span>
<span class="py-src-keyword">def</span> <span class="py-src-identifier">display</span>(<span class="py-src-parameter">i</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">i</span> == <span class="py-src-number">10</span>: <span class="py-src-keyword">return</span> <span class="py-src-string">'LF'</span>
    <span class="py-src-keyword">if</span> <span class="py-src-variable">i</span> == <span class="py-src-number">13</span>: <span class="py-src-keyword">return</span> <span class="py-src-string">'CR'</span> 
    <span class="py-src-keyword">if</span> <span class="py-src-variable">i</span> == <span class="py-src-number">32</span>: <span class="py-src-keyword">return</span> <span class="py-src-string">'SPACE'</span> 
    <span class="py-src-keyword">return</span> <span class="py-src-variable">chr</span>(<span class="py-src-variable">i</span>)

<span class="py-src-variable">infile</span> = <span class="py-src-variable">open</span>(<span class="py-src-string">'alice_in_wonderland.txt'</span>, <span class="py-src-string">'r'</span>)
<span class="py-src-variable">text</span> = <span class="py-src-variable">infile</span>.<span class="py-src-variable">read</span>()
<span class="py-src-variable">infile</span>.<span class="py-src-variable">close</span>()

<span class="py-src-variable">counts</span> = <span class="py-src-number">128</span> * [<span class="py-src-number">0</span>]

<span class="py-src-keyword">for</span> <span class="py-src-variable">letter</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">text</span>:
    <span class="py-src-variable">counts</span>[<span class="py-src-variable">ord</span>(<span class="py-src-variable">letter</span>)] += <span class="py-src-number">1</span>

<span class="py-src-variable">outfile</span> = <span class="py-src-variable">open</span>(<span class="py-src-string">'alice_counts.dat'</span>, <span class="py-src-string">'w'</span>)
<span class="py-src-variable">outfile</span>.<span class="py-src-variable">write</span>(<span class="py-src-string">&quot;%-12s%s\n&quot;</span> % (<span class="py-src-string">&quot;Character&quot;</span>, <span class="py-src-string">&quot;Count&quot;</span>))
<span class="py-src-variable">outfile</span>.<span class="py-src-variable">write</span>(<span class="py-src-string">&quot;=================\n&quot;</span>)

<span class="py-src-keyword">for</span> <span class="py-src-variable">i</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">range</span>(<span class="py-src-variable">len</span>(<span class="py-src-variable">counts</span>)):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">counts</span>[<span class="py-src-variable">i</span>]:
        <span class="py-src-variable">outfile</span>.<span class="py-src-variable">write</span>(<span class="py-src-string">&quot;%-12s%d\n&quot;</span> % (<span class="py-src-variable">display</span>(<span class="py-src-variable">i</span>), <span class="py-src-variable">counts</span>[<span class="py-src-variable">i</span>]))

<span class="py-src-variable">outfile</span>.<span class="py-src-variable">close</span>()
</pre><p>Run this program and look at the output file it generates using a text
editor.  You will be asked to analyze the program in the exercies below.</p><h2>10.11 Glossary<a name="auto10"></a></h2><a name="index35"></a><a name="index36"></a><a name="index37"></a><a name="index38"></a><a name="index39"></a><a name="index40"></a><a name="index41"></a><a name="index42"></a><a name="index43"></a><a name="index44"></a><a name="index45"></a><a name="index46"></a><a name="index47"></a><a name="index48"></a><a name="index49"></a><a name="index50"></a><a name="index51"></a><a name="index52"></a><a name="index53"></a><a name="index54"></a><a name="index55"></a><a name="index56"></a><a name="index57"></a><dl><dt>module:</dt><dd>A file containing Python definitions and statements intended for use
in other Python programs.  The contents of a module are made available to the
other program by using the <code>import</code> statement.</dd><dt>standard library:</dt><dd>A library is a collection of software used as tools in the development
of other software.  The standard library of a programming language is the set
of such tools that are distributed with the core programming language.
Python comes with an extensive standard library.</dd><dt>pydoc:</dt><dd>A documentation generator that comes with the Python standard library.</dd><dt>command prompt:</dt><dd>A string displayed by a 
<a href="http://en.wikipedia.org/wiki/Command_line">command line interface</a>
indicating that commands can be entered.</dd><dt>import statement:</dt><dd>A statement which makes the objects contained in a module available for
use.  There are two forms for the import statement.  Using a hypothetical
module named <code>mymod</code> containing functions <code>f1</code>
and <code>f2</code>, and variables <code>v1</code> and <code>v2</code>,
examples of these two forms include:
<pre class="python">
<span class="py-src-keyword">import</span> <span class="py-src-variable">mymod</span>
</pre>
The first form.
<pre class="python">
<span class="py-src-keyword">from</span> <span class="py-src-variable">mymod</span> <span class="py-src-keyword">import</span> <span class="py-src-variable">f1</span>, <span class="py-src-variable">f2</span>, <span class="py-src-variable">v1</span>, <span class="py-src-variable">v2</span>
</pre>
Import all objects
</dd><dt>namespace:</dt><dd>A syntactic container providing a context for names so that the same name
can reside in different namespaces without ambiguity.  In Python, modules,
classes, functions and methods all form namespaces.</dd><dt>naming collision:</dt><dd>A situation in which two or more names in a given namespace cannot be
unambiguously resolved.  Using
<pre class="python">
<span class="py-src-keyword">import</span> <span class="py-src-variable">string</span>
</pre>
instead of
<pre class="python">
<span class="py-src-keyword">from</span> <span class="py-src-variable">string</span> <span class="py-src-keyword">import</span> *
</pre>
prevents naming collisions.
</dd><dt>attribute:</dt><dd>
A variable defined inside a module (or class or instance -- as we will see
later).  Module attributes are accessed by using the <b>dot operator</b>
(<code>.</code>).
</dd><dt>dot operator:</dt><dd>
The dot operator (<code>.</code>) permits access to attributes and functions
of a module (or attributes and methods of a class or instance -- as we will 
see later).
</dd><dt>method:</dt><dd>
Function-like attribute of an object.  Methods are <em>invoked</em> (called)
on an object using the dot operator.  For example:
<pre class="python-interpreter">
&gt;&gt;&gt; s = &quot;this is a string.&quot;
&gt;&gt;&gt; s.upper()
'THIS IS A STRING.'
&gt;&gt;&gt;
</pre>
We say that the method, <code>upper</code> is invoked on the string,
<code>s</code>.  <code>s</code> is implicitely the first argument to
<code>upper</code>.
</dd><dt>volatile memory:</dt><dd>
Memory which requires an electrical current to maintain state.  The
<em>main memory</em> or RAM of a computer is volatile.  Information stored in
RAM is lost when the computer is turned off.
</dd><dt>non-volatile memory:</dt><dd>
Memory that can maintain its state without power.  Hard drives, flash drives,
and rewritable compact disks (CD-RW) are each examples of non-volatile memory.
</dd><dt>file:</dt><dd>A named entity, usually stored on a hard drive, floppy disk, or CD-ROM,
that contains a stream of characters.</dd><dt>mode:</dt><dd>A distinct method of operation within a computer program.  Files in Python
can be openned in one of three modes: read ('r'), write ('w'), and append ('a').
</dd><dt>path:</dt><dd>A sequence of directory names that specifies the exact location of a file.
</dd><dt>text file:</dt><dd>A file that contains printable characters organized into lines separated
by newline characters.</dd><dt>continue statement:</dt><dd>A statement that causes the current iteration of a loop to end.  The flow
of execution goes to the top of the loop, evaluates the condition, and
proceeds accordingly.</dd><dt>file system:</dt><dd>A method for naming, accessing, and organizing files and the data they
contain.</dd><dt>directory:</dt><dd>A named collection of files, also called a folder. Directories can contain
files and other directories, which are refered to as <em>subdirectories</em>
of the directory that contains them.</dd><dt>path:</dt><dd>The name and location of a file within a file system.  For example:
<pre class="shell">
/usr/share/dict/words
</pre>
indicates a file named <code>words</code> found in the <code>dict</code>
subdirectory of the <code>share</code> subdirectory of the <code>usr</code>
directory.</dd><dt>delimiter:</dt><dd>A sequence of one or more characters used to specify the boundary between
seperate parts of text.</dd></dl><h2>10.12 Exercises<a name="auto11"></a></h2><ol><li><div class="exercise">
Complete the following:
<ul><li>Start the pydoc server with the command <code>pydoc -g</code> at the
  command prompt.</li><li>Click on the <q>open browser</q> button in the pydoc tk window.</li><li>Find the <code>calendar</code> module and click on it.</li><li>While looking at the <em>Functions</em> section, try out the following
  in a Python shell:
  <pre class="python-interpreter">
  &gt;&gt;&gt; import calendar
  &gt;&gt;&gt; year = calendar.calendar(2008)
  &gt;&gt;&gt; print year                      # What happens here?
  </pre></li><li>Experiment with <code>calendar.isleap</code>.  What does it expect as
  an argument?  What does it return as a result?  What kind of a function is
  this?</li></ul>
Make detailed notes about what you learned from this exercise.
</div></li><li><div class="exercise"><p>If you don't have <code>Tkinter</code> installed on your computer, then
<code>pydoc -g</code> will return an error, since the graphics window that
it opens requires <code>Tkinter</code>.  An alternative is to start the web
server directly:</p><pre class="shell">
$ pydoc -p 7464
</pre><p>This starts the pydoc web server on port 7464.  Now point your web browser
at:</p><pre>
http://localhost:7464
</pre><p>and you will be able to browse the Python libraries installed on you
system.</p><p>Use this approach to start <code>pydoc</code> and take a look at the
<code>math</code> module.</p><ol style="list-style-type: lower-alpha;"><li>How many functions are in the <code>math</code> module?</li><li>What does <code>math.ceil</code> do?  What about <code>math.floor</code>?
  (<em>hint:</em> both <code>floor</code> and <code>ceil</code> expect floating
  point arguments.)
  </li><li>Describe how we have been computing the same value as
  <code>math.sqrt</code> without using the <code>math</code> module.</li><li>What are the two data contstants in the <code>math</code> module?</li></ol><p>Record detailed notes of your investigation in this exercise.</p></div></li><li><div class="exercise">
Use <code>pydoc</code> to investigate the <code>copy</code> module.  What does
<code>deepcopy</code> do?  In which exercises from last chapter would
<code>deepcopy</code> have come in handy?
</div></li><li><div class="exercise">
Create a module named <code>mymodule1.py</code>.  Add attributes
<code>myage</code> set to your current age, and <code>year</code> set to the
current year.  Create another module named <code>mymodule2.py</code>.  Add
attributes <code>myage</code> set to 0, and <code>year</code> set to the year
you were born.
<br /><br />
Now create a file named <code>namespace_test.py</code>.  Import both of the
modules above and write the following statement:
<pre class="python">
<span class="py-src-keyword">print</span> (<span class="py-src-variable">mymodule2</span>.<span class="py-src-variable">myage</span> - <span class="py-src-variable">mymodule1</span>.<span class="py-src-variable">myage</span>) == (<span class="py-src-variable">mymodule2</span>.<span class="py-src-variable">year</span> - <span class="py-src-variable">mymodule1</span>.<span class="py-src-variable">year</span>)
</pre>
When you will run <code>namespace_test.py</code> you will see either 
<code>True</code> or <code>False</code> as output depending on whether or not
you've already had your birthday this year.
</div></li><li><div class="exercise">
Add the following statement to <code>mymodule1.py</code>,
<code>mymodule2.py</code>, and <code>namespace_test.py</code> from the previous
exercise:
<pre class="python">
<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;My name is %s&quot;</span> % <span class="py-src-variable">__name__</span>
</pre>
Run <code>namespace_test.py</code>.  What happens?  Why?  Now add the following
to the bottom of <code>mymodule1.py</code>:
<pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">__name__</span> == <span class="py-src-string">'__main__'</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;This won't run if I'm  imported.&quot;</span>
</pre>
Run <code>mymodule1.py</code> and <code>namespace_test.py</code> again.  In
which case do you see the new print statement? 
</div></li><li><div class="exercise">
In a Python shell try the following:
<pre class="python-shell">
&gt;&gt;&gt; import this
</pre>
What does Tim Peter's have to say about namespaces?
</div></li><li><div class="exercise">
Use <code>pydoc</code> to find and test three other functions from the
<code>string</code> module.  Record your findings.
</div></li><li><div class="exercise">
Rewrite <code>matrix_mult</code> from the last chapter using what you have
learned about list methods.
</div></li><li><div class="exercise"><a name="index58"></a><a name="index59"></a>
The <code>dir</code> function, which we first saw in Chapter 7, prints out
a list of the <em>attributes</em> of an object passed to it as an argument.
In other words, <code>dir</code> returns the contents of the <em>namespace</em>
of its argument.
<br /><br />
Use <code>dir(str)</code> and <code>dir(list)</code> to find at least three
string and list methods which have not been introduced in the examples in the
chapter.  You should ignore anything that begins with double underscore (__)
for the time being.  Be sure to make detailed notes of your findings, including 
names of the new methods and examples of their use.
<br /><br />
(<em>hint:</em>  Print the docstring of a function you want to explore.  For
example, to find out how <code>str.join</code> works,
<code>print str.join.__doc__</code>)
</div></li><li><div class="exercise">
Give the Python interpreter's response to each of the following from a
continuous interpreter session:
<ol style="list-style-type: lower-alpha;"><li><pre class="python-interpreter">
  &gt;&gt;&gt; s = &quot;If we took the bones out it wouldn't be crunchy would it?&quot;
  &gt;&gt;&gt; s.split()
  </pre></li><li><pre class="python-interpreter">
  &gt;&gt;&gt; type(s.split())
  </pre></li><li><pre class="python-interpreter">
  &gt;&gt;&gt; s.split('o')
  </pre></li><li><pre class="python-interpreter">
  &gt;&gt;&gt; s.split('i')
  </pre></li><li><pre class="python-interpreter">
  &gt;&gt;&gt; '0'.join(s.split('o'))
  </pre></li></ol>
Be sure you understand why you get each result.  Then apply what you have
learned to fill in the body of the function below using the <code>split</code>
and <code>join</code> methods of <code>str</code> objects:
<pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">myreplace</span>(<span class="py-src-parameter">old</span>, <span class="py-src-parameter">new</span>, <span class="py-src-parameter">s</span>):
    <span class="py-src-string">&quot;&quot;&quot;
    Replace all occurances of old with new in the string s.

       &gt;&gt;&gt; myreplace(',', ';', 'this, that, and, some, other, thing')
       'this; that; and; some; other; thing'
       &gt;&gt;&gt; myreplace(' ', '**', 'Words will now be seperated by stars.')
       'Words**will**now**be**seperated**by**stars.'
    &quot;&quot;&quot;</span>
</pre>
Your solution should pass all doctests.
</div></li><li><div class="exercise">
Create a module named <code>wordtools.py</code> with the following at the
bottom:
<pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">__name__</span> == <span class="py-src-string">'__main__'</span>:
    <span class="py-src-keyword">import</span> <span class="py-src-variable">doctest</span>
    <span class="py-src-variable">doctest</span>.<span class="py-src-variable">testmod</span>()
</pre> 
Explain how this statement makes both using and testing this module convenient.
What will be the value of <code>__name__</code> when <code>wordtools.py</code>
is imported from another module?  What will it be when it is run as a main
program?  In which case will the doctests run?
<br /><br />
Now add bodies to each of the following functions to make the doctests pass:
<pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">cleanword</span>(<span class="py-src-parameter">word</span>):
    <span class="py-src-string">&quot;&quot;&quot;
      &gt;&gt;&gt; cleanword('what?')
      'what?'
      &gt;&gt;&gt; cleanword('&quot;now!&quot;')
      'now'
    &quot;&quot;&quot;</span>

<span class="py-src-keyword">def</span> <span class="py-src-identifier">has_dashdash</span>(<span class="py-src-parameter">s</span>):
    <span class="py-src-string">&quot;&quot;&quot;
      &gt;&gt;&gt; has_dashdash('distance--but')
      True
      &gt;&gt;&gt; has_dashdash('several')
      False
      &gt;&gt;&gt; has_dashdash('critters')
      False
      &gt;&gt;&gt; has_dashdash('spoke--fancy')
      True
    &quot;&quot;&quot;</span>
</pre>
Save this module so you can use the tools it contains in your programs.
</div></li><li><div class="exercise"><a href="resources/ch10/unsorted_fruits.txt">unsorted_fruits.txt</a>
contains a list of 26 fruits, each one with a name that begins with a different 
letter of the alphabet.
<br /><br />
Write a program named <code>sort_fruits.py</code> that reads in the fruits
from <code>unsorted_fruits.txt</code> and writes them out in alphabetical order
to a file named <code>sorted_fruits.txt</code>.
</div></li><li><div class="exercise">
Answer the following questions about <code>countletters.py</code>:
<ol style="list-style-type: lower-alpha;"><li>Explain in detail what the three lines do:
  <pre class="python">
<span class="py-src-variable">infile</span> = <span class="py-src-variable">open</span>(<span class="py-src-string">'alice_in_wonderland.txt'</span>, <span class="py-src-string">'r'</span>)
<span class="py-src-variable">text</span> = <span class="py-src-variable">infile</span>.<span class="py-src-variable">read</span>()
<span class="py-src-variable">infile</span>.<span class="py-src-variable">close</span>()
</pre>
  What is would <code>type(text)</code> return after these lines have been
  executed?</li><li>What does the expression <code>128 * [0]</code> evaluate to?  Read about
  <a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a> in Wikipedia and
  explain why you think the variable, <code>counts</code> is assigned to
  <code>128 * [0]</code> in light of what you read.</li><li>What does
  <pre class="python">
<span class="py-src-keyword">for</span> <span class="py-src-variable">letter</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">text</span>:
    <span class="py-src-variable">counts</span>[<span class="py-src-variable">ord</span>(<span class="py-src-variable">letter</span>)] += <span class="py-src-number">1</span>
</pre>
  do to <code>counts</code>?</li><li>Explain the purpose of the <code>display</code> function.  Why does it
  check for values <code>10</code>, <code>13</code>, and <code>32</code>?
  What is special about those values?</li><li>Describe in detail what the lines
  <pre class="python">
<span class="py-src-variable">outfile</span> = <span class="py-src-variable">open</span>(<span class="py-src-string">'alice_counts.dat'</span>, <span class="py-src-string">'w'</span>)
<span class="py-src-variable">outfile</span>.<span class="py-src-variable">write</span>(<span class="py-src-string">&quot;%-12s%s\n&quot;</span> % (<span class="py-src-string">&quot;Character&quot;</span>, <span class="py-src-string">&quot;Count&quot;</span>))
<span class="py-src-variable">outfile</span>.<span class="py-src-variable">write</span>(<span class="py-src-string">&quot;=================\n&quot;</span>)
</pre>
  do.  What will be in <code>alice_counts.dat</code> when they finish
  executing?</li><li>Finally, explain in detail what
  <pre class="python">
<span class="py-src-keyword">for</span> <span class="py-src-variable">i</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">range</span>(<span class="py-src-variable">len</span>(<span class="py-src-variable">counts</span>)):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">counts</span>[<span class="py-src-variable">i</span>]:
        <span class="py-src-variable">outfile</span>.<span class="py-src-variable">write</span>(<span class="py-src-string">&quot;%-12s%d\n&quot;</span> % (<span class="py-src-variable">display</span>(<span class="py-src-variable">i</span>), <span class="py-src-variable">counts</span>[<span class="py-src-variable">i</span>]))
</pre>
  does.  What is the purpose of <code>if counts[i]</code>?</li></ol></div></li></ol></div><p><a href="index.xhtml">Table of Contents</a> |
    <a href="dex.xhtml">Index</a></p></body></html>