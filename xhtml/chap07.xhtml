<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><title>How to Think Like a Computer Scientist: 7. Strings</title><link href="stylesheet.css" type="text/css" rel="stylesheet" /></head><body bgcolor="white"><h1 class="title">7. Strings</h1><div class="toc"><ol><li><a href="#auto0">A compound data type</a></li><li><a href="#auto1">Length</a></li><li><a href="#auto2">Traversal and the for loop</a></li><li><a href="#auto3">String slices</a></li><li><a href="#auto4">String comparison</a></li><li><a href="#auto5">Strings are immutable</a></li><li><a href="#auto6">The in operator</a></li><li><a href="#auto7">A find function</a></li><li><a href="#auto8">Looping and counting</a></li><li><a href="#auto9">Optional paramters</a></li><li><a href="#auto10">The string module</a></li><li><a href="#auto11">Character classification</a></li><li><a href="#auto12">String formatting</a></li><li><a href="#auto13">Glossary</a></li><li><a href="#auto14">Exercises</a></li></ol></div><div class="content"><span></span><a name="strings"></a><h2>7.1 A compound data type<a name="auto0"></a></h2><a name="index01"></a><a name="index02"></a><p>So far we have seen five types: <code>int</code>, <code>float</code>, 
<code>bool</code>, <code>NoneType</code> and <code>str</code>.  Strings are
qualitatively different from the other four because they are made up of smaller 
pieces---characters.</p><a name="index03"></a><p>Types that comprise smaller pieces are called <b>compound data
types</b>.  Depending on what we are doing, we may want to treat a
compound data type as a single thing, or we may want to access its parts. This
ambiguity is useful.</p><a name="index04"></a><a name="index05"></a><p>The bracket operator selects a single character from a string:</p><pre class="python-interpreter">
&gt;&gt;&gt; fruit = &quot;banana&quot;
&gt;&gt;&gt; letter = fruit[1]
&gt;&gt;&gt; print letter
</pre><p>The expression <code>fruit[1]</code> selects character number 1 from
<code>fruit</code>.  The variable <code>letter</code> refers to the result.
When we display <code>letter</code>, we get a surprise:</p><pre class="python-interpreter">
a
</pre><p>The first letter of <code>&quot;banana&quot;</code> is not <code>a</code>, unless you 
are a computer scientist.  For perverse reasons, computer scientists always
start counting from zero.  The 0th letter (<q>zero-eth</q>) of
<code>&quot;banana&quot;</code> is <code>b</code>.  The 1th letter (<q>one-eth</q>) is
<code>a</code>, and the 2th (<q>two-eth</q>) letter is <code>n</code>.</p><p>If you want the zero-eth letter of a string, you just put 0, or any
expression with the value 0, in the brackets:</p><pre class="python-interpreter">
&gt;&gt;&gt; letter = fruit[0]
&gt;&gt;&gt; print letter
b
</pre><p>The expression in brackets is called an <b>index</b>.  An index
specifies a member of an ordered set, in this case the set of characters in the 
string.  The index <em>indicates</em> which one you want, hence the name.  It
can be any integer expression.</p><a name="index06"></a><h2>7.2 Length<a name="auto1"></a></h2><a name="index07"></a><a name="index08"></a><p>The <code>len</code> function returns the number of characters in a string:
</p><pre class="python-interpreter">
&gt;&gt;&gt; fruit = &quot;banana&quot;
&gt;&gt;&gt; len(fruit)
6
</pre><p>To get the last letter of a string, you might be tempted to try something
like this:</p><pre class="python">
<span class="py-src-variable">length</span> = <span class="py-src-variable">len</span>(<span class="py-src-variable">fruit</span>)
<span class="py-src-variable">last</span> = <span class="py-src-variable">fruit</span>[<span class="py-src-variable">length</span>]       <span class="py-src-comment"># ERROR!</span>
</pre><p>That won't work. It causes the runtime error
<code class="shell">IndexError: string index out of range</code>.  The reason
is that there is no 6th letter in <code>&quot;banana&quot;</code>.  Since we started
counting at zero, the six letters are numbered 0 to 5.  To get the last
character, we have to subtract 1 from <code>length</code>:</p><a name="index09"></a><pre class="python">
<span class="py-src-variable">length</span> = <span class="py-src-variable">len</span>(<span class="py-src-variable">fruit</span>)
<span class="py-src-variable">last</span> = <span class="py-src-variable">fruit</span>[<span class="py-src-variable">length</span>-<span class="py-src-number">1</span>]
</pre><p>Alternatively, we can use negative indices, which count backward from the
end of the string.  The expression <code>fruit[-1]</code> yields the last
letter, <code>fruit[-2]</code> yields the second to last, and so on.</p><a name="index10"></a><h2>7.3 Traversal and the <code>for</code> loop<a name="auto2"></a></h2><a name="for"></a><a name="index11"></a><a name="index12"></a><a name="index13"></a><a name="index14"></a><p>A lot of computations involve processing a string one character at a time.
Often they start at the beginning, select each character in turn, do something
to it, and continue until the end.  This pattern of processing is called a
<b>traversal</b>.  One way to encode a traversal is with a
<code>while</code> statement:</p><pre class="python">
<span class="py-src-variable">index</span> = <span class="py-src-number">0</span>
<span class="py-src-keyword">while</span> <span class="py-src-variable">index</span> &lt; <span class="py-src-variable">len</span>(<span class="py-src-variable">fruit</span>):
    <span class="py-src-variable">letter</span> = <span class="py-src-variable">fruit</span>[<span class="py-src-variable">index</span>]
    <span class="py-src-keyword">print</span> <span class="py-src-variable">letter</span>
    <span class="py-src-variable">index</span> += <span class="py-src-number">1</span>
</pre><p>This loop traverses the string and displays each letter on a line by itself. 
The loop condition is <code>index &lt; len(fruit)</code>, so when
<code>index</code> is equal to the length of the string, the condition is false,
and the body of the loop is not executed.  The last character accessed is the
one with the index <code>len(fruit)-1</code>, which is the last character in
the string.</p><p>Using an index to traverse a set of values is so common that Python provides 
an alternative, simpler syntax---the <code>for</code> loop:</p><pre class="python">
<span class="py-src-keyword">for</span> <span class="py-src-variable">char</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">fruit</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">char</span>
</pre><p>Each time through the loop, the next character in the string is assigned
to the variable <code>char</code>.  The loop continues until no characters are
left.</p><a name="index15"></a><a name="index16"></a><a name="index17"></a><a name="index18"></a><p>The following example shows how to use concatenation and a <code>for</code>
loop to generate an abecedarian series.  <q>Abecedarian</q> refers to a series
or list in which the elements appear in alphabetical order.  For example, in
Robert McCloskey's book <em>Make Way for Ducklings</em>, the names of the
ducklings are Jack, Kack, Lack, Mack, Nack, Ouack, Pack, and Quack.  This loop
outputs these names in order:</p><pre class="python">
<span class="py-src-variable">prefixes</span> = <span class="py-src-string">&quot;JKLMNOPQ&quot;</span>
<span class="py-src-variable">suffix</span> = <span class="py-src-string">&quot;ack&quot;</span>
   
<span class="py-src-keyword">for</span> <span class="py-src-variable">letter</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">prefixes</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">letter</span> + <span class="py-src-variable">suffix</span>
</pre><p>The output of this program is:</p><pre class="shell">
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
</pre><p>Of course, that's not quite right because <q>Ouack</q> and <q>Quack</q> are
misspelled.  You'll fix this as an exercise below.</p><h2>7.4 String slices<a name="auto3"></a></h2><a name="slice"></a><a name="index19"></a><a name="index20"></a><p>A substring of a string is called a <b>slice</b>.  Selecting a
slice is similar to selecting a character:</p><pre class="python-interpreter">
&gt;&gt;&gt; s = &quot;Peter, Paul, and Mary&quot;
&gt;&gt;&gt; print s[0:5]
Peter
&gt;&gt;&gt; print s[7:11]
Paul
&gt;&gt;&gt; print s[17:21]
Mary
</pre><p>The operator <code>[n:m]</code> returns the part of the string from the
<q>n-eth</q> character to the <q>m-eth</q> character, including the first but
excluding the last.  This behavior is counterintuitive; it makes more sense if
you imagine the indices pointing <em>between</em> the characters, as in the
following diagram:</p><img src="illustrations/banana.png" /><p>If you omit the first index (before the colon), the slice starts at the
beginning of the string.  If you omit the second index, the slice goes to the
end of the string.  Thus:</p><pre class="python-interpreter">
&gt;&gt;&gt; fruit = &quot;banana&quot;
&gt;&gt;&gt; fruit[:3]
'ban'
&gt;&gt;&gt; fruit[3:]
'ana'
</pre><p>What do you think <code>s[:]</code> means?</p><h2>7.5 String comparison<a name="auto4"></a></h2><a name="index21"></a><a name="index22"></a><p>The comparison operators work on strings.  To see if two strings are equal:
</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">word</span> == <span class="py-src-string">&quot;banana&quot;</span>:
    <span class="py-src-keyword">print</span>  <span class="py-src-string">&quot;Yes, we have no bananas!&quot;</span>
</pre><p>Other comparison operations are useful for putting words in alphabetical
order:</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">word</span> &lt; <span class="py-src-string">&quot;banana&quot;</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Your word,&quot;</span> + <span class="py-src-variable">word</span> + <span class="py-src-string">&quot;, comes before banana.&quot;</span>
<span class="py-src-keyword">elif</span> <span class="py-src-variable">word</span> &gt; <span class="py-src-string">&quot;banana&quot;</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Your word,&quot;</span> + <span class="py-src-variable">word</span> + <span class="py-src-string">&quot;, comes after banana.&quot;</span>
<span class="py-src-keyword">else</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Yes, we have no bananas!&quot;</span>
</pre><p>You should be aware, though, that Python does not handle upper- and
lowercase letters the same way that people do.  All the uppercase letters come
before all the lowercase letters.  As a result:</p><pre class="shell">
Your word, Zebra, comes before banana.
</pre><p>A common way to address this problem is to convert strings to a standard
format, such as all lowercase, before performing the comparison.  A more
difficult problem is making the program realize that zebras are not fruit.</p><h2>7.6 Strings are immutable<a name="auto5"></a></h2><a name="index23"></a><a name="index24"></a><a name="index25"></a><p>It is tempting to use the <code>[]</code> operator on the left side of an
assignment, with the intention of changing a character in a string.  For
example:</p><pre class="python">
<span class="py-src-variable">greeting</span> = <span class="py-src-string">&quot;Hello, world!&quot;</span>
<span class="py-src-variable">greeting</span>[<span class="py-src-number">0</span>] = <span class="py-src-string">'J'</span>            <span class="py-src-comment"># ERROR!</span>
<span class="py-src-keyword">print</span> <span class="py-src-variable">greeting</span>
</pre><p>Instead of producing the output <code>Jello, world!</code>, this code
produces the runtime error <code class="shell">TypeError: 'str' object doesn't
support item assignment</code>.
</p><a name="index26"></a><p>Strings are <b>immutable</b>, which means you can't change an
existing string.  The best you can do is create a new string that is a
variation on the original:</p><pre class="python">
<span class="py-src-variable">greeting</span> = <span class="py-src-string">&quot;Hello, world!&quot;</span>
<span class="py-src-variable">newGreeting</span> = <span class="py-src-string">'J'</span> + <span class="py-src-variable">greeting</span>[<span class="py-src-number">1</span>:]
<span class="py-src-keyword">print</span> <span class="py-src-variable">newGreeting</span>
</pre><p>The solution here is to concatenate a new first letter onto a slice of
<code>greeting</code>.  This operation has no effect on the original string.
</p><a name="index27"></a><h2>7.7 The <code>in</code> operator<a name="auto6"></a></h2><a name="index28"></a><a name="index29"></a><p>
The <code>in</code> operator tests if one string is a substring of another:
</p><pre class="python-interpreter">
&gt;&gt;&gt; 'p' in 'apple'
True
&gt;&gt;&gt; 'i' in 'apple'
False
&gt;&gt;&gt; 'ap' in 'apple'
True
&gt;&gt;&gt; 'pa' in 'apple'
False
</pre><p>Note that a string is a substring of itself:</p><pre class="python-interpreter">
&gt;&gt;&gt; 'a' in 'a'
True
&gt;&gt;&gt; 'apple' in 'apple'
True
</pre><p>Combining the <code>in</code> operator with sting concatination using
<code>+</code>, we can write a function that removes all the vowels from
a string:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">remove_vowels</span>(<span class="py-src-parameter">s</span>):
    <span class="py-src-variable">vowels</span> = <span class="py-src-string">&quot;aeiouAEIOU&quot;</span>
    <span class="py-src-variable">s_without_vowels</span> = <span class="py-src-string">&quot;&quot;</span>
    <span class="py-src-keyword">for</span> <span class="py-src-variable">letter</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">s</span>:
        <span class="py-src-keyword">if</span> <span class="py-src-variable">letter</span> <span class="py-src-keyword">not</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">vowels</span>:
            <span class="py-src-variable">s_without_vowels</span> += <span class="py-src-variable">letter</span>
    <span class="py-src-keyword">return</span> <span class="py-src-variable">s_without_vowels</span>
</pre><p>Test this function to confirm that it does what we wanted it to do.</p><h2>7.8 A <code>find</code> function<a name="auto7"></a></h2><a name="find"></a><a name="index30"></a><a name="index31"></a><a name="index32"></a><a name="index33"></a><p>What does the following function do?</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">find</span>(<span class="py-src-parameter">strng</span>, <span class="py-src-parameter">ch</span>):
    <span class="py-src-variable">index</span> = <span class="py-src-number">0</span>
    <span class="py-src-keyword">while</span> <span class="py-src-variable">index</span> &lt; <span class="py-src-variable">len</span>(<span class="py-src-variable">strng</span>):
        <span class="py-src-keyword">if</span> <span class="py-src-variable">strng</span>[<span class="py-src-variable">index</span>] == <span class="py-src-variable">ch</span>:
            <span class="py-src-keyword">return</span> <span class="py-src-variable">index</span>
        <span class="py-src-variable">index</span> += <span class="py-src-number">1</span>
    <span class="py-src-keyword">return</span> -<span class="py-src-number">1</span>
</pre><p>In a sense, <code>find</code> is the opposite of the <code>[]</code>
operator.  Instead of taking an index and extracting the corresponding
character, it takes a character and finds the index where that character
appears.  If the character is not found, the function returns
<code>-1</code>.</p><p>This is the first example we have seen of a <code>return</code> statement
inside a loop.  If <code>strng[index] == ch</code>, the function returns
immediately, breaking out of the loop prematurely.</p><p>If the character doesn't appear in the string, then the program exits the
loop normally and returns <code>-1</code>.</p><p>This pattern of computation is sometimes called a <q>eureka</q> traversal
because as soon as we find what we are looking for, we can cry <q>Eureka!</q>
and stop looking.</p><h2>7.9 Looping and counting<a name="auto8"></a></h2><a name="counter"></a><a name="index34"></a><a name="index35"></a><p>The following program counts the number of times the letter <code>a</code>
appears in a string, and is another example of the counter pattern introduced
in chapter 6:</p><pre class="python">
<span class="py-src-variable">fruit</span> = <span class="py-src-string">&quot;banana&quot;</span>
<span class="py-src-variable">count</span> = <span class="py-src-number">0</span>
<span class="py-src-keyword">for</span> <span class="py-src-variable">char</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">fruit</span>:
    <span class="py-src-keyword">if</span> <span class="py-src-variable">char</span> == <span class="py-src-string">'a'</span>:
        <span class="py-src-variable">count</span> += <span class="py-src-number">1</span>
<span class="py-src-keyword">print</span> <span class="py-src-variable">count</span>
</pre><h2>7.10 Optional paramters<a name="auto9"></a></h2><a name="index36"></a><a name="index37"></a><a name="index38"></a><p>To find the locations of the second or third occurance of a character in a
string, we can modify the <code>find</code> function, adding a third parameter
for the starting postion in the search string:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">find2</span>(<span class="py-src-parameter">strng</span>, <span class="py-src-parameter">ch</span>, <span class="py-src-parameter">start</span>):
    <span class="py-src-variable">index</span> = <span class="py-src-variable">start</span> 
    <span class="py-src-keyword">while</span> <span class="py-src-variable">index</span> &lt; <span class="py-src-variable">len</span>(<span class="py-src-variable">strng</span>):
        <span class="py-src-keyword">if</span> <span class="py-src-variable">strng</span>[<span class="py-src-variable">index</span>] == <span class="py-src-variable">ch</span>:
            <span class="py-src-keyword">return</span> <span class="py-src-variable">index</span>
        <span class="py-src-variable">index</span> += <span class="py-src-number">1</span>
    <span class="py-src-keyword">return</span> -<span class="py-src-number">1</span>
</pre><p>The call <code>find2('banana', 'a', 2)</code> now returns <code>3</code>,
the index of the second 'a' in 'banana'.</p><p>Better still, we can combine <code>find</code> and <code>find2</code> using
an <b>optional parameter</b>:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">find</span>(<span class="py-src-parameter">strng</span>, <span class="py-src-parameter">ch</span>, <span class="py-src-parameter">start</span>=<span class="py-src-number">0</span>):
    <span class="py-src-variable">index</span> = <span class="py-src-variable">start</span> 
    <span class="py-src-keyword">while</span> <span class="py-src-variable">index</span> &lt; <span class="py-src-variable">len</span>(<span class="py-src-variable">strng</span>):
        <span class="py-src-keyword">if</span> <span class="py-src-variable">strng</span>[<span class="py-src-variable">index</span>] == <span class="py-src-variable">ch</span>:
            <span class="py-src-keyword">return</span> <span class="py-src-variable">index</span>
        <span class="py-src-variable">index</span> += <span class="py-src-number">1</span>
    <span class="py-src-keyword">return</span> -<span class="py-src-number">1</span>
</pre><p>The call <code>find('banana', 'a', 2)</code> to this version of
<code>find</code> behaves just like <code>find2</code>, while in the call
<code>find('banana', 'a')</code>, <code>start</code> will be set to the
<b>default value</b> of <code>0</code>.</p><p>Adding another optional parameter to <code>find</code> makes it search both
forward and backward:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">find</span>(<span class="py-src-parameter">strng</span>, <span class="py-src-parameter">ch</span>, <span class="py-src-parameter">start</span>=<span class="py-src-number">0</span>, <span class="py-src-parameter">step</span>=<span class="py-src-number">1</span>):
    <span class="py-src-variable">index</span> = <span class="py-src-variable">start</span> 
    <span class="py-src-keyword">while</span> <span class="py-src-number">0</span> &lt;= <span class="py-src-variable">index</span> &lt; <span class="py-src-variable">len</span>(<span class="py-src-variable">strng</span>):
        <span class="py-src-keyword">if</span> <span class="py-src-variable">strng</span>[<span class="py-src-variable">index</span>] == <span class="py-src-variable">ch</span>:
            <span class="py-src-keyword">return</span> <span class="py-src-variable">index</span>
        <span class="py-src-variable">index</span> += <span class="py-src-variable">step</span> 
    <span class="py-src-keyword">return</span> -<span class="py-src-number">1</span>
</pre><p>Passing in a value of <code>-1</code> for <code>step</code> will make
it search toward the beginning of the string instead of the end.  Note that we
needed to check for a lower bound for <code>index</code> in the while loop as
well as an upper bound to accomodate this change.</p><h2>7.11 The <code>string</code> module<a name="auto10"></a></h2><a name="index39"></a><a name="index40"></a><a name="index41"></a><a name="index42"></a><a name="index43"></a><a name="index44"></a><a name="index45"></a><p>The <code>string</code> module contains useful functions that manipulate
strings.  As usual, we have to import the module before we can use it:</p><pre class="python-interpreter">
&gt;&gt;&gt; import string
</pre><p>To see what is inside it, use the <code>dir</code> function with the module
name as an argument.</p><pre class="python-interpreter">
&gt;&gt;&gt; dir(string)
</pre><p>which will return the list of items inside the string module:
<br /><br /><code>
['Template', '_TemplateMetaclass', '__builtins__', '__doc__', '__file__',
'__name__', '_float', '_idmap', '_idmapL', '_int', '_long', '_multimap',
'_re', 'ascii_letters', 'ascii_lowercase', 'ascii_uppercase', 'atof',
'atof_error', 'atoi', 'atoi_error', 'atol', 'atol_error', 'capitalize',
'capwords', 'center', 'count', 'digits', 'expandtabs', 'find', 'hexdigits',
'index', 'index_error', 'join', 'joinfields', 'letters', 'ljust', 'lower',
'lowercase', 'lstrip', 'maketrans', 'octdigits', 'printable', 'punctuation',
'replace', 'rfind', 'rindex', 'rjust', 'rsplit', 'rstrip', 'split',
'splitfields', 'strip', 'swapcase', 'translate', 'upper', 'uppercase',
'whitespace', 'zfill']
</code></p><p>To find out more about an item in this list, we can use the
<code>type</code> command.  We need to specify the module name followed by the 
item using <b>dot notation</b>.</p><pre class="python-interpreter">
&gt;&gt;&gt; type(string.digits)
&lt;type 'str'&gt;
&gt;&gt;&gt; type(string.find)
&lt;type 'function'&gt;
</pre><p>Since <code>string.digits</code> is a string, we can print it to see what
it contains:</p><pre class="python-interpreter">
&gt;&gt;&gt; print string.digits
0123456789
</pre><p>Not surprisingly, it contains each of the decimal digits.</p><p><code>string.find</code> is a function which does much the same thing as the 
function we wrote.  To find out more about it, we can print out its
<b>docstring</b>, <code>__doc__</code>, which contains documentation on the
function:</p><pre class="python-interpreter">
&gt;&gt;&gt; print string.find.__doc__
find(s, sub [,start [,end]]) -&gt; in

    Return the lowest index in s where substring sub is found,
    such that sub is contained within s[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.

</pre><p>The parameters in square brackets are optional parameters.  We can use
<code>string.find</code> much as we did our own <code>find</code>:</p><pre class="python-interpreter">
&gt;&gt;&gt; fruit = &quot;banana&quot;
&gt;&gt;&gt; index = string.find(fruit, &quot;a&quot;)
&gt;&gt;&gt; print index
1
</pre><p>This example demonstrates one of the benefits of modules---they help
avoid collisions between the names of built-in functions and user-defined
functions.  By using dot notation we can specify which version of
<code>find</code> we want.</p><p>Actually, <code>string.find</code> is more general than our version.
it can find substrings, not just characters:</p><pre class="python-interpreter">
&gt;&gt;&gt; string.find(&quot;banana&quot;, &quot;na&quot;)
2
</pre><p>Like ours, it takes an additional argument that specifies the index at
which it should start:</p><pre class="python-interpreter">
&gt;&gt;&gt; string.find(&quot;banana&quot;, &quot;na&quot;, 3)
4
</pre><p>Unlike ours, its second optional parameter specifies the index at which
the search should end:</p><pre class="python-interpreter">
&gt;&gt;&gt; string.find(&quot;bob&quot;, &quot;b&quot;, 1, 2)
-1
</pre><p>In this example, the search fails because the letter <em>b</em> does not
appear in the index range from <code>1</code> to <code>2</code> (not including
<code>2</code>).</p><h2>7.12 Character classification<a name="auto11"></a></h2><a name="in"></a><a name="index46"></a><a name="index47"></a><a name="index48"></a><a name="index49"></a><a name="index50"></a><a name="index51"></a><p>It is often helpful to examine a character and test whether it is upper- or
lowercase, or whether it is a character or a digit.  The <code>string</code>
module provides several constants that are useful for these purposes.  One
of these, <code>string.digits</code>, we have already seen.</p><p>The string <code>string.lowercase</code> contains all of the letters that
the system considers to be lowercase.  Similarly, <code>string.uppercase</code>
contains all of the uppercase letters.  Try the following and see what you get:
</p><pre class="python">
<span class="py-src-keyword">print</span> <span class="py-src-variable">string</span>.<span class="py-src-variable">lowercase</span>
<span class="py-src-keyword">print</span> <span class="py-src-variable">string</span>.<span class="py-src-variable">uppercase</span>
<span class="py-src-keyword">print</span> <span class="py-src-variable">string</span>.<span class="py-src-variable">digits</span>
</pre><p>We can use these constants and <code>find</code> to classify characters. For
example, if <code>find(lowercase, ch)</code> returns a value other than
<code>-1</code>, then <code>ch</code> must be lowercase:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">is_lower</span>(<span class="py-src-parameter">ch</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">string</span>.<span class="py-src-variable">find</span>(<span class="py-src-variable">string</span>.<span class="py-src-variable">lowercase</span>, <span class="py-src-variable">ch</span>) != -<span class="py-src-number">1</span>
</pre><p>Alternatively, we can take advantage of the <code>in</code> operator:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">is_lower</span>(<span class="py-src-parameter">ch</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">ch</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">string</span>.<span class="py-src-variable">lowercase</span>
</pre><p>As yet another alternative, we can use the comparison operator:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">is_lower</span>(<span class="py-src-parameter">ch</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-string">'a'</span> &lt;= <span class="py-src-variable">ch</span> &lt;= <span class="py-src-string">'z'</span>
</pre><p>If <code>ch</code> is between <em>a</em> and <em>z</em>, it must be a
lowercase letter.</p><p>Another constant defined in the <code>string</code> module may surprise you
when you print it:</p><pre class="python-interpreter">
&gt;&gt;&gt; print string.whitespace
</pre><p><b>Whitespace</b> characters move the cursor without printing
anything.  They create the white space between visible characters (at least on
white paper).  The constant <code>string.whitespace</code> contains all the
whitespace characters, including space, tab (\t), and newline (\n).</p><a name="index52"></a><a name="index53"></a><p>There are other useful functions in the <code>string</code> module, but this
book isn't intended to be a reference manual.  On the other hand, the
<em>Python Library Reference</em> is.  Along with a wealth of other
documentation, it's available from the Python website, 
<a href="http://www.python.org">http://www.python.org</a>.</p><a name="index54"></a><h2>7.13 String formatting<a name="auto12"></a></h2><a name="index55"></a><a name="index56"></a><a name="index57"></a><p>The most concise and powerful way to format a string in Python is to use
the <em>string formatting operator</em>, <code>%</code>, together with Python's
string formatting operations.  To see how this works, let's start with a few
examples:</p><pre class="python-interpreter">
&gt;&gt;&gt; &quot;His name is %s.&quot;  % &quot;Arthur&quot;
'His name is Arthur.'
&gt;&gt;&gt; name = &quot;Alice&quot;
&gt;&gt;&gt; age = 10
&gt;&gt;&gt; &quot;I am %s and I am %d years old.&quot; % (name, age)
'I am Alice and I am 10 years old.'
&gt;&gt;&gt; n1 = 4
&gt;&gt;&gt; n2 = 5
&gt;&gt;&gt; &quot;2**10 = %d and %d * %d = %f&quot; % (2**10, n1, n2, n1 * n2)
'2**10 = 1024 and 4 * 5 = 20.000000'
&gt;&gt;&gt;
</pre><p>The syntax for the string formatting operation looks like this:</p><pre class="boxed">
&quot;&lt;FORMAT&gt;&quot; % (&lt;VALUES&gt;)
</pre><p>It begins with a <em>format</em> which contains a sequence of characters
and <em>conversion specifications</em>.  Conversion specifications start with
a <code>%</code> operator.  Following the format string is a single
<code>%</code> and then a sequence of values, <em>one per conversion
specification</em>, seperated by commas and enclosed in parenthesis.  The
parenthesis are optional if there is only a single value.
</p><p>In the first example above, there is a single conversion specification,
<code>%s</code>, which indicates a string.  The single value,
<code>&quot;Arthur&quot;</code>, maps to it, and is not enclosed in parenthesis.</p><p>In the second example, <code>name</code> has string value,
<code>&quot;Alice&quot;</code>, and <code>age</code> has integer value, <code>10</code>.
These map to the two converstion specifications, <code>%s</code> and
<code>%d</code>.  The <code>d</code> in the second converstion specification
indicates that the value is a decimal integer.</p><p>In the third example variables <code>n1</code> and <code>n2</code> have
integer values <code>4</code> and <code>5</code> respectively.  There are
four converstion specifications in the format string: three <code>%d</code>'s
and a <code>%f</code>.  The <code>f</code> indicates that the value should
be represented as a floating point number.  The four values that map to the
four converstion specifications are: <code>2**10</code>, <code>n1</code>,
<code>n2</code>, and <code>n1 * n2</code>.</p><p><code>s</code>, <code>d</code>, and <code>f</code> are all the conversion
types we will need for this book.  To see a complete list, see the
<a href="http://docs.python.org/lib/typesseq-strings.html">String Formatting 
Operations</a> section of the Python Library Reference.</p><p>The following example illustrates the real utility of string formatting:
</p><pre class="python">
<span class="py-src-variable">i</span> = <span class="py-src-number">1</span>
<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;i\ti**2\ti**3\ti**5\ti**10\ti**20&quot;</span>
<span class="py-src-keyword">while</span> <span class="py-src-variable">i</span> &lt;= <span class="py-src-number">10</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">i</span>, <span class="py-src-string">'\t'</span>, <span class="py-src-variable">i</span>**<span class="py-src-number">2</span>, <span class="py-src-string">'\t'</span>, <span class="py-src-variable">i</span>**<span class="py-src-number">3</span>, <span class="py-src-string">'\t'</span>, <span class="py-src-variable">i</span>**<span class="py-src-number">5</span>, <span class="py-src-string">'\t'</span>, <span class="py-src-variable">i</span>**<span class="py-src-number">10</span>, <span class="py-src-string">'\t'</span>, <span class="py-src-variable">i</span>**<span class="py-src-number">20</span>
    <span class="py-src-variable">i</span> += <span class="py-src-number">1</span>
</pre><p>This program prints out a table of various powers of the numbers from
1 to 10.  In its current form it relies on the tab character (<code>\t</code>)
to align the columns of values, but this breaks down when the values in the
table get larger than the 8 character tab width:</p><pre class="shell">
i       i**2    i**3    i**5    i**10   i**20
1       1       1       1       1       1
2       4       8       32      1024    1048576
3       9       27      243     59049   3486784401
4       16      64      1024    1048576         1099511627776
5       25      125     3125    9765625         95367431640625
6       36      216     7776    60466176        3656158440062976
7       49      343     16807   282475249       79792266297612001
8       64      512     32768   1073741824      1152921504606846976
9       81      729     59049   3486784401      12157665459056928801
10      100     1000    100000  10000000000     100000000000000000000
</pre><p>One possible solution would be to change the tab width, but the first column
already has more space than it needs.  The best solution would be to set the
width of each column independently.  As you may have guessed by now, string
formatting provides the solution:</p><pre class="python">
<span class="py-src-variable">i</span> = <span class="py-src-number">1</span>
<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;%-4s%-5s%-6s%-8s%-13s%-15s&quot;</span> %
      (<span class="py-src-string">'i'</span>, <span class="py-src-string">'i**2'</span>, <span class="py-src-string">'i**3'</span>, <span class="py-src-string">'i**5'</span>, <span class="py-src-string">'i**10'</span>, <span class="py-src-string">'i**20'</span>)
<span class="py-src-keyword">while</span> <span class="py-src-variable">i</span> &lt;= <span class="py-src-number">10</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;%-4d%-5d%-6d%-8d%-13d%-15d&quot;</span> % (<span class="py-src-variable">i</span>, <span class="py-src-variable">i</span>**<span class="py-src-number">2</span>, <span class="py-src-variable">i</span>**<span class="py-src-number">3</span>, <span class="py-src-variable">i</span>**<span class="py-src-number">5</span>, <span class="py-src-variable">i</span>**<span class="py-src-number">10</span>, <span class="py-src-variable">i</span>**<span class="py-src-number">20</span>)
    <span class="py-src-variable">i</span> += <span class="py-src-number">1</span>
</pre><p>Running this version produces the following output:</p><pre class="shell">
i   i**2 i**3  i**5    i**10        i**20          
1   1    1     1       1            1              
2   4    8     32      1024         1048576        
3   9    27    243     59049        3486784401     
4   16   64    1024    1048576      1099511627776  
5   25   125   3125    9765625      95367431640625 
6   36   216   7776    60466176     3656158440062976
7   49   343   16807   282475249    79792266297612001
8   64   512   32768   1073741824   1152921504606846976
9   81   729   59049   3486784401   12157665459056928801
10  100  1000  100000  10000000000  100000000000000000000
</pre><p>The <code>-</code> after each <code>%</code> in the converstion
specifications indicates left justification.  The numerical values specify
the minimum length, so <code>%-13d</code> is a left justified number at
least 13 characters wide.</p><h2>7.14 Glossary<a name="auto13"></a></h2><a name="index58"></a><a name="index59"></a><a name="index60"></a><a name="index61"></a><a name="index62"></a><a name="index63"></a><a name="index64"></a><a name="index65"></a><a name="index66"></a><a name="index67"></a><dl><dt>compound data type:</dt><dd>A data type in which the values are made up of components, or elements,
that are themselves values.</dd><dt>index:</dt><dd>A variable or value used to select a member of an ordered set, such as a
character from a string.</dd><dt>traverse:</dt><dd>To iterate through the elements of a set, performing a similar operation on 
each.</dd><dt>slice:</dt><dd>A part of a string (substring) specified by a range of indices.  More
generally, a subsequence of any sequence type in Python can be created
using the slice operator
(<code><em>sequence</em>[<em>start</em>:<em>stop</em>]</code>).</dd><dt>immutable:</dt><dd>A compound data types whose elements can not be assigned new values.</dd><dt>optional parameter:</dt><dd>A parameter written in a function header with an assignment to a default
value which it will receive if no corresponding argument is given for it in
the function call.</dd><dt>default value:</dt><dd>The value given to an optional parameter if no argument for it is provided
in the function call.</dd><dt>dot notation</dt><dd>Use of the <b>dot operator</b>, <code>.</code>, to access functions inside
a module.</dd><dt>docstring</dt><dd>A string constant on the first line of a function or module definition
(and as we will see later, in class and method definitions as well).
Docstrings provide a convinient way to associate documentation with code.
Docstrings are also used by the <code>doctest</code> module for automated
testing.</dd><dt>whitespace:</dt><dd>Any of the characters that move the cursor without printing visible
characters.  The constant <code>string.whitespace</code> contains all the
white-space characters.</dd></dl><h2>7.15 Exercises<a name="auto14"></a></h2><ol><li><div class="exercise">
Modify:
<pre class="python">
<span class="py-src-variable">prefixes</span> = <span class="py-src-string">&quot;JKLMNOPQ&quot;</span>
<span class="py-src-variable">suffix</span> = <span class="py-src-string">&quot;ack&quot;</span>
   
<span class="py-src-keyword">for</span> <span class="py-src-variable">letter</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">prefixes</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">letter</span> + <span class="py-src-variable">suffix</span>
</pre>
so that <code>Ouack</code> and <code>Quack</code> are spelled correctly.
</div></li><li><div class="exercise">
Encapsulate
<pre class="python">
<span class="py-src-variable">fruit</span> = <span class="py-src-string">&quot;banana&quot;</span>
<span class="py-src-variable">count</span> = <span class="py-src-number">0</span>
<span class="py-src-keyword">for</span> <span class="py-src-variable">char</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">fruit</span>:
    <span class="py-src-keyword">if</span> <span class="py-src-variable">char</span> == <span class="py-src-string">'a'</span>:
        <span class="py-src-variable">count</span> += <span class="py-src-number">1</span>
<span class="py-src-keyword">print</span> <span class="py-src-variable">count</span>
</pre>
in a function named <code>count_letters</code>, and generalize it so that it
accepts the string and the letter as arguments.
</div></li><li><div class="exercise">
Now rewrite the <code>count_letters</code> function so that instead of
traversing the string, it repeatedly calls <code>find</code> (the version from
section 8.10), with the optional third parameter to locate new occurences of
the letter being counted.
</div></li><li><div class="exercise">
Which version of <code>is_lower</code> do you think will be fastest?  Can you
think of other reasons besides speed to prefer one version or the other?
</div></li><li><div class="exercise">
Create a file named <code>stringtools.py</code> and put the following in
it:
<pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">reverse</span>(<span class="py-src-parameter">s</span>):
    <span class="py-src-string">&quot;&quot;&quot;
      &gt;&gt;&gt; reverse('happy')
      'yppah'
      &gt;&gt;&gt; reverse('Python')
      'nohtyP'
      &gt;&gt;&gt; reverse(&quot;&quot;)
      ''
      &gt;&gt;&gt; reverse(&quot;P&quot;)
      'P'
    &quot;&quot;&quot;</span>

<span class="py-src-keyword">if</span> <span class="py-src-variable">__name__</span> == <span class="py-src-string">'__main__'</span>:
    <span class="py-src-keyword">import</span> <span class="py-src-variable">doctest</span>
    <span class="py-src-variable">doctest</span>.<span class="py-src-variable">testmod</span>()
</pre>
Add a function body to <code>reverse</code> to make the doctests pass.
</div></li><li><div class="exercise">
Add <code>mirror</code> to <code>stringtools.py</code> .
<pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">mirror</span>(<span class="py-src-parameter">s</span>):
    <span class="py-src-string">&quot;&quot;&quot;
      &gt;&gt;&gt; mirror(&quot;good&quot;)
      'gooddoog'
      &gt;&gt;&gt; mirror(&quot;yes&quot;)
      'yessey'
      &gt;&gt;&gt; mirror('Python')
      'PythonnohtyP'
      &gt;&gt;&gt; mirror(&quot;&quot;)
      ''
      &gt;&gt;&gt; mirror(&quot;a&quot;)
      'aa'
    &quot;&quot;&quot;</span>
</pre>
Write a function body for it that will make it work as indicated by the
doctests.
</div></li><li><div class="exercise">
Include <code>remove_letter</code> in <code>stringtools.py</code> .
<pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">remove_letter</span>(<span class="py-src-parameter">letter</span>, <span class="py-src-parameter">strng</span>):
    <span class="py-src-string">&quot;&quot;&quot;
      &gt;&gt;&gt; remove_letter('a', 'apple')
      'pple'
      &gt;&gt;&gt; remove_letter('a', 'banana')
      'bnn'
      &gt;&gt;&gt; remove_letter('z', 'banana')
      'banana'
      &gt;&gt;&gt; remove_letter('i', 'Mississippi')
      'Msssspp'
    &quot;&quot;&quot;</span>
</pre>
Write a function body for it that will make it work as indicated by the
doctests.
</div></li><li><div class="exercise">
Finally, add bodies to each of the following functions, one at a time
<pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">is_palindrome</span>(<span class="py-src-parameter">s</span>):
    <span class="py-src-string">&quot;&quot;&quot;
      &gt;&gt;&gt; is_palindrome('abba')
      True
      &gt;&gt;&gt; is_palindrome('abab')
      False
      &gt;&gt;&gt; is_palindrome('tenet')
      True
      &gt;&gt;&gt; is_palindrome('banana')
      False
      &gt;&gt;&gt; is_palindrome('straw warts')
      True
    &quot;&quot;&quot;</span>

<span class="py-src-keyword">def</span> <span class="py-src-identifier">count</span>(<span class="py-src-parameter">sub</span>, <span class="py-src-parameter">s</span>):
    <span class="py-src-string">&quot;&quot;&quot;
      &gt;&gt;&gt; count('is', 'Mississippi')
      2
      &gt;&gt;&gt; count('an', 'banana')
      2
      &gt;&gt;&gt; count('ana', 'banana')
      2
      &gt;&gt;&gt; count('nana', 'banana')
      1
      &gt;&gt;&gt; count('nanan', 'banana')
      0
    &quot;&quot;&quot;</span>

<span class="py-src-keyword">def</span> <span class="py-src-identifier">remove</span>(<span class="py-src-parameter">sub</span>, <span class="py-src-parameter">s</span>):
    <span class="py-src-string">&quot;&quot;&quot;
      &gt;&gt;&gt; remove('an', 'banana')
      'bana'
      &gt;&gt;&gt; remove('cyc', 'bicycle')
      'bile'
      &gt;&gt;&gt; remove('iss', 'Mississippi')
      'Missippi'
      &gt;&gt;&gt; remove('egg', 'bicycle')
      'bicycle'
    &quot;&quot;&quot;</span>

<span class="py-src-keyword">def</span> <span class="py-src-identifier">remove_all</span>(<span class="py-src-parameter">sub</span>, <span class="py-src-parameter">s</span>):
    <span class="py-src-string">&quot;&quot;&quot;
      &gt;&gt;&gt; remove_all('an', 'banana')
      'ba'
      &gt;&gt;&gt; remove_all('cyc', 'bicycle')
      'bile'
      &gt;&gt;&gt; remove_all('iss', 'Mississippi')
      'Mippi'
      &gt;&gt;&gt; remove_all('eggs', 'bicycle')
      'bicycle'
    &quot;&quot;&quot;</span>
</pre>
until all the doctests pass.
</div></li><li><div class="exercise">
Try each of the following formatted string operations in a Python shell and
record the results:
  <ol style="list-style-type: lower-alpha;"><li>&quot;%s %d %f&quot; % (5, 5, 5)</li><li>&quot;%-.2f&quot; % 3</li><li>&quot;%-10.2f%-10.2f&quot; % (7, 1.0/2)</li><li>print &quot;  $%5.2f\n  $%5.2f\n  $%5.2f&quot; % (3, 4.5, 11.2)</li></ol></div></li><li><div class="exercise">
The following formatted strings have errors.  Fix them:
  <ol style="list-style-type: lower-alpha;"><li>&quot;%s %s %s %s&quot; % ('this', 'that', 'something')</li><li>&quot;%s %s %s&quot; % ('yes', 'no', 'up', 'down')</li><li>&quot;%d %f %f&quot; % (3, 3, 'three')</li></ol></div></li></ol></div><p><a href="index.xhtml">Table of Contents</a> |
    <a href="dex.xhtml">Index</a></p></body></html>