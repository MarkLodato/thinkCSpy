<html>
<head>
  <title>Modules and files</title>
</head>
<body>

<h1>Modules and files</h1>

<h2>Modules</h2>
<span class="index" value="module" />
<span class="index" value="standard library" />
<span class="index" value="import" />
<span class="index" value="import statement" />
<span class="index" value="statement!import" />

<p>A <b>module</b> is a file containing Python definitions and statements
intended for use in other Python programs.  There are many Python modules that
come with Python as part of the <b>standard library</b>.  We have seen two of
these already, the <code>doctest</code> module and the <code>string</code>
module.</p>


<h2>pydoc</h2>
<span class="index" value="pydoc" />
<span class="index" value="command prompt" />

<p>You can use <b>pydoc</b> to search through the Python libraries installed on
your system.  At the <b>command prompt</b> type the following:</p>

<pre class='shell'>
$ pydoc -g
</pre>

<p>and the following will appear:</p>

<p><img src="illustrations/pydoc_tk.png" /></p>

<p>(<em>note</em>: see exercise 2 if you get an error)</p>

<p>Click on the <q>open browser</q> button to launch a web browser window
containing the documentation generated by <code>pydoc</code>:</p> 

<p><img src="illustrations/pydoc_firefox.png" /></p>

<p>This is a listing of all the python libraries found by Python on your
system.  Clicking on a module name opens a new page with documenation for
that module.  Clicking <code>keyword</code>, for example, opens the following
page:</p>

<p><img src="illustrations/pydoc_keyword_firefox.png" /></p>

<p>Documentation for most modules contains three color coded sections:</p>
<ul>
  <li><em>Classes</em> in pink</li>
  <li><em>Functions</em> in orange</li> 
  <li><em>Data</em> in green</li>
</ul>

<p>Classes will be discussed in later chapters, but for now we can use pydoc
to see the functions and data contained within modules.</p>

<p>The <code>keyword</code> module contains a single function,
<code>iskeyword</code>, which as its name suggests is a boolean function
that returns <code>True</code> if a string passed to it is a keyword:</p>

<pre class='python-interpreter'>
>>> from keyword import *
>>> iskeyword('for')
True
>>> iskeyword('all')
False
>>>
</pre>

<p>The data item, <code>kwlist</code> contains a list of all the current
keywords in Python:</p>

<pre class='python-interpreter'>
>>> from keyword import *
>>> print kwlist
['and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif',
'else', 'except', 'exec', 'finally', 'for', 'from', 'global', 'if', 'import',
'in', 'is', 'lambda', 'not', 'or', 'pass', 'print', 'raise', 'return', 'try',
'while', 'with', 'yield']
>>>
</pre>

<p>We encourage you to use <code>pydoc</code> to explore the extensive
libraries that come with Python.  There are so many treasures to discover!</p>


<h2>Creating modules</h2>

<p>All we need to create a module is a text file with a <code>.py</code>
extension on the filename:</p>

<pre class="python">
#  seqtools.py
#
def remove_at(pos, seq):
    return seq[:pos] + seq[pos+1:]
</pre>

<p>We can now use our module in both scripts and the Python shell.  To do so,
we must first <b>import</b> the module.  There are two ways to do this:</p>

<pre class="python-interpreter">
>>> from seqtools import remove_at
>>> s = "A string!"
>>> remove_at(4, s)
'A sting!'
</pre>

<p>and:</p>

<pre class="python-interpreter">
>>> import seqtools
>>> s = "A string!"
>>> seqtools.remove_at(4, s)
'A sting!'
</pre>

<p>In the first example, <code>remove_at</code> is called just like the 
functions we have seen previously.  In the second example the name of the
module and a dot (.) are written before the function name.</p> 

<p>Notice that in either case we do not include the <code>.py</code> file
extension when importing.  Python expects the file names of Python modules to
end in <code>.py</code>, so the file extention is not included in the
<b>import statement</b>.</p>

<p>The use of modules makes it possible to break up very large programs into
managable sized parts, and to keep related parts together.</p>


<h2>Namespaces</h2>
<span class="index" value="namespace" />
<span class="index" value="naming collision" />

<p>A <b>namespace</b> is a syntactic container which permits the same name
to be used in different modules or functions (and as we will see soon, in
classes and methods).</p>

<p>Each module determines its own namespace, so we can use the same name
in multiple modules without causing an identification problem.</p>

<pre class='python'>
# module1.py

question = "What is the meaning of life, the Universe, and everything?"
answer = 42
</pre>

<pre class='python'>
# module2.py

question = "What is your quest?"
answer = "To seek the holy grail." 
</pre>

<p>We can now import both modules and access <code>question</code> and
<code>answer</code> in each:</p>

<pre class="python-interpreter">
>>> import module1
>>> import module2
>>> print module1.question
What is the meaning of life, the Universe, and everything?
>>> print module2.question
What is your quest?
>>> print module1.answer
42
>>> print module2.answer
To seek the holy grail.
>>>
</pre>

<p>If we had used <code>from module1 import *</code> and
<code>from module2 import *</code> instead, we would have a
<b>naming collision</b> and would not be able to access <code>question</code>
and <code>answer</code> from <code>module1</code>.</p>

<p>Functions also have their own namespace:</p>

<pre class='python'>
def f():
    n = 7
    print "printing n inside of f: %d"  % n

def g():
    n = 42
    print "printing n inside of g: %d"  % n

n = 11
print "printing n before calling f: %d"  % n
f()
print "printing n after calling f: %d"  % n
g()
print "printing n after calling g: %d"  % n
</pre>

<p>Running this program produces the following output:</p>

<pre class='shell'>
printing n before calling f: 11
printing n inside of f: 7
printing n after calling f: 11
printing n inside of g: 42
printing n after calling g: 11
</pre>

<p>The three <code>n</code>'s here do not collide since they are each in a
different namepace.</p>

<p>Namespaces permit several programmers to work on the same project without
having naming collisions.</p>


<h2>Attributes and the dot operator</h2>
<span class="index" value="attribute" />
<span class="index" value="dot operator" />
<span class="index" value="operator!." />
<span class="index" value="string module" />
<span class="index" value="module!string" />

<p>Variables defined inside a module are called <b>attributes</b> of the
module.  They are accessed by using the <b>dot operator</b> (<code>.</code>).
The <code>question</code> attribute of <code>module1</code> and
<code>module2</code> are accessed using <code>module1.question</code> and
<code>module2.question</code>.</p>

<p>Modules contain functions as well as attributes, and the dot operator is
used to access them in the same way. <code>seqtools.remove_at</code> refers to
the <code>remove_at</code> function in the <code>seqtools</code> module.</p>

<p>In Chapter 7 we introduced the <code>find</code> function from the
<code>string</code> module.  The <code>string</code> module contains many
other useful functions:</p>

<pre class='python-interpreter'>
>>> import string
>>> string.capitalize('maryland')
'Maryland'
>>> string.capwords("what's all this, then, amen?")
"What's All This, Then, Amen?"
>>> string.center('How to Center Text Using Python', 70)
'                   How to Center Text Using Python                    '
>>> string.upper('angola')
'ANGOLA'
>>> 
</pre>

<p>You should use pydoc to browse the other functions and attributes in the
string module.</p>


<h2>String and list methods</h2>
<span class="index" value="string methods" />
<span class="index" value="methods!string" />
<span class="index" value="list methods" />
<span class="index" value="methods!list" />

<p>As the Python language developed, most of functions from the
<code>string</code> module have also been added as <b>methods</b> of string
objects.  A method acts much like a function, but the syntax for calling
it is a bit different:</p>

<pre class='python-interpreter'>
>>> 'maryland'.capitalize()
'Maryland'
>>> "what's all this, then, amen?".title()
"What'S All This, Then, Amen?"
>>> 'How to Center Text Using Python'.center(70)
'                   How to Center Text Using Python                    '
>>> 'angola'.upper()
'ANGOLA'
>>>
</pre>

<p>String methods are built-in to string objects, and they are <em>invoked</em>
(called) by following the object with the dot operator and the method name.</p>

<p>We will be learning how to create our own objects with their own methods in
later chapters.  For now we will only be using methods that come with Python's
built-in objects.</p> 
[5, 12, 27, 3, 12]
<p>The dot operator can also be used to access built-in methods of list
objects:</p>

<pre class='python-interpreter'>
>>> mylist = []
>>> mylist.append(5)
>>> mylist.append(27)
>>> mylist.append(3)
>>> mylist.append(12)
>>> mylist
[5, 27, 3, 12]
>>>
</pre>

<p><code>append</code> is a list method which adds the argument passed to it to 
the end of the list.  Continuing with this example, we several other list
methods:</p>

<pre class='python-interpreter'>
>>> mylist.insert(1, 12)
>>> mylist
[5, 12, 27, 3, 12]
>>> mylist.count(12)
2
>>> mylist.extend([5, 9, 5, 11])
>>> mylist
[5, 12, 27, 3, 12, 5, 9, 5, 11])
>>> mylist.index(9)
6
>>> mylist.count(5)
3
>>> mylist.reverse()
>>> mylist
[11, 5, 9, 5, 12, 3, 27, 12, 5]
>>> mylist.sort()
>>> mylist
[3, 5, 5, 5, 9, 11, 12, 12, 27]
>>> mylist.remove(12)
>>> mylist
[3, 5, 5, 5, 9, 11, 12, 27]
>>>
</pre>

<p>Experiment with the list methods in this example until you feel confident
that you understand how they work.</p>


<h2>Reading and writing text files</h2>
<span class="index" value="volatile memory" />
<span class="index" value="non-volatile memory" />
<span class="index" value="file" />

<p>While a program is running, its data is stored in
<em>random access memory</em> (RAM).  RAM is fast and inexpensive, but it is
also <b>volatile</b>, which means that when the program ends, or the computer
shuts down, data in RAM disappears.  To make data available the next time you
turn on your computer and start your program, you have to write it to a
<b>non-volatile</b> storage medium, such a hard drive, usb drive, or CD-RW.</p>

<p>Data on non-volatile storage media is stored in named locations on the
media called <b>files</b>.  By reading and writing files, programs can save
information between program runs.</p>

<p>Working with files is a lot like working with a notebook.  To use a
notebook, you have to open it.  When you're done, you have to close it.  While
the notebook is open, you can either write in it or read from it.  In either
case, you know where you are in the notebook.  You can read the whole notebook
in its natural order or you can skip around.</p>

<p>All of this applies to files as well.  To open a file, you specify its name
and indicate whether you want to read or write.</p>

<p>Opening a file creates a file object.  In this example, the variable
<code>myfile</code> refers to the new file object.</p>

<pre class="python-interpreter">
>>> myfile = open('test.dat', 'w')
>>> print myfile
&lt;open file 'test.dat', mode 'w' at 0x2aaaaab80cd8&gt;
</pre>

<p>The open function takes two arguments.  The first is the name of the file,
and the second is the <b>mode</b>.  Mode <code>'w'</code> means that we are
opening the file for writing.</p>

<p>If there is no file named <code>test.dat</code>, it will be created.  If
there already is one, it will be replaced by the file we are writing.</p>

<p>When we print the file object, we see the name of the file, the mode, and
the location of the object.</p>

<p>To put data in the file we invoke the <code>write</code> method on the file
object:</p>

<pre class="python-interpreter">
>>> myfile.write("Now is the time")
>>> myfile.write("to close the file")
</pre>

<p>Closing the file tells the system that we are done writing and makes the
file available for reading:</p>

<pre class="python-interpreter">
>>> myfile.close()
</pre>

<p>Now we can open the file again, this time for reading, and read the contents 
into a string.  This time, the mode argument is <code>'r'</code> for reading:
</p>

<pre class="python-interpreter">
>>> myfile = open('test.dat', 'r')
</pre>

<p>If we try to open a file that doesn't exist, we get an error:</p>

<span class="index" value="runtime error" />

<pre class="python-interpreter">
>>> myfile = open('test.cat', 'r')
IOError: [Errno 2] No such file or directory: 'test.cat'
</pre>

<p>Not surprisingly, the <code>read</code> method reads data from the file.
With no arguments, it reads the entire contents of the file into a single
string:</p>

<pre class="python-interpreter">
>>> text = myfile.read()
>>> print text
Now is the timeto close the file
</pre>

<p>There is no space between <q>time</q> and <q>to</q> because we did not write 
a space between the strings.</p>

<p><code>read</code> can also take an argument that indicates how many
characters to read:</p>

<pre class="python-interpreter">
>>> myfile = open('test.dat', 'r')
>>> print myfile.read(5)
Now i
</pre>

<p>If not enough characters are left in the file, <code>read</code> returns the 
remaining characters.  When we get to the end of the file, <code>read</code>
returns the empty string:</p>

<pre class="python-interpreter">
>>> print myfile.read(1000006)
s the timeto close the file
>>> print myfile.read()
   
>>>
</pre>

<p>The following function copies a file, reading and writing up to fifty
characters at a time.  The first argument is the name of the original file; the 
second is the name of the new file:</p>

<pre class="python">
def copy_file(oldfile, newfile):
    infile = open(oldfile, 'r')
    outfile = open(newfile, 'w')
    while True:
        text = infile.read(50)
        if text == "":
            break
        outfile.write(text)
    infile.close()
    outfile.close()
    return
</pre>

<p>This functions continues looping, reading 50 characters from
<code>infile</code> and writing the same 50 charaters to <code>outfile</code>
until the end of <code>infile</code> is reached, at which point
<code>text</code> is empty and the <code>break</code> statement is executed.
</p>


<h2>Text files</h2>
<span class="index" value="text file" />
<span class="index" value="file!text" />
<span class="index" value="continue statement" />
<span class="index" value="statement!continue" />

<p>A <b>text file</b> is a file that contains printable characters and
whitespace, organized into lines separated by newline characters.  Since Python 
is specifically designed to process text files, it provides methods that make
the job easy.</p>

<p>To demonstrate, we'll create a text file with three lines of text separated
by newlines:</p>

<pre class="python-interpreter">
>>> outfile = open("test.dat","w")
>>> outfile.write("line one\nline two\nline three\n")
>>> outfile.close()
</pre>

<p>The <code>readline</code> method reads all the characters up to and
including the next newline character:</p>

<pre class="python-interpreter">
>>> infile = open("test.dat","r")
>>> print inf.readline()
line one
   
>>>
</pre>

<p><code>readlines</code> returns all of the remaining lines as a list of
strings:</p>

<pre class="python-interpreter">
>>> print infile.readlines()
['line two\012', 'line three\012']
</pre>

<p>In this case, the output is in list format, which means that the strings
appear with quotation marks and the newline character appears as the escape
sequence <code>\\012</code>.</p>

<p>At the end of the file, <code>readline</code> returns the empty string
and <code>readlines</code> returns the empty list:</p>

<pre class="python-interpreter">
>>> print infile.readline()
   
>>> print infile.readlines()
[]
</pre>

<p>The following is an example of a line-processing program.
<code>filter</code> makes a copy of <code>oldfile</code>, omitting any
lines that begin with <code>#</code>:</p>

<pre class="python">
def filter(oldfile, newfile):
    infile = open(oldfile, 'r')
    outfile = open(newfile, 'w')
    while True:
        text = infile.readline()
        if text == "":
           break
        if text[0] == '#':
           continue
        outfile.write(text)
    infile.close()
    outfile.close()
    return
</pre>

<p>The <b>continue statement</b> ends the current iteration of the loop,
but continues looping.  The flow of execution moves to the top of the loop,
checks the condition, and proceeds accordingly.</p>

<p>Thus, if <code>text</code> is the empty string, the loop exits.  If the
first character of <code>text</code> is a hash mark, the flow of execution goes 
to the top of the loop.  Only if both conditions fail do we copy
<code>text</code> into the new file.</p>


<h2>Directories</h2>
<span class="index" value="file system" />
<span class="index" value="directory" />
<span class="index" value="path" />
<span class="index" value="delimiter" />

<p>Files on non-volatile storage media are organized by a set of rules known
as a <b>file system</b>.  File systems are made up of files and
<b>directories</b>, which are containers for both files and other directories.
</p>

<p>When you create a new file by opening it and writing, the new file goes in
the current directory (wherever you were when you ran the program).  Similarly, 
when you open a file for reading, Python looks for it in the current directory.
</p>

<p>If you want to open a file somewhere else, you have to specify the
<b>path</b> to the file, which is the name of the directory (or folder) where
the file is located:</p>

<pre class="python-interpreter">
>>> wordsfile = open('/usr/share/dict/words', 'r')
>>> wordlist = wordsfile.readlines()
>>> print wordlist[:5]
['\n', 'A\n', "A's\n", 'AOL\n', "AOL's\n", 'Aachen\n']
</pre>

<p>This example opens a file named <code>words</code> that resides in a
directory named <code>dict</code>, which resides in <code>share</code>, which
resides in <code>usr</code>, which resides in the top-level directory of the
system, called <code>/</code>.  It then reads in each line into a list using
<code>readlines</code>, and prints out the first 5 elements from that list.</p>

<p>You cannot use <code>/</code> as part of a filename; it is reserved as a
<b>delimiter</b> between directory and filenames.</p>

<p>The file <code>/usr/share/dict/words</code> should exist on unix based
systems, and contains a list of words in alphabetical order.</p>


<h2>Counting Letters</h2>
<span class="index" value="ord function" />
<span class="index" value="function!ord" />
<span class="index" value="chr function" />
<span class="index" value="function!chr" />

<p>The <code>ord</code> function returns the integer representation of a
character:</p>

<pre class="python-interpreter">
>>> ord('a')
97
>>> ord('A')
65
>>>
</pre>

<p>We can see from this example why <code>'Appricot' &lt; 'axi'</code>
evaluates to <code>True</code>.</p>

<p>The <code>chr</code> function is the inverse of <code>ord</code>, it
takes an integer as an argument and returns its character representation:</p>

<pre class="python-interpreter">
>>> for i in range(65, 71):
...     print chr(i)
...
A
B
C
D
E
F
>>>
</pre>

<p>The following program counts the number of times each character occurs in
the book
<a href="resources/ch10/alice_in_wonderland.txt">Alice in Wonderland</a>:</p>

<pre class='python'>
infile = open('alice_in_wonderland.txt', 'r')
text = infile.read()
infile.close()

counts = 128*[0]

for letter in text:
    counts[ord(letter)] += 1

print "%-12s%s" % ("Character", "Count")
print "================="

def display(i):
    if i == 10: return 'LF'
    if i == 13: return 'CR'
    return chr(i)


for i in range(len(counts)):
    if counts[i]:
        print "%-12s%d" % (display(i), counts[i])
</pre>


<h2>Glossary</h2>
<span class="index" value="module" />
<span class="index" value="standard library" />
<span class="index" value="command prompt" />
<span class="index" value="pydoc" />
<span class="index" value="import" />
<span class="index" value="import statement" />
<span class="index" value="statement!import" />
<span class="index" value="namespace" />
<span class="index" value="naming collision" />
<span class="index" value="attribute" />
<span class="index" value="dot operator" />
<span class="index" value="operator!." />
<span class="index" value="method" />
<span class="index" value="volatile memory" />
<span class="index" value="non-volatile memory" />
<span class="index" value="mode (file object)" />
<span class="index" value="file" />
<span class="index" value="directory" />
<span class="index" value="path" />
<span class="index" value="delimiter" />

<dl>
<dt>module:</dt>
<dd>A file containing Python definitions and statements intended for use
in other Python programs.  The contents of a module are made available to the
other program by using the <code>import</code> statement.</dd>

<dt>standard library:</dt>
<dd>A library is a collection of software used as tools in the development
of other software.  The standard library of a programming language is the set
of such tools that are distributed with the core programming language.
Python comes with an extensive standard library.</dd>

<dt>command prompt:</dt>
<dd>A string displayed by a 
<a href="http://en.wikipedia.org/wiki/Command_line">command line interface</a>
indicating that commands can be entered.</dd>

<dt>pydoc:</dt>
<dd>A documentation generator that comes with the Python standard library.</dd>

<dt>import:</dt>
<dd>A statement which makes the objects contained in a module available for
use.  There are two forms for the import statement.  Using a hypothetical
module named <code>mymod</code> containing functions <code>f1</code>
and <code>f2</code>, and variables <code>v1</code> and <code>v2</code>,
examples of these two forms include:
<pre class='python'>
import mymod 
</pre>
The first form.
<pre class='python'>
from mymod import f1, f2, v1, v2 
</pre>
Import all objects
</dd>

<dt>namespace:</dt>
<dd>A syntactic container providing a context for names so that the same name
can reside in different namespaces without ambiguity.  In Python, modules,
classes, functions and methods all form namespaces.</dd>

<dt>naming collision:</dt>
<dd>A situation in which two or more names in a given namespace cannot be
unambiguously resolved.  Using
<pre class='python'>
import string
</pre>
instead of
<pre class='python'>
from string import *
</pre>
prevents naming collisions.
</dd>

<dt>attribute:</dt>
<dd>
A variable defined inside a module (or class or instance -- as we will see
later).  Module attributes are accessed by using the <b>dot operator</b>
(<code>.</code>).
</dd>

<dt>dot operator:</dt>
<dd>
The dot operator (<code>.</code>) permits access to attributes and functions
of a module (or attributes and methods of a class or instance -- as we will 
see later).
</dd>

<dt>method:</dt>
<dd>
Function-like attribute of an object.  Methods are <em>invoked</em> (called)
on an object using the dot operator.  For example:
<pre class='python-interpreter'>
>>> s = "this is a string."
>>> s.upper()
'THIS IS A STRING.'
>>>
</pre>
We say that the method, <code>upper</code> is invoked on the string,
<code>s</code>.  <code>s</code> is implicitely the first argument to
<code>upper</code>.
</dd>

<dt>volatile memory:</dt>
<dd>
Memory which requires an electrical current to maintain state.  The
<em>main memory</em> or RAM of a computer is volatile.  Information stored in
RAM is lost when the computer is turned off.
</dd>

<dt>non-volatile memory:</dt>
<dd>
Memory that can maintain its state without power.  Hard drives, flash drives,
and rewritable compact disks (CD-RW) are each examples of non-volatile memory.
</dd>

<dt>file:</dt>
<dd>A named entity, usually stored on a hard drive, floppy disk, or CD-ROM,
that contains a stream of characters.</dd>

<dt>directory:</dt>
<dd>A named collection of files, also called a folder.</dd>

<dt>mode:</dt>
<dd>A distinct method of operation within a computer program.  Files in Python
can be openned in one of three modes: read ('r'), write ('w'), and append ('a').
</dd>

<dt>path:</dt>
<dd>A sequence of directory names that specifies the exact location of a file.
</dd>

<dt>text file:</dt>
<dd>A file that contains printable characters organized into lines separated
by newline characters.</dd>

<dt>continue statement:</dt>
<dd>A statement that causes the current iteration of a loop to end.  The flow
of execution goes to the top of the loop, evaluates the condition, and
proceeds accordingly.</dd>

<dt>delimiter:</dt>
<dd>
</dd>
</dl>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
Complete the following:
<ul>
  <li>Start the pydoc server with the command <code>pydoc -g</code> at the
  command prompt.</li>
  <li>Click on the <q>open browser</q> button in the pydoc tk window.</li>
  <li>Find the <code>calendar</code> module and click on it.</li> 
  <li>While looking at the <em>Functions</em> section, try out the following
  in a Python shell:
  <pre class='python-interpreter'>
  >>> import calendar
  >>> year = calendar.calendar(2008)
  >>> print year                      # What happens here?
  </pre></li>
  <li>Experiment with <code>calendar.isleap</code>.  What does it expect as
  an argument?  What does it return as a result?  What kind of a function is
  this?</li>
</ul>
Make detailed notes about what you learned from this exercise.
</div></li>

<li><div class="exercise">
<p>If you don't have <code>Tkinter</code> installed on your computer, then
<code>pydoc -g</code> will return an error, since the graphics window that
it opens requires <code>Tkinter</code>.  An alternative is to start the web
server directly:</p>
<pre class='shell'>
$ pydoc -p 7464
</pre>
<p>This starts the pydoc web server on port 7464.  Now point your web browser
at:</p>
<pre>
http://localhost:7464
</pre>
<p>and you will be able to browse the Python libraries installed on you
system.</p>
<p>Use this approach to start <code>pydoc</code> and take a look at the
<code>math</code> module.</p>
<ol style='list-style-type: lower-alpha;'>
  <li>How many functions are in the <code>math</code> module?</li>
  <li>What does <code>math.ceil</code> do?  What about <code>math.floor</code>?
  (<em>hint:</em> both <code>floor</code> and <code>ceil</code> expect floating
  point arguments.)
  </li>
  <li>Describe how we have been computing the same value as
  <code>math.sqrt</code> without using the <code>math</code> module.</li>
  <li>What are the two data contstants in the <code>math</code> module?</li>
</ol>
<p>Record detailed notes of your investigation in this exercise.</p>
</div></li>

<li><div class="exercise">
Use <code>pydoc</code> to investigate the <code>copy</code> module.  What does
<code>deepcopy</code> do?  In which exercises from last chapter would
<code>deepcopy</code> have come in handy?
</div></li>

<li><div class="exercise">
<p>
Create a module named <code>mymodule1</code>.  Add attributes
<code>myage</code> set to your current age, and <code>year</code> set to the
current year.  Create another module named <code>mymodule2</code>.  Add
attributes <code>myage</code> set to 0, and <code>year</code> set to the year
you were born.
</p>
<p>
Now create a file named <code>namespace_test.py</code>.  Import both of the
modules above and write the following statement:</p>
<pre class='python'>
print (mymodule2.myage - mymodule1.myage) == (mymodule2.year - mymodule1.year)
</pre>
When you will run <code>namespace_test.py</code> you will see either 
<code>True</code> or <code>False</code> as output depending on whether or not
you've had a birthday between now and the beginning of the new year.
</div></li>

<li><div class="exercise">
In a Python shell try the following:
<pre class='python-shell'>
>>> import this
</pre>
What does Tim Peter's have to say about namespaces?
</div></li>

<li><div class="exercise">
Use <code>pydoc</code> to find and test three other functions from the
<code>string</code> module.  Record your findings.
</div></li>

<li><div class="exercise">
Rewrite <code>matrix_mult</code> from the last chapter using what you have
learned about list methods.
</div></li>

<li><div class="exercise">
<span class="index" value="dir" />
<span class="index" value="function!dir" />
The <code>dir</code> function, which we first saw in Chapter 7, prints out
a list of the <em>attributes</em> of an object passed to it as an argument.
In other words, <code>dir</code> returns the contents of the <em>namespace</em>
of its argument.
<br /><br />
Use <code>dir(str)</code> and <code>dir(list)</code> to find at least three
string and list methods which have not been introduced in the examples in the
chapter.  You should ignor anything that begins with double underscore (__)
for the time being.  Be sure to make detailed notes of your findings, including 
names of the new methods and examples of their use.
<br /><br />
(<em>hint:</em>  Print the docstring of a function you want to explore.  For
example, to find out how <code>str.join</code> works,
<code>print str.join.__doc__</code>)
</div></li>

<li><div class="exercise">
Give the Python interpreter's response to each of the following from a
continuous interpreter session:
<ol style="list-style-type: lower-alpha;">
  <li><pre class='python-interpreter'>
  >>> s = "If we took the bones out it wouldn't be cruncy would it?"
  >>> s.split()
  </pre></li>

  <li><pre class='python-interpreter'>
  >>> type(s.split())
  </pre></li>

  <li><pre class='python-interpreter'>
  >>> s.split('o')
  </pre></li>

  <li><pre class='python-interpreter'>
  >>> s.split('i')
  </pre></li>

  <li><pre class='python-interpreter'>
  >>> '0'.join(s.split('o'))
  </pre></li>
</ol>
Be sure you understand why you get each result.  Then apply what you have
learned to fill in the body of the function below using the <code>split</code>
and <code>join</code> methods of <code>str</code> objects:
<pre class='python'>
def myreplace(old, new, s):
    """
    Replace all occurances of old with new in the string s.

       >>> myreplace(',', ';', 'this, that, and, some, other, thing')
       'this; that; and; some; other; thing'
       >>> myreplace(' ', '**', 'Words will now be seperated by stars.')
       'Words**will**now**be**seperated**by**stars.'
    """
</pre>
Your solution should pass all doctests.
</div></li>

</ol>


</body>
</html>
