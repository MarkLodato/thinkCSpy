<html>
<head>
  <title>Modules and files</title>
</head>
<body>

<h1>Modules and files</h1>

<h2>Modules</h2>
<span class="index" value="module" />
<span class="index" value="standard library" />
<span class="index" value="import" />
<span class="index" value="import statement" />
<span class="index" value="statement!import" />
<span class="index" value="namespace" />

<p>A <b>module</b> is a file containing Python definitions and statements
intended for use in other Python programs.  There are many Python modules that
come bundled with Python as part of the <b>standard library</b>.  We have seen
two of these already, the <code>doctest</code> module and the
<code>string</code> module.</p>


<h2>pydoc</h2>
<span class="index" value="pydoc" />
<span class="index" value="command prompt" />

<p>We can use <b>pydoc</b> to search through the Python libraries installed on
our system.  At the <b>command prompt</b> type the following:</p>

<pre class='shell'>
$ pydoc -g
</pre>

<p>and the following will appear:</p>


<p><img src="illustrations/pydoc_tk.png" /></p>

<p>(<em>note</em>: see exercise 2 if you get an error)</p>

<p>Click on the <q>open browser</q> button to launch a web browser window
containing the documentation generated by <code>pydoc</code>:</p> 

<p><img src="illustrations/pydoc_firefox.png" /></p>

<p>You are incouraged to use <code>pydoc</code> to poke around the extensive
libraries that come with Python.</p>


<h2>Creating modules</h2>

<p>All we need to create a module is a text file with a <code>.py</code>
extension on the filename:</p>

<pre class="python">
#  seqtools.py
#
def remove_at(pos, seq):
    return seq[:pos] + seq[pos+1:]
</pre>

<p>We can now use our module in both scripts and the Python shell.  To do so,
we must first <b>import</b> the module.  There are two ways to do this:</p>

<pre class="python-interpreter">
>>> from seqtools import remove_at
>>> s = "A string!"
>>> remove_at(4, s)
'A sting!'
</pre>

<p>and:</p>

<pre class="python-interpreter">
>>> import seqtools
>>> s = "A string!"
>>> seqtools.remove_at(4, s)
'A sting!'
</pre>

<p>In the first example, <code>remove_at</code> is called just like the 
functions we have seen previously, while in the second example the name of the
module and a dot (.) are written before the function name.</p> 

<p>Notice that we do not include the <code>.py</code> file extension when
importing.  It must be there for a file to be a Python module, but it is not
included in the <b>import statement</b>.</p>


<h2>Namespaces</h2>
<span class="index" value="namespace" />

<p>Since each module determines its own <b>namespace</b>, the same name can
appear in several modules without causing a problem.</p>

<pre class='python'>
# module1.py

question = "What is the meaning of life, the Universe, and everything?"
answer = 42
</pre>

<pre class='python'>
# module2.py

question = "What is your quest?"
answer = "To seek the holy grail." 
</pre>

<p>The use of modules makes it possible to break up very large programs into
managable sized parts, and to keep related parts together.  Modules also help
several programmers work on the same project without having namespace clashes.
</p>


<h2>The <code>sys</code> module and <code>argv</code></h2>
<span class="index" value="sys module" />
<span class="index" value="module!sys" />
<span class="index" value="argv" />
<span class="index" value="command line" />
<span class="index" value="command line arguments" />

<p>The <code>sys</code> module contains a variable named <code>argv</code>,
which holds a list of strings read in from the <b>command line</b> when
a Python script is run.  These <b>command line arguments</b> can be used to
pass information into a program at the same time it is invoked.</p>

<pre class="python">
#
# demo_argv.py
#
from sys import argv

print argv 
</pre>

<p>Running this program from the unix command prompt demonstrates how
<code>sys.argv</code> works:</p>

<pre class="shell">
$ python demo_argv.py this and that 1 2 3
['demo_argv.py', 'this', 'and', 'that', '1', '2', '3']
$ 
</pre>

<p><code>argv</code> is a list of strings.  Notice that the first element is
the name of the program.  Arguments are seperated by white space, and separated
into a list in the same way that <code>string.split</code> operates.  If you
want an argument with white space in it, use quotes:</p>

<pre class="shell">
$ python demo_argv.py "this and" that "1 2" 3
['demo_argv.py', 'this and', 'that', '1 2', '3']
$ 
</pre>


<h2>The <code>eval</code> function</h2>
<span class="index" value="eval" />
<span class="index" value="funtion!eval" />

<p>The <code>eval</code> function takes a string as an argument and
<em>evaluates</em> it as a Python expression, returning the value of the
expression.</p>

<pre class="python-interpreter">
>>> eval('4 + 5')
9
>>> thing = eval('[1, 2, 3]')
>>> type(thing)
&lt;type 'list'&gt;
>>> thing
[1, 2, 3]
</pre>

<p>Be advised that there are security risks associated with using
<code>eval</code> with data from untrusted sources (see the 
<a href="http://en.wikipedia.org/wiki/Eval">wikipedia article on eval</a>
for more on this).  In the example above we check to make sure the only
data evaluated consists of a string of digits."</p>

<p>Combining <code>argv</code> with <code>eval</code> we can write a handy
little command line program that prints a truth table for an arbitrary
boolean expression involving two boolean variables, <code>p</code> and
<code>q</code>:</p>

<pre class="python">
from sys import argv

def truth_table(expression):
    print "\n p      q      %s"  % expression
    length = len( " p      q      %s"  % expression)
    print length*"="

    for p in True, False:
        for q in True, False:
            print "%-7s %-7s %-7s" % (p, q, eval(expression))
    print

if len(argv) != 2:
    print "Invalid input, enter a quoted string containing a boolean"
    print "expression in p and q."
else:
    truth_table(argv[1])
</pre>

<p>Save the program above in a file named <code>truth_in_p_and_q.py</code>.
It can now be passed an arbitrary boolean expression involving boolean
variables <code>p</code> and <code>q</code> at the command line, and it
will print a truth table for the given expression:</p>

<pre class="shell">
$ python truth_in_p_and_q.py "(p and not q) or (not p and q)"

 p      q      (p and not q) or (not p and q)
=============================================
True    True    False  
True    False   True   
False   True    True   
False   False   False  

$
</pre>

<p>Note that the boolean expression needs to be enclosed in quotation marks.
</p>


<h2>Reading and writing text files</h2>
<span class="index" value="volitile memory" />
<span class="index" value="non-volitile memory" />
<span class="index" value="file" />

<p>While a program is running, its data is stored in
<em>random access memory</em> (RAM).  RAM is fast and inexpensive, but it is
also <b>volitile</b>, which means that when the program ends, or the computer
shuts down, data in RAM disappears.  To store data permanently, you have to put 
it in a <b>non-volitile</b> storage medium, such a hard drive, usb drive, or
CD-RW.</p>

<p>Data on non-volitile storage media is stored in named locations on the
media called <b>files</b>.  By reading and writing files, programs can save
information between program runs.</p>

<p>Working with files is a lot like working with a notebook.  To use a
notebook, you have to open it.  When you're done, you have to close it.  While
the notebook is open, you can either write in it or read from it.  In either
case, you know where you are in the notebook.  You can read the whole notebook
in its natural order or you can skip around.</p>

<p>All of this applies to files as well.  To open a file, you specify its name
and indicate whether you want to read or write.</p>

<p>Opening a file creates a file object.  In this example, the variable
<code>f</code> refers to the new file object.</p>

<pre class="python-interpreter">
>>> f = open('test.dat', 'w')
>>> print f
&lt;open file 'test.dat', mode 'w' at 0x2aaaaab80cd8&gt;
</pre>

<p>The open function takes two arguments.  The first is the name of the file,
and the second is the <b>mode</b>.  Mode <code>'w'</code> means that we are
opening the file for writing.</p>

<p>If there is no file named <code>test.dat</code>, it will be created.  If
there already is one, it will be replaced by the file we are writing.</p>

<p>When we print the file object, we see the name of the file, the mode, and
the location of the object.</p>

<p>To put data in the file we invoke the <code>write</code> method on the file
object:</p>

<pre class="python-interpreter">
>>> f.write("Now is the time")
>>> f.write("to close the file")
</pre>

<p>Closing the file tells the system that we are done writing and makes the
file available for reading:</p>

<pre class="python-interpreter">
>>> f.close()
</pre>

<p>Now we can open the file again, this time for reading, and read the contents 
into a string.  This time, the mode argument is <code>'r'</code> for reading:
</p>

<pre class="python-interpreter">
>>> f = open('test.dat', 'r')
</pre>

<p>If we try to open a file that doesn't exist, we get an error:</p>

<span class="index" value="runtime error" />

<pre class="python-interpreter">
>>> f = open('test.cat', 'r')
IOError: [Errno 2] No such file or directory: 'test.cat'
</pre>

<p>Not surprisingly, the <code>read</code> method reads data from the file.
With no arguments, it reads the entire contents of the file into a single
string:</p>

<pre class="python-interpreter">
>>> text = f.read()
>>> print text
Now is the timeto close the file
</pre>

<p>There is no space between <q>time</q> and <q>to</q> because we did not write 
a space between the strings.</p>

<p><code>read</code> can also take an argument that indicates how many
characters to read:</p>

<pre class="python-interpreter">
>>> f = open('test.dat', 'r')
>>> print f.read(5)
Now i
</pre>

<p>If not enough characters are left in the file, <code>read</code> returns the 
remaining characters.  When we get to the end of the file, <code>read</code>
returns the empty string:</p>

<pre class="python-interpreter">
>>> print f.read(1000006)
s the timeto close the file
>>> print f.read()
   
>>>
</pre>

<p>The following function copies a file, reading and writing up to fifty
characters at a time.  The first argument is the name of the original file; the 
second is the name of the new file:</p>

<pre class="python">
def copy_file(old_file, new_file):
    f1 = open(old_file, 'r')
    f2 = open(new_file, 'w')
    while True:
        text = f1.read(50)
        if text == "":
            break
        f2.write(text)
    f1.close()
    f2.close()
    return
</pre>

<p>This functions continues looping, reading 50 characters from <code>f1</code>
and writing the same 50 charaters to <code>f2</code> until the end of
<code>f1</code> is reached, at which point <code>text</code> is empty and the
<code>break</code> statement is executed.</p>


<h2>Text files</h2>
<span class="index" value="text file" />
<span class="index" value="file!text" />

<p>A <b>text file</b> is a file that contains printable characters and
whitespace, organized into lines separated by newline characters.  Since Python 
is specifically designed to process text files, it provides methods that make
the job easy.</p>

<p>To demonstrate, we'll create a text file with three lines of text separated
by newlines:</p>

<pre class="python-interpreter">
>>> f = open("test.dat","w")
>>> f.write("line one\nline two\nline three\n")
>>> f.close()
</pre>

<p>The <code>readline</code> method reads all the characters up to and
including the next newline character:</p>

<pre class="python-interpreter">
>>> f = open("test.dat","r")
>>> print f.readline()
line one
   
>>>
</pre>

<p><code>readlines</code> returns all of the remaining lines as a list of
strings:</p>

<pre class="python-interpreter">
>>> print f.readlines()
['line two\012', 'line three\012']
</pre>

<p>In this case, the output is in list format, which means that the strings
appear with quotation marks and the newline character appears as the escape
sequence <code>\\012</code>.</p>

<p>At the end of the file, <code>readline</code> returns the empty string
and <code>readlines</code> returns the empty list:</p>

<pre class="python-interpreter">
>>> print f.readline()
   
>>> print f.readlines()
[]
</pre>

<p>The following is an example of a line-processing program.
<code>filter</code> makes a copy of <code>old_file</code>, omitting any
lines that begin with <code>#</code>:</p>

<pre class="python">
def filter(old_file, new_file):
    f1 = open(old_file, 'r')
    f2 = open(new_file, 'w')
    while True:
        text = f1.readline()
        if text == "":
           break
        if text[0] == '#':
           continue
        f2.write(text)
    f1.close()
    f2.close()
    return
</pre>

<p>The <code>continue</code> statement ends the current iteration of the loop,
but continues looping.  The flow of execution moves to the top of the loop,
checks the condition, and proceeds accordingly.</p>

<span class="index" value="continue statement" />
<span class="index" value="statement!continue" />

<p>Thus, if <code>text</code> is the empty string, the loop exits.  If the
first character of <code>text</code> is a hash mark, the flow of execution goes 
to the top of the loop.  Only if both conditions fail do we copy
<code>text</code> into the new file.</p>


<h2>Directories</h2>
<span class="index" value="file system" />
<span class="index" value="directory" />

<p>Files on non-volitile storage media are organized by a set of rules known
as a <b>file system</b>.  File systems are made up of files and
<b>directories</b>, which are containers for both files and other directories.
</p>

<p>When you create a new file by opening it and writing, the new file goes in
the current directory (wherever you were when you ran the program).  Similarly, 
when you open a file for reading, Python looks for it in the current directory.
</p>

<p>If you want to open a file somewhere else, you have to specify the
<b>path</b> to the file, which is the name of the directory
(or folder) where the file is located:</p>

<pre class="python-interpreter">
>>>   f = open('/usr/share/dict/words', 'r')
>>>   print f.readline()
Aarhus
</pre>

<p>This example opens a file named <code>words</code> that resides in a
directory named <code>dict</code>, which resides in <code>share</code>, which
resides in <code>usr</code>, which resides in the top-level directory of the
system, called <code>/</code>.</p>

<span class="index" value="path" />
<span class="index" value="delimiter" />

<p>You cannot use <code>/</code> as part of a filename; it is reserved as a
delimiter between directory and filenames.</p>

<p>The file <code>/usr/share/dict/words</code> contains a list of words
in alphabetical order, of which the first is the name of a Danish university.
</p>


<h2>Counting Letters</h2>

<p>The following program counts the number of times each character occurs in
the book
<a href="resources/ch10/alice_in_wonderland.txt">Alice in Wonderland</a>:</p>

<pre class='python'>
infile = open('alice_in_wonderland.txt', 'r')
text = infile.read()
counts = 128*[0]

for letter in text:
    counts[ord(letter)] += 1

print "%-12s%s" % ("Character", "Count")
print "================="

def display(i):
    if i == 10: return 'LF'
    if i == 13: return 'CR'
    return chr(i)


for i in range(len(counts)):
    if counts[i]:
        print "%-12s%d" % (display(i), counts[i])
</pre>


<h2>Glossary</h2>
<span class="index" value="module" />
<span class="index" value="standard library" />
<span class="index" value="command prompt" />
<span class="index" value="pydoc" />
<span class="index" value="import" />
<span class="index" value="namespace" />
<span class="index" value="command line" />
<span class="index" value="command line arguments" />
<span class="index" value="volitile memory" />
<span class="index" value="non-volitile memory" />
<span class="index" value="file" />
<span class="index" value="directory" />
<span class="index" value="path" />
<span class="index" value="math module" />
<span class="index" value="module!math" />

<dl>
<dt>module:</dt>
<dd>A file containing Python definitions and statements intended for use
in other Python programs.  The contents of a module are made available to the
other program by using the <code>import</code> statement.</dd>

<dt>standard library:</dt>
<dd>A library is a collection of software used as tools in the development
of other software.  The standard library of a programming language is the set
of such tools that are distributed with the core programming language.
Python comes with an extensive standard library.</dd>

<dt>command prompt:</dt>
<dd>A string displayed by a 
<a href="http://en.wikipedia.org/wiki/Command_line">command line interface</a>
indicating that commands can be entered.</dd>

<dt>pydoc:</dt>
<dd>A documentation generator that comes with the Python standard library.</dd>

<dt>import:</dt>
<dd>A statement which makes the objects contained in a module available for
use.  There are two forms for the import statement.  Using a hypothetical
module named <code>mymod</code> containing functions <code>f1</code>
and <code>f2</code>, and variables <code>v1</code> and <code>v2</code>,
examples of these two forms include:
<pre class='python'>
import mymod 
</pre>
The first form.
<pre class='python'>
from mymod import f1, f2, v1, v2 
</pre>
Import all objects
</dd>

<dt>namespace:</dt>
<dd>A container providing a context for names so that the same name can reside
in different namespaces without ambiguity.  In Python, modules, classes,
functions and methods all form namespaces.</dd>

<dt>command line:</dt>
<dd>The sequence of characters read into the <em>command interpreter</em> in
a <em>command line interface</em> (see the Wikipedia article on
<a href="http://en.wikipedia.org/wiki/Command_line">command line interface</a>
for more information).</dd>

<dt>command line argument:</dt>
<dd>
A value passed to a program along with the program's invocation at the
<em>command prompt</em> of a command line interface (CLI).</dd>

<dt>file:</dt>
<dd>A named entity, usually stored on a hard drive, floppy disk, or CD-ROM,
that contains a stream of characters.</dd>

<dt>directory:</dt>
<dd>A named collection of files, also called a folder.</dd>

<dt>mode:</dt>
<dd>A distinct method of operation within a computer program.  Files in Python
can be openned in one of three modes: read ('r'), write ('w'), and append ('a').
</dd>

<dt>path:</dt>
<dd>A sequence of directory names that specifies the exact location of a file.
</dd>

<dt>text file:</dt>
<dd>A file that contains printable characters organized into lines separated
by newline characters.</dd>

<dt>continue statement:</dt>
<dd>A statement that causes the current iteration of a loop to end.  The flow
of execution goes to the top of the loop, evaluates the condition, and
proceeds accordingly.</dd>

<dt>math module</dt>
<dd>A collection of trigonometric, exponential, and logrithmic functions and
constants.  Adding <code>import math</code> in a Python program enables access
to the module.</dd>
</dl>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
Complete the following:
<ul>
  <li>Start the pydoc server with the command <code>pydoc -g</code> at the
  command prompt.</li>
  <li>Click on the <q>open browser</q> button in the pydoc tk window.</li>
  <li>Find the <code>calendar</code> module and click on it.</li> 
  <li>While looking at the <em>Functions</em> section, try out the following
  in a Python shell:
  <pre class='python-interpreter'>
  >>> import calendar
  >>> year = calendar.calendar(2008)
  >>> print year                      # What happens here?
  </pre></li>
  <li>Experiment with <code>calendar.isleap</code>.  What does it expect as
  an argument?  What does it return as a result?  What kind of a function is
  this?</li>
</ul>
Make detailed notes about what you learned from this exercise.
</div></li>

<li><div class="exercise">
<p>If you don't have <code>Tkinter</code> installed on your computer, then
<code>pydoc -g</code> will return an error, since the graphics window that
it opens requires <code>Tkinter</code>.  An alternative is to start the web
server directly:</p>
<pre class='shell'>
$ pydoc -p 7464
</pre>
<p>This starts the pydoc web server on port 7464.  Now point your web browser
at:</p>
<pre>
http://localhost:7464
</pre>
<p>and you will be able to browse the Python libraries installed on you
system.</p>
<p>Use this approach to start <code>pydoc</code> and take a look at the
<code>math</code> module.</p>
<ol style='list-style-type: lower-alpha;'>
  <li>How many functions are in the <code>math</code> module?</li>
  <li>What does <code>math.ceil</code> do?  What about <code>math.floor</code>?
  </li>
  <li>Describe how we have been computing the same value as
  <code>math.sqrt</code> without using the <code>math</code> module.</li>
  <li>What are the two data contstants in the <code>math</code> module?</li>
</ol>
<p>Record detailed notes of your investigation in this exercise.</p>
</div></li>

<li><div class="exercise">
Use <code>pydoc</code> to investigate the <code>copy</code> module.  What
does <code>deepcopy</code> do?  In which exercises from the last would
<code>deepcopy</code> have come in handy?
</div></li>

<li><div class="exercise">
In a Python shell try the following:
<pre class='python-shell'>
>>> import this
</pre>
What does Tim Peter's have to say about namespaces?
</div></li>

</ol>


</body>
</html>
