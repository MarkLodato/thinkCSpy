<html>
<head>
  <title>Fruitful functions</title>
</head>
<body>

<h1>Fruitful functions</h1>

<h2>Return values</h2>
<span class="index" value="return value" />

<p>The built-in functions we have used, such as <code>abs</code>,
<code>pow</code>, and <code>max</code>, have produced results.  Calling each of
these functions generates a value, which we usually assign to a variable or 
use as part of an expression.</p>

<pre class="python">
biggest = max(3, 7, 2, 5)
x = abs(3 - 11) + 10 
</pre>

<p>But so far, none of the functions we have written has returned a value.</p>

<p>In this chapter, we are going to write functions that return values, which
we will call <b>fruitful functions</b>, for want of a better name.
The first example is <code>area</code>, which returns the area of a circle with 
the given radius:</p>

<pre class="python">
def area(radius):
    temp = 3.14159 * radius**2
    return temp
</pre>

<p>We have seen the <code>return</code> statement before, but in a fruitful
function the <code>return</code> statement includes a
<b>return value</b>.  This statement means: <q>Return immediately
from this function and use the following expression as a return value.</q>
The expression provided can be arbitrarily complicated, so we could have
written this function more concisely:</p>

<pre class="python">
def area(radius):
    return 3.14159 * radius**2
</pre>

<p>On the other hand, <b>temporary variables</b> like
<code>temp</code> often make debugging easier.</p>

<span class="index" value="temporary variable" />
<span class="index" value="variable!temporary" />

<p>Sometimes it is useful to have multiple return statements, one in each
branch of a conditional.  We have already seen the built-in <code>abs</code>,
now we see how to write our own:</p>

<pre class="python">
def absolute_value(x):
    if x &lt; 0:
        return -x
    else:
        return x
</pre>

<p>Since these <code>return</code> statements are in an alternative
conditional, only one will be executed.  As soon as one is executed, the
function terminates without executing any subsequent statements.</p>

<p>Another way to write the above function is to leave out the
<code>else</code> and just follow the <code>if</code> condition by the
second <code>return</code> statement.</p>

<pre class="python">
def absolute_value(x):
    if x &lt; 0:
        return -x
    return x
</pre>

<p>Think about this version and convince yourself it works the same as
the first one.</p>

<p>Code that appears after a <code>return</code> statement, or any other place
the flow of execution can never reach, is called <b>dead code</b>.
</p>

<span class="index" value="dead code" />

<p>In a fruitful function, it is a good idea to ensure that every possible path 
through the program hits a <code>return</code> statement.  The following
version of <code>absolute_value</code> fails to do this:</p>

<pre class="python">
def absolute_value(x):
    if x &lt; 0:
        return -x
    elif x &gt; 0:
        return x
</pre>

<p>This version is not correct because if <code>x</code> happens to be 0,
neither condition is true, and the function ends without hitting a
<code>return</code> statement.  In this case, the return value is a special
value called <b><code>None</code></b>:</p>

<span class="index" value="None" />
<span class="index" value="NoneType" />
<span class="index" value="value!None" />
<span class="index" value="type!NoneType" />

<pre class="python-interpreter">
>>> print absolute_value(0)
None
</pre>

<p><code>None</code> is the unique value of a type called the
<code>NoneType</code>:
</p>

<pre class="python-interpreter">
>>> type(None)
&lt;type 'NoneType'>
</pre>

<p>All Python functions return <code>None</code> whenever they do not return
another value.</p>


<h2>Program development</h2>
<a name="program development" />
<span class="index" value="scaffolding" />

<p>At this point, you should be able to look at complete functions and tell
what they do.  Also, if you have been doing the exercises, you have written
some small functions.  As you write larger functions, you might start to have
more difficulty, especially with runtime and semantic errors.</p>

<p>To deal with increasingly complex programs, we are going to suggest a
technique called <b>incremental development</b>.  The goal of
incremental development is to avoid long debugging sessions by adding and
testing only a small amount of code at a time.</p>

<span class="index" value="incremental development" />
<span class="index" value="development!incremental" />

<p>As an example, suppose you want to find the distance between two points,
given by the coordinates (x<sub>1</sub>, y<sub>1</sub>) and
(x<sub>2</sub>, y<sub>2</sub>).  By the Pythagorean theorem, the distance
is:</p>

<p><img src="illustrations/distance_formula.png" /></p>

<p>The first step is to consider what a <code>distance</code> function should
look like in Python. In other words, what are the inputs (parameters) and what
is the output (return value)?</p>

<p>In this case, the two points are the inputs, which we can represent using
four parameters.  The return value is the distance, which is a floating-point
value.</p>

<p>Already we can write an outline of the function:</p>

<pre class="python">
def distance(x1, y1, x2, y2):
    return 0.0
</pre>

<p>Obviously, this version of the function doesn't compute distances; it
always returns zero.  But it is syntactically correct, and it will run, which
means that we can test it before we make it more complicated.</p>

<p>To test the new function, we call it with sample values:</p>

<pre class="python-interpreter">
>>> distance(1, 2, 4, 6)
0.0
</pre>

<p>We chose these values so that the horizontal distance equals 3 and the
vertical distance equals 4; that way, the result is 5
(the hypotenuse of a 3-4-5 triangle). When testing a function, it is useful to
know the right answer.</p>

<p>At this point we have confirmed that the function is syntactically
correct, and we can start adding lines of code.  After each incremental change, 
we test the function again.  If an error occurs at any point, we know where it
must be---in the last line we added.</p>

<p>A logical first step in the computation is to find the differences
x<sub>2</sub> - x<sub>1</sub> and y<sub>2</sub> - y<sub>1</sub>.  We will
store those values in temporary variables named <code>dx</code> and
<code>dy</code> and print them.</p>

<pre class="python">
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    print "dx is", dx
    print "dy is", dy
    return 0.0
</pre>

<p>If the function is working, the outputs should be 3 and 4.  If so, we know
that the function is getting the right parameters and performing the first
computation correctly.  If not, there are only a few lines to check.</p>

<p>Next we compute the sum of squares of <code>dx</code> and
<code>dy</code>:</p>

<pre class="python">
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx**2 + dy**2
    print "dsquared is: ", dsquared
    return 0.0
</pre>

<p>Notice that we removed the <code>print</code> statements we wrote in the
previous step.  Code like that is called <b>scaffolding</b> because
it is helpful for building the program but is not part of the final product.
</p>

<p>Again, we would run the program at this stage and check the output
(which should be 25).</p>

<p>Finally, using the fractional exponent <code>0.5</code> to find the
square root, we compute and return the result:</p>

<pre class="python">
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx**2 + dy**2
    result = dsquared**0.5
    return result
</pre>

<p>If that works correctly, you are done.  Otherwise, you might want to print
the value of <code>result</code> before the return statement.</p>

<p>When you start out, you should add only a line or two of code at a time.  As
you gain more experience, you might find yourself writing and debugging bigger
chunks.  Either way, the incremental development process can save you a lot of
debugging time.</p>

<p>The key aspects of the process are:</p>
<ol>
<li>Start with a working program and make small incremental changes.  At any
point, if there is an error, you will know exactly where it is.</li>

<li>Use temporary variables to hold intermediate values so you can output and
check them.</li>

<li>Once the program is working, you might want to remove some of the
scaffolding or consolidate multiple statements into compound expressions, but
only if it does not make the program difficult to read.</li>
</ol>


<h2>Composition</h2>
<span class="index" value="composition" />
<span class="index" value="function!composition" />

<p>As you should expect by now, you can call one function from within another.  
This ability is called <b>composition</b>.</p>

<p>As an example, we'll write a function that takes two points, the center of
the circle and a point on the perimeter, and computes the area of the circle.
</p>

<p>Assume that the center point is stored in the variables <code>xc</code> and
<code>yc</code>, and the perimeter point is in <code>xp</code> and
<code>yp</code>. The first step is to find the radius of the circle, which is
the distance between the two points.  Fortunately, we've just written a
function, <code>distance</code>, that does just that, so now all we have to do
is use it:</p>

<pre class="python">
radius = distance(xc, yc, xp, yp)
</pre>

<p>The second step is to find the area of a circle with that radius and return
it.  Again we will use one of our earlier functions:</p>

<pre class="python">
result = area(radius)
return result
</pre>

<p>Wrapping that up in a function, we get:</p>

<pre class="python">
def area2(xc, yc, xp, yp):
    radius = distance(xc, yc, xp, yp)
    result = area(radius)
    return result
</pre>

<p>We called this function <code>area2</code> to distinguish it from the
<code>area</code> function defined earlier.  There can only be one function
with a given name within a given module.</p>

<p>The temporary variables <code>radius</code> and <code>result</code> are
useful for development and debugging, but once the program is working, we can
make it more concise by composing the function calls:</p>

<pre class="python">
def area2(xc, yc, xp, yp):
    return area(distance(xc, yc, xp, yp))
</pre>


<h2>Boolean functions</h2>
<a name="boolean" />
<span class="index" value="boolean function" />
<span class="index" value="function!boolean" />

<p>Functions can return boolean values, which is often convenient for hiding
complicated tests inside functions.  For example:</p>

<pre class="python">
def is_divisible(x, y):
    if x % y == 0:
        return True 
    else:
        return False 
</pre>

<p>The name of this function is <code>is_divisible</code>.  It is common to
give <b>boolean functions</b> names that sound like yes/no questions.
<code>is_divisible</code> returns either <code>True</code> or
<code>False</code> to indicate whether the <code>x</code> is or is not
divisible by <code>y</code>.</p>

<p>We can make the function more concise by taking advantage of the fact that
the condition of the <code>if</code> statement is itself a boolean expression.  
We can return it directly, avoiding the <code>if</code> statement altogether:
</p>

<pre class="python">
def is_divisible(x, y):
    return x % y == 0
</pre>

<p>This session shows the new function in action:</p>

<pre class="python-interpreter">
>>> is_divisible(6, 4)
False
>>> is_divisible(6, 3)
True
</pre>

<p>Boolean functions are often used in conditional statements:</p>

<pre class="python">
if is_divisible(x, y):
    print "x is divisible by y"
else:
    print "x is not divisible by y"
</pre>

<p>It might be tempting to write something like:</p>

<pre class="python">
if is_divisible(x, y) == True:
</pre>

<p>But the extra comparison is unnecessary.</p>


<h2>The <code>function</code> type</h2>

<p>A function is another type in Python, joining <code>int</code>,
<code>float</code>, <code>str</code>,  <code>bool</code>, and
<code>NoneType</code>.</p>

<pre class="python-interpreter">
>>> def func():
...    return "function func was called..."
...
>>> type(func)
&lt;type 'function'&gt;
>>>
</pre>

<p>Just like the other types, functions can be passed as arguments to other
functions:</p>

<pre class="python">
def f(n):
    return 3*n - 6

def g(n):
    return 5*n + 2

def h(n):
    return -2*n + 17

def doto(value, func):
    return func(value)
    
print doto(7, f)
print doto(7, g)
print doto(7, h)
</pre>

<p><code>doto</code> is called three times.  7 is the argument for value
each time, and the functions <code>f</code>, <code>g</code>, and
<code>h</code> are passed in for <code>func</code> in turn.
The output of this script is:</p>

<pre class="shell">
15
37
3
</pre>

<p>This example is a bit contrived, but we will see situations later where
it is quite useful to pass a function to a function.</p>


<h2>Programming with style</h2>

<p>Readability is very important to programmers, since in practice programs
are read and modified far more often then they are written.  All the code
examples in this book will be consistent with the
<em>Python Enhancement Proposal 8</em>
(<a href="http://www.python.org/dev/peps/pep-0008/">PEP 8</a>),  a style
guide developed by the Python community.</p>

<p>We'll have more to say about style as our programs become more complex, but
a few pointers will be helpful already:</p>

<ul>
    <li>use 4 spaces for indentation</li>
    <li>imports should go at the top of the file</li>
    <li>separate function definitions with two blank lines</li>
    <li>keep function definitions together</li>
    <li>keep top level statements, including function calls, together at the
    botton of the program</li>
</ul>


<h2>Unit testing with <code>doctest</code></h2>

<p>It is a common best practice in software development these days to
include automatic <b>unit testing</b> of source code.  Unit testing provides
a way to automatically verify that individual pieces of code, such as
functions, are working properly.   This makes it possible to change the
implimentation of a function at a later time and quickly test that it still
does what it was intended to do.</p>

<p>Python has a built-in <code>doctest</code> module for easy unit testing.
To see how this works, put the following in a script named
<code>myfunctions.py</code>:</p>

<pre class='python'>
def is_divisible_by_2_or_5(n):
    """
      >>> is_divisible_by_2_or_5(8)
      True
    """


if __name__ == '__main__':
    import doctest
    doctest.testmod()
</pre>

<p>Running this script will produce the following output:</p>

<pre class='shell'>
$ python myfunctions.py 
**********************************************************************
File "myfunctions.py", line 3, in __main__.is_divisible_by_2_or_5
Failed example:
    is_divisible_by_2_or_5(8)
Expected:
    True
Got nothing
**********************************************************************
1 items had failures:
   1 of   1 in __main__.is_divisible_by_2_or_5
***Test Failed*** 1 failures.
$
</pre>

<p>This is an example of a <em>failing test</em>.  Tests in doctest are
written in the same format as Python shell sessions.  This test says: if you
call <code>is_divisible_by_2_or_5(8)</code> the result should be
<code>True</code>.  Since <code>is_divisible_by_2_or_5</code> as written
doesn't return anything at all, the test fails, and doctest tells us that
it expected <code>True</code> but got nothing.</p>

<p>We can make this test pass by returning <code>True</code>:</p>

<pre class='python'>
def is_divisible_by_2_or_5(n):
    """
      >>> is_divisible_by_2_or_5(8)
      True
    """
    return True


if __name__ == '__main__':
    import doctest
    doctest.testmod()
</pre>

<p>If we run it now, there will be no output, which indicates that the
test passed.  Note that the doctest string must be placed immediately after
the function definition header.</p>

<p>To see more detailed out put, call the script with the
<code>-v</code> command line option:</p>

<pre class='shell'>
$ python myfunctions.py -v
Trying:
    is_divisible_by_2_or_5(8)
Expecting:
    True
ok
1 items had no tests:
    __main__
1 items passed all tests:
   1 tests in __main__.is_divisible_by_2_or_5
1 tests in 2 items.
1 passed and 0 failed.
Test passed.
$
</pre>

<p>While the test passed, our test suite is clearly inadequete, since
<code>is_divisible_by_2_or_5</code> will now return <code>True</code> no
matter what argument is passed to it.  Here is a completed version
with a more complete test suite and code that makes the tests pass:</p>

<pre class='python'>
def is_divisible_by_2_or_5(n):
    """
      >>> is_divisible_by_2_or_5(8)
      True
      >>> is_divisible_by_2_or_5(7)
      False
      >>> is_divisible_by_2_or_5(5)
      True
      >>> is_divisible_by_2_or_5(9)
      False
    """
    return n % 2 == 0 or n % 5 == 0 


if __name__ == '__main__':
    import doctest
    doctest.testmod()
</pre>

<p>Run this script now with the <code>-v</code> command line option and see
what you get.</p>


<h2>Glossary</h2>
<span class="index" value="fruitful function" />
<span class="index" value="return value" />
<span class="index" value="temporary variable" />
<span class="index" value="variable!temporary" />
<span class="index" value="dead code" />
<span class="index" value="None" />
<span class="index" value="NoneType" />
<span class="index" value="type!NoneType" />
<span class="index" value="incremental development" />
<span class="index" value="scaffolding" />
<span class="index" value="composition" />
<span class="index" value="boolean function" />
<span class="index" value="function!boolean " />
<span class="index" value="function!composition" />
<span class="index" value="unit testing" />
<span class="index" value="doctest" />


<dl>
<dt>fruitful function:</dt>
<dd>A function that yields a return value.</dd>

<dt>return value:</dt>
<dd>The value provided as the result of a function call.</dd>

<dt>temporary variable:</dt>
<dd>A variable used to store an intermediate value in a complex calculation.
</dd>

<dt>dead code:</dt>
<dd>Part of a program that can never be executed, often because it appears
after a <code>return</code> statement.</dd>

<dt><code>None</code>:</dt>
<dd>A special Python value returned by functions that have no return statement, 
or a return statement without an argument. <code>None</code> is the only
value of the type, <code>NoneType</code>.</dd>

<dt>incremental development:</dt>
<dd>A program development plan intended to avoid debugging by adding and
testing only a small amount of code at a time.</dd>

<dt>scaffolding:</dt>
<dd>Code that is used during program development but is not part of the final
version.</dd>

<dt>boolean function:</dt>
<dd>A function that returns a boolean value.</dd>

<dt>composition (of functions):</dt>
<dd>Calling one function from within the body of another, or using the
return value of one function as an argument to the call of another.</dd>

<dt>unit testing:</dt>
<dd>An automatic procedure used to validate that individual units of code
are working properly.  Python has <code>doctest</code> built in for this
purpose.</dd>
</dl>

<h2>Exercises</h2>
<p>
All of the exercises below should be added to a file named
<code>ch05.py</code> that contains the following at the bottom:
</p>
<pre class='python'>

if __name__ == '__main__':
    import doctest
    doctest.testmod()
</pre>
<p>
After completing each exercise in turn, run the program to confirm that
the doctests for your new function pass.
</p>

<ol>
<li><div class="exercise">
Write a <code>compare</code> function that returns <code>1</code> if
<code>a &gt; b</code>, <code>0</code> if <code>a == b</code>,
and <code>-1</code> if <code>a &lt; b</code>.
<pre class='python'>
def compare(a, b):
    """
      >>> compare(5, 4)
      1
      >>> compare(7, 7)
      0
      >>> compare(2, 3)
      -1
      >>> compare(42, 1)
      1
    """
</pre>
Fill in the body of the function so the doctests pass.
</div></li>

<li><div class="exercise">
Use incremental development to write a function called <code>hypotenuse</code>
that returns the length of the hypotenuse of a right triangle given the lengths 
of the two legs as parameters.  Record each stage of the incremental
development process as you go.
<pre class='python'>
def hypotenuse(a, b):
    """
      >>> hypotenuse(3, 4)
      5.0
      >>> hypotenuse(12, 5)
      13.0
      >>> hypotenuse(7, 24)
      25.0
      >>> hypotenuse(9, 12)
      15.0
    """
</pre>
When you are finished add your completed function with the doctests to
<code>ch05.py</code> and confirm that the doctests pass.
</div></li>

<li><div class="exercise">
Write a function <code>slope(x1, y1, x2, y2)</code> that returns the slope of
the line through the points (x1, y1) and (x2, y2).  Be sure your implimentation 
of <code>slope</code> can pass the following doctests:
<pre class='python'>
def slope(x1, y1, x2, y2):
    """
      >>> slope(5, 3, 4, 2)
      1.0
      >>> slope(1, 2, 3, 2)
      0.0
      >>> slope(1, 2, 3, 3)
      0.5
      >>> slope(2, 4, 1, 2)
      2.0
    """
</pre>
Then a call to <code>slope</code> in a new function named
<code>intercept(x1, y1, x2, y2)</code> that returns the y-intercept of the line 
through the points <code>(x1, y1)</code> and <code>(x2, y2)</code>.
<pre class='python'>
def intercept(x1, y1, x2, y2):
    """
      >>> intercept(1, 6, 3, 12)
      3.0
      >>> intercept(6, 1, 1, 6)
      7.0
      >>> intercept(4, 6, 12, 8)
      5.0
    """
</pre>
<code>intercept</code> should pass the doctests above. 
</div></li>

<li><div class="exercise">
Write a function called <code>is_even(n)</code> that takes an integer as an
argument and returns <code>True</code> if the argument is an <b>even number</b>
and <code>False</code> if it is <b>odd</b>.  Add your own doctests to this
function.
</div></li>

<li><div class="exercise">
Now write the function <code>is_odd(n)</code> that returns <code>True</code>
when <code>n</code> is odd and <code>False</code> otherwise. Include doctests
for this function as you write it.  Finally, modify it so that it uses a call
to <code>is_even</code> to determine if its argument is an odd integer.
</div></li>

<li><div class="exercise">
<pre class='python'>
def is_factor(f, n):
    """
      >>> is_factor(3, 12)
      True
      >>> is_factor(5, 12)
      False
      >>> is_factor(7, 14)
      True
      >>> is_factor(2, 14)
      True
      >>> is_factor(7, 15)
      False
    """
</pre>
Add a body to <code>is_factor</code> to make the doctests pass.
</div></li>

<li><div class="exercise">
<pre class='python'>
def is_multiple(m, n):
    """
      >>> is_multiple(12, 3)
      True
      >>> is_multiple(12, 4)
      True
      >>> is_multiple(12, 5)
      False
      >>> is_multiple(12, 6)
      True
      >>> is_multiple(12, 7)
      False
    """
</pre>
Add a body to <code>is_multiple</code> to make the doctests pass.  Can you
find a way to use <code>is_factor</code> in your definition of
<code>is_multiple</code>?
</div></li>

<li><div class="exercise">
<pre class='python'>
def f2c(t):
    """
      >>> f2c(212)
      100
      >>> f2c(32)
      0
      >>> f2c(-40)
      -40
      >>> f2c(36)
      2
      >>> f2c(37)
      3
      >>> f2c(38)
      3
      >>> f2c(39)
      4
    """
</pre>
Write a body for the function definition of <code>f2c</code> designed to return
the integer value of the nearest degree Celsius for given tempurature in
Fahrenheit. (<em>hint:</em> you may want to make use of the built-in function,
<code>round</code>.  Try printing <code>round.__doc__</code> in a Python shell
and experimenting with round until you are comfortable with how it works.)
</div></li>

<li><div class="exercise">
<pre class='python'>
def c2f(t):
    """
      >>> c2f(0)
      32
      >>> c2f(100)
      212
      >>> c2f(-40)
      -40
      >>> c2f(12)
      54
      >>> c2f(18)
      64
      >>> c2f(-48)
      -54
    """
</pre>
Add a function body for <code>c2f</code> to convert from Celsius to Fahrenheit.
</div></li>
</ol>

</body>
</html>
