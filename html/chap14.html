<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>How to Think Like a Computer Scientist: 14. Classes and methods</title><link href="stylesheet.css" type="text/css" rel="stylesheet" /></head><body bgcolor="white"><h1 class="title">14. Classes and methods</h1><div class="toc"><ol><li><a href="#auto0">Object-oriented features</a></li><li><a href="#auto1">print_time</a></li><li><a href="#auto2">Another example</a></li><li><a href="#auto3">A more complicated example</a></li><li><a href="#auto4">Optional arguments</a></li><li><a href="#auto5">The initialization method</a></li><li><a href="#auto6">Points revisited</a></li><li><a href="#auto7">Operator overloading</a></li><li><a href="#auto8">Polymorphism</a></li><li><a href="#auto9">Glossary</a></li><li><a href="#auto10">Exercises</a></li></ol></div><div class="content"><span></span><h2>14.1 Object-oriented features<a name="auto0"></a></h2><a name="index01"></a><a name="index02"></a><p>
Python is an <b>object-oriented programming language</b>, which
means that it provides features that support
<b>object-oriented programming</b>.
</p><p>
It is not easy to define object-oriented programming, but we have already
seen some of its characteristics:
</p><ol><li>Programs are made up of object definitions and function definitions, and
  most of the computation is expressed in terms of operations on objects.</li><li>Each object definition corresponds to some object or concept in the real
  world, and the functions that operate on that object correspond to the ways
  real-world objects interact.</li></ol><p>For example, the <code>Time</code> class defined in the last chapter
corresponds to the way people record the time of day, and the functions we
defined correspond to the kinds of things people do with times.  Similarly, the 
<code>Point</code> and <code>Rectangle</code> classes correspond to the
mathematical concepts of a point and a rectangle.
</p><p>So far, we have not taken advantage of the features Python provides to
support object-oriented programming.  Strictly speaking, these features are not 
necessary.  For the most part, they provide an alternative syntax for things we 
have already done, but in many cases, the alternative is more concise and more
accurately conveys the structure of the program.</p><p>For example, in the <code>Time</code> program, there is no obvious
connection between the class definition and the function definitions that
follow.  With some examination, it is apparent that every function takes at
least one <code>Time</code> object as a parameter.</p><p>This observation is the motivation for <b>methods</b>.  We have
already seen some methods, such as <code>keys</code> and <code>values</code>,
which were invoked on dictionaries.  Each method is associated with a class and 
is intended to be invoked on instances of that class.</p><a name="index03"></a><a name="index04"></a><a name="index05"></a><a name="index06"></a><p>Methods are just like functions, with two differences:</p><ol><li>Methods are defined inside a class definition in order to make the
relationship between the class and the method explicit.</li><li>The syntax for invoking a method is different fromp the syntax for calling
a function.</li></ol><p>In the next few sections, we will take the functions from the previous
two chapters and transform them into methods.  This transformation is purely
mechanical; you can do it simply by following a sequence of steps.  If you are
comfortable converting from one form to another, you will be able to choose the 
best form for whatever you are doing.</p><h2>14.2 <code>print_time</code><a name="auto1"></a></h2><a name="print_time"></a><a name="index07"></a><p>In the last chapter, we defined a class named <code>Time</code> and you
wrote a function named <code>print_time</code>, which should have looked
something like this:</p><pre class="python">
<span class="py-src-keyword">class</span> <span class="py-src-identifier">Time</span>:
    <span class="py-src-keyword">pass</span>
   
<span class="py-src-keyword">def</span> <span class="py-src-identifier">print_time</span>(<span class="py-src-parameter">time</span>):
    <span class="py-src-keyword">print</span> (<span class="py-src-variable">str</span>(<span class="py-src-variable">time</span>.<span class="py-src-variable">hours</span>) + <span class="py-src-string">&quot;:&quot;</span> +
           <span class="py-src-variable">str</span>(<span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span>) + <span class="py-src-string">&quot;:&quot;</span> +
           <span class="py-src-variable">str</span>(<span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span>))
</pre><p>To call this function, we passed a <code>Time</code> object as a parameter:
</p><pre class="python-interpreter">
&gt;&gt;&gt; current_time = Time()
&gt;&gt;&gt; current_time.hours = 9
&gt;&gt;&gt; current_time.minutes = 14
&gt;&gt;&gt; current_time.seconds = 30
&gt;&gt;&gt; print_time(current_time)
</pre><p>To make <code>print_time</code> a method, all we have to do is move the
function definition inside the class definition.  Notice the change in
indentation.</p><pre class="python">
<span class="py-src-keyword">class</span> <span class="py-src-identifier">Time</span>:
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">print_time</span>(<span class="py-src-parameter">time</span>):
        <span class="py-src-keyword">print</span> (<span class="py-src-variable">str</span>(<span class="py-src-variable">time</span>.<span class="py-src-variable">hours</span>) + <span class="py-src-string">&quot;:&quot;</span> +
               <span class="py-src-variable">str</span>(<span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span>) + <span class="py-src-string">&quot;:&quot;</span> +
               <span class="py-src-variable">str</span>(<span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span>))
</pre><p>Now we can invoke <code>print_time</code> using dot notation.</p><a name="index08"></a><pre class="python-interpreter">
&gt;&gt;&gt; current_time.print_time()
</pre><p>As usual, the object on which the method is invoked appears before the dot
and the name of the method appears after the dot.</p><p>The object on which the method is invoked is assigned to the first
parameter, so in this case <code>current_time</code> is assigned to the
parameter <code>time</code>.</p><p>By convention, the first parameter of a method is called <code>self</code>.  
The reason for this is a little convoluted, but it is based on a useful
metaphor.</p><p>The syntax for a function call, <code>print_time(current_time)</code>,
suggests that the function is the active agent.  It says something like,
<q>Hey <code>print_time</code>!  Here's an object for you to print.</q></p><p>In object-oriented programming, the objects are the active agents.  An
invocation like <code>current_time.print_time()</code> says
<q>Hey <code>current_time</code>!  Please print yourself!</q></p><p>This change in perspective might be more polite, but it is not obvious that
it is useful.  In the examples we have seen so far, it may not be.  But
sometimes shifting responsibility from the functions onto the objects makes it
possible to write more versatile functions, and makes it easier to maintain and 
reuse code.</p><h2>14.3 Another example<a name="auto2"></a></h2><p>Let's convert <code>increment</code> to a method.  To save space, we will
leave out previously defined methods, but you should keep them in your
version:</p><pre class="python">
<span class="py-src-keyword">class</span> <span class="py-src-identifier">Time</span>:
    <span class="py-src-comment">#previous method definitions here...
</span>   
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">increment</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">seconds</span>):
        <span class="py-src-variable">self</span>.<span class="py-src-variable">seconds</span> = <span class="py-src-variable">seconds</span> + <span class="py-src-variable">self</span>.<span class="py-src-variable">seconds</span>
   
        <span class="py-src-keyword">while</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">seconds</span> &gt;= <span class="py-src-number">60</span>:
            <span class="py-src-variable">self</span>.<span class="py-src-variable">seconds</span> = <span class="py-src-variable">self</span>.<span class="py-src-variable">seconds</span> - <span class="py-src-number">60</span>
            <span class="py-src-variable">self</span>.<span class="py-src-variable">minutes</span> = <span class="py-src-variable">self</span>.<span class="py-src-variable">minutes</span> + <span class="py-src-number">1</span>
   
        <span class="py-src-keyword">while</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">minutes</span> &gt;= <span class="py-src-number">60</span>:
            <span class="py-src-variable">self</span>.<span class="py-src-variable">minutes</span> = <span class="py-src-variable">self</span>.<span class="py-src-variable">minutes</span> - <span class="py-src-number">60</span>
            <span class="py-src-variable">self</span>.<span class="py-src-variable">hours</span> = <span class="py-src-variable">self</span>.<span class="py-src-variable">hours</span> + <span class="py-src-number">1</span>
</pre><p>The transformation is purely mechanical - we move the method definition into 
the class definition and change the name of the first parameter.</p><p>Now we can invoke <code>increment</code> as a method.</p><pre class="python">
<span class="py-src-variable">current_time</span>.<span class="py-src-variable">increment</span>(<span class="py-src-number">500</span>)
</pre><p>Again, the object on which the method is invoked gets assigned to the first
parameter, <code>self</code>.  The second parameter, <code>seconds</code> gets
the value <code>500</code>.</p><h2>14.4 A more complicated example<a name="auto3"></a></h2><p>The <code>after</code> function is slightly more complicated because it
operates on two <code>Time</code> objects, not just one.  We can only convert
one of the parameters to <code>self</code>; the other stays the same:</p><pre class="python">
<span class="py-src-keyword">class</span> <span class="py-src-identifier">Time</span>:
    <span class="py-src-comment">#previous method definitions here...
</span>   
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">after</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">time2</span>):
        <span class="py-src-keyword">if</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">hour</span> &gt; <span class="py-src-variable">time2</span>.<span class="py-src-variable">hour</span>:
            <span class="py-src-keyword">return</span> <span class="py-src-variable">True</span> 
        <span class="py-src-keyword">if</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">hour</span> &lt; <span class="py-src-variable">time2</span>.<span class="py-src-variable">hour</span>:
            <span class="py-src-keyword">return</span> <span class="py-src-variable">False</span> 
   
        <span class="py-src-keyword">if</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">minute</span> &gt; <span class="py-src-variable">time2</span>.<span class="py-src-variable">minute</span>:
            <span class="py-src-keyword">return</span> <span class="py-src-variable">True</span> 
        <span class="py-src-keyword">if</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">minute</span> &lt; <span class="py-src-variable">time2</span>.<span class="py-src-variable">minute</span>:
            <span class="py-src-keyword">return</span> <span class="py-src-variable">False</span> 
   
        <span class="py-src-keyword">if</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">second</span> &gt; <span class="py-src-variable">time2</span>.<span class="py-src-variable">second</span>:
            <span class="py-src-keyword">return</span> <span class="py-src-variable">True</span>
        <span class="py-src-keyword">return</span> <span class="py-src-variable">False</span>
</pre><p>We invoke this method on one object and pass the other as an argument:</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">doneTime</span>.<span class="py-src-variable">after</span>(<span class="py-src-variable">current_time</span>):
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;The bread will be done after it starts.&quot;</span>
</pre><p>You can almost read the invocation like English: <q>If the done-time is
after the current-time, then...</q></p><h2>14.5 Optional arguments<a name="auto4"></a></h2><p>We have seen built-in functions that take a variable number of arguments.
For example, <code>string.find</code> can take two, three, or four arguments.
</p><p>It is possible to write user-defined functions with optional argument lists. 
For example, we can upgrade our own version of <code>find</code> to do the same 
thing as <code>string.find</code>.</p><p>This is the original version:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">find</span>(<span class="py-src-parameter">str</span>, <span class="py-src-parameter">ch</span>):
    <span class="py-src-variable">index</span> = <span class="py-src-number">0</span>
    <span class="py-src-keyword">while</span> <span class="py-src-variable">index</span> &lt; <span class="py-src-variable">len</span>(<span class="py-src-variable">str</span>):
        <span class="py-src-keyword">if</span> <span class="py-src-variable">str</span>[<span class="py-src-variable">index</span>] == <span class="py-src-variable">ch</span>:
            <span class="py-src-keyword">return</span> <span class="py-src-variable">index</span>
        <span class="py-src-variable">index</span> = <span class="py-src-variable">index</span> + <span class="py-src-number">1</span>
    <span class="py-src-keyword">return</span> -<span class="py-src-number">1</span>
</pre><p>This is the new and improved version:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">find</span>(<span class="py-src-parameter">str</span>, <span class="py-src-parameter">ch</span>, <span class="py-src-parameter">start</span>=<span class="py-src-number">0</span>):
    <span class="py-src-variable">index</span> = <span class="py-src-variable">start</span>
    <span class="py-src-keyword">while</span> <span class="py-src-variable">index</span> &lt; <span class="py-src-variable">len</span>(<span class="py-src-variable">str</span>):
        <span class="py-src-keyword">if</span> <span class="py-src-variable">str</span>[<span class="py-src-variable">index</span>] == <span class="py-src-variable">ch</span>:
            <span class="py-src-keyword">return</span> <span class="py-src-variable">index</span>
        <span class="py-src-variable">index</span> = <span class="py-src-variable">index</span> + <span class="py-src-number">1</span>
    <span class="py-src-keyword">return</span> -<span class="py-src-number">1</span>
</pre><p>The third parameter, <code>start</code>, is optional because a default
value, <code>0</code>, is provided.  If we invoke <code>find</code> with
only two arguments, we use the default value and start from the beginning of
the string:</p><pre class="python-interpreter">
&gt;&gt;&gt; find(&quot;apple&quot;, &quot;p&quot;)
1
</pre><p>If we provide a third parameter, it <b>overrides</b> the default:
</p><pre class="python-interpreter">
&gt;&gt;&gt; find(&quot;apple&quot;, &quot;p&quot;, 2)
2
&gt;&gt;&gt; find(&quot;apple&quot;, &quot;p&quot;, 3)
-1
</pre><h2>14.6 The initialization method<a name="auto5"></a></h2><a name="index09"></a><a name="index10"></a><p>The <b>initialization method</b> is a special method that is
invoked when an object is created.  The name of this method is
<code>__init__</code> (two underscore characters, followed by
<code>init</code>, and then two more underscores).  An initialization method
for the <code>Time</code> class looks like this:</p><pre class="python">
<span class="py-src-keyword">class</span> <span class="py-src-identifier">Time</span>:
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">__init__</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">hours</span>=<span class="py-src-number">0</span>, <span class="py-src-parameter">minutes</span>=<span class="py-src-number">0</span>, <span class="py-src-parameter">seconds</span>=<span class="py-src-number">0</span>):
        <span class="py-src-variable">self</span>.<span class="py-src-variable">hours</span> = <span class="py-src-variable">hours</span>
        <span class="py-src-variable">self</span>.<span class="py-src-variable">minutes</span> = <span class="py-src-variable">minutes</span>
        <span class="py-src-variable">self</span>.<span class="py-src-variable">seconds</span> = <span class="py-src-variable">seconds</span>
</pre><p>There is no conflict between the attribute <code>self.hours</code> and the
parameter <code>hours</code>.  Dot notation specifies which variable we are
referring to.</p><a name="index11"></a><p>When we invoke the <code>Time</code> constructor, the arguments we provide
are passed along to <code>init</code>:</p><pre class="python-interpreter">
&gt;&gt;&gt; current_time = Time(9, 14, 30)
&gt;&gt;&gt; current_time.print_time()
&gt;&gt;&gt; 9:14:30
</pre><p>Because the parameters are optional, we can omit them:</p><pre class="python-interpreter">
&gt;&gt;&gt; current_time = Time()
&gt;&gt;&gt; current_time.print_time()
&gt;&gt;&gt; 0:0:0
</pre><p>Or provide only the first parameter:</p><pre class="python-interpreter">
&gt;&gt;&gt; current_time = Time (9)
&gt;&gt;&gt; current_time.print_time()
&gt;&gt;&gt; 9:0:0
</pre><p>Or the first two parameters:</p><pre class="python-interpreter">
&gt;&gt;&gt; current_time = Time (9, 14)
&gt;&gt;&gt; current_time.print_time()
&gt;&gt;&gt; 9:14:0
</pre><p>Finally, we can provide a subset of the parameters by naming them
explicitly:</p><pre class="python-interpreter">
&gt;&gt;&gt; current_time = Time(seconds = 30, hours = 9)
&gt;&gt;&gt; current_time.print_time()
&gt;&gt;&gt; 9:0:30
</pre><h2>14.7 Points revisited<a name="auto6"></a></h2><a name="index12"></a><a name="index13"></a><p>Let's rewrite the <code>Point</code> class from chapter 12 in a more
object-oriented style:</p><pre class="python">
<span class="py-src-keyword">class</span> <span class="py-src-identifier">Point</span>:
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">__init__</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">x</span>=<span class="py-src-number">0</span>, <span class="py-src-parameter">y</span>=<span class="py-src-number">0</span>):
        <span class="py-src-variable">self</span>.<span class="py-src-variable">x</span> = <span class="py-src-variable">x</span>
        <span class="py-src-variable">self</span>.<span class="py-src-variable">y</span> = <span class="py-src-variable">y</span>
   
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">__str__</span>(<span class="py-src-parameter">self</span>):
        <span class="py-src-keyword">return</span> <span class="py-src-string">'('</span> + <span class="py-src-variable">str</span>(<span class="py-src-variable">self</span>.<span class="py-src-variable">x</span>) + <span class="py-src-string">', '</span> + <span class="py-src-variable">str</span>(<span class="py-src-variable">self</span>.<span class="py-src-variable">y</span>) + <span class="py-src-string">')'</span>
</pre><p>The initialization method takes <code>x</code> and <code>y</code> values as
optional parameters; the default for either parameter is 0.</p><p>The next method, <code>__str__</code>, returns a string representation
of a <code>Point</code> object.  If a class provides a method named
<code>__str__</code>, it overrides the default behavior of the Python built-in
<code>str</code> function.</p><pre class="python-interpreter">
&gt;&gt;&gt; p = Point(3, 4)
&gt;&gt;&gt; str(p)
'(3, 4)'
</pre><p>Printing a <code>Point</code> object implicitly invokes <code>__str__</code> 
on the object, so defining <code>__str__</code> also changes the behavior of
<code>print</code>:</p><pre class="python-interpreter">
&gt;&gt;&gt; p = Point(3, 4)
&gt;&gt;&gt; print p
(3, 4)
</pre><p>When we write a new class, we almost always start by writing
<code>__init__</code>, which makes it easier to instantiate objects, and
<code>__str__</code>, which is almost always useful for debugging.</p><h2>14.8 Operator overloading<a name="auto7"></a></h2><a name="operator overloading"></a><a name="index14"></a><a name="index15"></a><a name="index16"></a><a name="index17"></a><p>Some languages make it possible to change the definition of the built-in
operators when they are applied to user-defined types.  This feature is called
<b>operator overloading</b>.  It is especially useful when defining
new mathematical types.</p><p>For example, to override the addition operator <code>+</code>, we provide a
method named <code>__add__</code>:</p><pre class="python">
<span class="py-src-keyword">class</span> <span class="py-src-identifier">Point</span>:
    <span class="py-src-comment"># previously defined methods here...
</span>   
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">__add__</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">other</span>):
        <span class="py-src-keyword">return</span> <span class="py-src-variable">Point</span>(<span class="py-src-variable">self</span>.<span class="py-src-variable">x</span> + <span class="py-src-variable">other</span>.<span class="py-src-variable">x</span>, <span class="py-src-variable">self</span>.<span class="py-src-variable">y</span> + <span class="py-src-variable">other</span>.<span class="py-src-variable">y</span>)
</pre><p>As usual, the first parameter is the object on which the method is invoked.  
The second parameter is conveniently named <code>other</code> to distinguish it 
from <code>self</code>.  To add two <code>Point</code>s, we create and return a 
new <code>Point</code> that contains  the sum of the <code>x</code> coordinates 
and the sum of the <code>y</code> coordinates.</p><p>Now, when we apply the <code>+</code> operator to <code>Point</code> objects,
Python invokes <code>__add__</code>:</p><pre class="python-interpreter">
&gt;&gt;&gt;  p1 = Point(3, 4)
&gt;&gt;&gt;  p2 = Point(5, 7)
&gt;&gt;&gt;  p3 = p1 + p2
&gt;&gt;&gt;  print p3
(8, 11)
</pre><p>The expression <code>p1 + p2</code> is equivalent to
<code>p1.__add__(p2)</code>, but obviously more elegant.</p><div class="exercise">
As an exercise, add a method <code>__sub__(self, other)</code> that overloads
the subtraction operator, and try it out.
</div><p>There are several ways to override the behavior of the multiplication
operator: by defining a method named <code>__mul__</code>, or
<code>__rmul__</code>, or both.</p><p>If the left operand of <code>*</code> is a <code>Point</code>, Python
invokes <code>__mul__</code>, which assumes that the other operand is also
a <code>Point</code>.  It computes the <b>dot product</b> of the two
points, defined according to the rules of linear algebra:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">__mul__</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">other</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">x</span> * <span class="py-src-variable">other</span>.<span class="py-src-variable">x</span> + <span class="py-src-variable">self</span>.<span class="py-src-variable">y</span> * <span class="py-src-variable">other</span>.<span class="py-src-variable">y</span>
</pre><p>If the left operand of <code>*</code> is a primitive type and the right
operand is a <code>Point</code>, Python invokes <code>__rmul__</code>, which
performs <b>scalar multiplication</b>:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">__rmul__</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">other</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">Point</span>(<span class="py-src-variable">other</span> * <span class="py-src-variable">self</span>.<span class="py-src-variable">x</span>,  <span class="py-src-variable">other</span> * <span class="py-src-variable">self</span>.<span class="py-src-variable">y</span>)
</pre><p>The result is a new <code>Point</code> whose coordinates are a multiple
of the original coordinates.  If <code>other</code> is a type that cannot be
multiplied by a floating-point number, then <code>__rmul__</code> will yield an 
error.</p><p>This example demonstrates both kinds of multiplication:</p><pre class="python-interpreter">
&gt;&gt;&gt; p1 = Point(3, 4)
&gt;&gt;&gt; p2 = Point(5, 7)
&gt;&gt;&gt; print p1 * p2
43
&gt;&gt;&gt; print 2 * p2
(10, 14)
</pre><p>What happens if we try to evaluate <code>p2 * 2</code>?  Since the first
parameter is a <code>Point</code>, Python invokes <code>__mul__</code> with
<code>2</code> as the second argument.  Inside <code>__mul__</code>, the
program tries to access the <code>x</code> coordinate of <code>other</code>,
which fails because an integer has no attributes:</p><pre class="python-interpreter">
&gt;&gt;&gt; print p2 * 2
AttributeError: 'int' object has no attribute 'x'
</pre><p>Unfortunately, the error message is a bit opaque.  This example demonstrates 
some of the difficulties of object-oriented programming.  Sometimes it is hard
enough just to figure out what code is running.</p><p>For a more complete example of operator overloading, see
Appendix (reference overloading).</p><h2>14.9 Polymorphism<a name="auto8"></a></h2><a name="index18"></a><p>Most of the methods we have written only work for a specific type.  When you 
create a new object, you write methods that operate on that type.</p><p>But there are certain operations that you will want to apply to many types,
such as the arithmetic operations in the previous sections.  If many types
support the same set of operations, you can write functions that work on any of 
those types.</p><p>For example, the <code>multadd</code> operation (which is common in linear
algebra) takes three parameters; it multiplies the first two and then adds the
third.  We can write it in Python like this:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">multadd</span> (<span class="py-src-parameter">x</span>, <span class="py-src-parameter">y</span>, <span class="py-src-parameter">z</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">x</span> * <span class="py-src-variable">y</span> + <span class="py-src-variable">z</span>
</pre><p>This method will work for any values of <code>x</code> and <code>y</code>
that can be multiplied and for any value of <code>z</code> that can be added to 
the product.</p><p>We can invoke it with numeric values:</p><pre class="python-interpreter">
&gt;&gt;&gt; multadd (3, 2, 1)
7
</pre><p>Or with <code>Point</code>s:</p><pre class="python-interpreter">
&gt;&gt;&gt; p1 = Point(3, 4)
&gt;&gt;&gt; p2 = Point(5, 7)
&gt;&gt;&gt; print multadd (2, p1, p2)
(11, 15)
&gt;&gt;&gt; print multadd (p1, p2, 1)
44
</pre><p>In the first case, the <code>Point</code> is multiplied by a scalar and then 
added to another <code>Point</code>.  In the second case, the dot product
yields a numeric value, so the third parameter also has to be a numeric value.
</p><p>A function like this that can take parameters with different types is called 
<b>polymorphic</b>.</p><p>As another example, consider the method <code>front_and_back</code>, which
prints a list twice, forward and backward:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">front_and_back</span>(<span class="py-src-parameter">front</span>):
    <span class="py-src-keyword">import</span> <span class="py-src-variable">copy</span>
    <span class="py-src-variable">back</span> = <span class="py-src-variable">copy</span>.<span class="py-src-variable">copy</span>(<span class="py-src-variable">front</span>)
    <span class="py-src-variable">back</span>.<span class="py-src-variable">reverse</span>()
    <span class="py-src-keyword">print</span> <span class="py-src-variable">str</span>(<span class="py-src-variable">front</span>) + <span class="py-src-variable">str</span>(<span class="py-src-variable">back</span>)
</pre><p>Because the <code>reverse</code> method is a modifier, we make a copy of the 
list before reversing it.  That way, this method doesn't modify the list it
gets as a parameter.</p><p>Here's an example that applies <code>front_and_back</code> to a list:</p><pre class="python-interpreter">
&gt;&gt;&gt;   myList = [1, 2, 3, 4]
&gt;&gt;&gt;   front_and_back(myList)
[1, 2, 3, 4][4, 3, 2, 1]
</pre><p>Of course, we intended to apply this function to lists, so it is not
surprising that it works.  What would be surprising is if we could apply it to
a <code>Point</code>.</p><p>To determine whether a function can be applied to a new type, we apply the
fundamental rule of polymorphism:</p><blockquote><em>If all of the operations inside the function can be applied to the
type, the function can be applied to the type.</em></blockquote><p>The operations in the method include <code>copy</code>,
<code>reverse</code>, and <code>print</code>.</p><p><code>copy</code> works on any object, and we have already written a
<code>__str__</code> method for <code>Point</code>s, so all we need is a
<code>reverse</code> method in the <code>Point</code> class:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">reverse</span>(<span class="py-src-parameter">self</span>):
    <span class="py-src-variable">self</span>.<span class="py-src-variable">x</span> , <span class="py-src-variable">self</span>.<span class="py-src-variable">y</span> = <span class="py-src-variable">self</span>.<span class="py-src-variable">y</span>, <span class="py-src-variable">self</span>.<span class="py-src-variable">x</span>
</pre><p>Then we can pass <code>Point</code>s to <code>front_and_back</code>:</p><pre class="python-interpreter">
&gt;&gt;&gt;   p = Point(3, 4)
&gt;&gt;&gt;   front_and_back(p)
(3, 4)(4, 3)
</pre><p>
The best kind of polymorphism is the unintentional kind, where you discover
that a function you have already written can be applied to a type for which you 
never planned.
</p><h2>14.10 Glossary<a name="auto9"></a></h2><a name="index19"></a><a name="index20"></a><a name="index21"></a><a name="index22"></a><a name="index23"></a><a name="index24"></a><a name="index25"></a><a name="index26"></a><a name="index27"></a><dl><dt>object-oriented language:</dt><dd>A language that provides features, such as user-defined classes and
inheritance, that facilitate object-oriented programming.</dd><dt>object-oriented programming:</dt><dd>A style of programming in which data and the operations that manipulate it
are organized into classes and methods.</dd><dt>method:</dt><dd>A function that is defined inside a class definition and is invoked on
instances of that class.</dd><dt>override:</dt><dd>To replace a default.  Examples include replacing a default parameter with
a particular argument and replacing a default method by providing a new method
with the same name.</dd><dt>initialization method:</dt><dd>A special method that is invoked automatically when a new object is created 
and that initializes the object's attributes.</dd><dt>operator overloading:</dt><dd>Extending built-in operators (<code>+</code>, <code>-</code>,
<code>*</code>, <code>&gt;</code>, <code>&lt;</code>, etc.) so that they work
with user-defined types.</dd><dt>dot product:</dt><dd>An operation defined in linear algebra that multiplies two
<code>Point</code>s and yields a numeric value.</dd><dt>scalar multiplication:</dt><dd>An operation defined in linear algebra that multiplies each of the
coordinates of a <code>Point</code> by a numeric value.</dd><dt>polymorphic:</dt><dd>A function that can operate on more than one type.  If all the operations
in a function can be applied to a type, then the function can be applied to a
type.</dd></dl><h2>14.11 Exercises<a name="auto10"></a></h2><ol><li><div class="exercise">
Convert the function<code>convertToSeconds</code>:
<pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">convertToSeconds</span>(<span class="py-src-parameter">t</span>):
    <span class="py-src-variable">minutes</span> = <span class="py-src-variable">t</span>.<span class="py-src-variable">hours</span> * <span class="py-src-number">60</span> + <span class="py-src-variable">t</span>.<span class="py-src-variable">minutes</span>
    <span class="py-src-variable">seconds</span> = <span class="py-src-variable">minutes</span> * <span class="py-src-number">60</span> + <span class="py-src-variable">t</span>.<span class="py-src-variable">seconds</span>
    <span class="py-src-keyword">return</span> <span class="py-src-variable">seconds</span>
</pre>
to a method in the <code>Time</code> class.
</div></li><li><div class="exercise">
Add a fourth parameter, <code>end</code>, to the <code>find</code> function
that specifies where to stop looking.
<br /><br />
Warning: This exercise is a bit tricky.  The default value of <code>end</code>
should be <code>len(str)</code>, but that doesn't work.  The default values are 
evaluated when the function is defined, not when it is called.  When
<code>find</code> is defined, <code>str</code> doesn't exist yet, so you can't
find its length.
</div></li><li><div class="exercise">&nbsp;</div></li></ol></div><p><a href="index.html">Table of Contents</a> |
    <a href="dex.html">Index</a></p></body></html>