<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>How to Think Like a Computer Scientist: 8. Lists</title><link href="stylesheet.css" type="text/css" rel="stylesheet" /></head><body bgcolor="white"><h1 class="title">8. Lists</h1><div class="toc"><ol><li><a href="#auto0">List values</a></li><li><a href="#auto1">Accessing elements</a></li><li><a href="#auto2">List length</a></li><li><a href="#auto3">List membership</a></li><li><a href="#auto4">Lists and for loops</a></li><li><a href="#auto5">List operations</a></li><li><a href="#auto6">List slices</a></li><li><a href="#auto7">Lists are mutable</a></li><li><a href="#auto8">List deletion</a></li><li><a href="#auto9">Converting strings to lists</a></li><li><a href="#auto10">Objects and values</a></li><li><a href="#auto11">Aliasing</a></li><li><a href="#auto12">Cloning lists</a></li><li><a href="#auto13">List parameters</a></li><li><a href="#auto14">Nested lists</a></li><li><a href="#auto15">Recursive list traversal</a></li><li><a href="#auto16">Matrixes</a></li><li><a href="#auto17">Strings and lists</a></li><li><a href="#auto18">The sys module and argv</a></li><li><a href="#auto19">Glossary</a></li><li><a href="#auto20">Exercises</a></li></ol></div><div class="content"><span></span><a name="index01"></a><a name="index02"></a><a name="index03"></a><a name="index04"></a><a name="index05"></a><p>A <b>list</b> is an ordered set of values, where each value is identified by 
an index.  The values that make up a list are called its <b>elements</b>.
Lists are similar to strings, which are ordered sets of characters, except that 
the elements of a list can have any type.  Lists and strings---and other things 
that behave like ordered sets---are called <b>sequences</b>.</p><h2>8.1 List values<a name="auto0"></a></h2><p>There are several ways to create a new list; the simplest is to
enclose the elements in square brackets (<code>[</code> and <code>]</code>):
</p><pre class="python">
[<span class="py-src-number">10</span>, <span class="py-src-number">20</span>, <span class="py-src-number">30</span>, <span class="py-src-number">40</span>]
[<span class="py-src-string">&quot;spam&quot;</span>, <span class="py-src-string">&quot;bungee&quot;</span>, <span class="py-src-string">&quot;swallow&quot;</span>]
</pre><p>The first example is a list of four integers.  The second is a list of three 
strings.  The elements of a list don't have to be the same type.  The following 
list contains a string, a float, an integer, and (mirabile dictu) another
list:</p><pre class="python">
[<span class="py-src-string">&quot;hello&quot;</span>, <span class="py-src-number">2.0</span>, <span class="py-src-number">5</span>, [<span class="py-src-number">10</span>, <span class="py-src-number">20</span>]]
</pre><p>A list within another list is said to be <b>nested</b>.</p><a name="index06"></a><p>Lists that contain consecutive integers are common, so Python provides a
simple way to create them:</p><pre class="python-interpreter">
&gt;&gt;&gt; range(1, 5)
[1, 2, 3, 4]
</pre><p>The <code>range</code> function takes two arguments and returns a list that
contains all the integers from the first to the second, including the first but 
not including the second!</p><p>There are two other forms of <code>range</code>.  With a single argument, it
creates a list that starts at 0:</p><pre class="python-interpreter">
&gt;&gt;&gt; range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre><p>If there is a third argument, it specifies the space between successive
values, which is called the <b>step size</b>.  This example counts
from 1 to 10 by steps of 2:</p><pre class="python-interpreter">
&gt;&gt;&gt; range(1, 10, 2)
[1, 3, 5, 7, 9]
</pre><p>Finally, there is a special list that contains no elements.  It is called
the empty list, and is denoted <code>[]</code>.</p><p>With all these ways to create lists, it would be disappointing if we
couldn't assign list values to variables or pass lists as parameters to
functions.  We can:</p><pre class="python">
<span class="py-src-variable">vocabulary</span> = [<span class="py-src-string">&quot;ameliorate&quot;</span>, <span class="py-src-string">&quot;castigate&quot;</span>, <span class="py-src-string">&quot;defenestrate&quot;</span>]
<span class="py-src-variable">numbers</span> = [<span class="py-src-number">17</span>, <span class="py-src-number">123</span>]
<span class="py-src-variable">empty</span> = []
<span class="py-src-keyword">print</span> <span class="py-src-variable">vocabulary</span>, <span class="py-src-variable">numbers</span>, <span class="py-src-variable">empty</span>
[<span class="py-src-string">'ameliorate'</span>, <span class="py-src-string">'castigate'</span>, <span class="py-src-string">'defenestrate'</span>] [<span class="py-src-number">17</span>, <span class="py-src-number">123</span>] []
</pre><h2>8.2 Accessing elements<a name="auto1"></a></h2><a name="index07"></a><a name="index08"></a><p>The syntax for accessing the elements of a list is the same as the syntax
for accessing the characters of a string---the bracket operator
(<code>[]</code> -- not to be confused with an empty list).  The expression
inside the brackets specifies the index.  Remember that the indices start at
0:</p><pre class="python">
<span class="py-src-keyword">print</span> <span class="py-src-variable">numbers</span>[<span class="py-src-number">0</span>]
<span class="py-src-variable">numbers</span>[<span class="py-src-number">1</span>] = <span class="py-src-number">5</span>
</pre><p>The bracket operator can appear anywhere in an expression.  When it appears
on the left side of an assignment, it changes one of the elements in the list,
so the one-eth element of <code>numbers</code>, which used to be 123, is now 5.
</p><p>Any integer expression can be used as an index:</p><pre class="python-interpreter">
&gt;&gt;&gt; numbers[9-8]
5
&gt;&gt;&gt; numbers[1.0]
TypeError: list indices must be integers
</pre><p>If you try to read or write an element that does not exist, you get a
runtime error:</p><a name="index09"></a><pre class="python-interpreter">
&gt;&gt;&gt; numbers[2] = 5
IndexError: list assignment index out of range
</pre><p>If an index has a negative value, it counts backward from the end of the
list:</p><pre class="python-interpreter">
&gt;&gt;&gt; numbers[-1]
5
&gt;&gt;&gt; numbers[-2]
17
&gt;&gt;&gt; numbers[-3]
IndexError: list index out of range
</pre><p><code>numbers[-1]</code> is the last element of the list,
<code>numbers[-2]</code> is the second to last, and <code>numbers[-3]</code>
doesn't exist.</p><p>It is common to use a loop variable as a list index.</p><pre class="python">
<span class="py-src-variable">horsemen</span> = [<span class="py-src-string">&quot;war&quot;</span>, <span class="py-src-string">&quot;famine&quot;</span>, <span class="py-src-string">&quot;pestilence&quot;</span>, <span class="py-src-string">&quot;death&quot;</span>]
   
<span class="py-src-variable">i</span> = <span class="py-src-number">0</span>
<span class="py-src-keyword">while</span> <span class="py-src-variable">i</span> &lt; <span class="py-src-number">4</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">horsemen</span>[<span class="py-src-variable">i</span>]
    <span class="py-src-variable">i</span> = <span class="py-src-variable">i</span> + <span class="py-src-number">1</span>
</pre><p>This <code>while</code> loop counts from 0 to 4.  When the loop variable
<code>i</code> is 4, the condition fails and the loop terminates.  So the
body of the loop is only executed when <code>i</code> is 0, 1, 2, and 3.</p><p>Each time through the loop, the variable <code>i</code> is used as an index
into the list, printing the <code>i</code>-eth element.  This pattern of
computation is called a <b>list traversal</b>.</p><a name="index10"></a><a name="index11"></a><h2>8.3 List length<a name="auto2"></a></h2><a name="index12"></a><a name="index13"></a><p>The function <code>len</code> returns the length of a list.  It is a good
idea to use this value as the upper bound of a loop instead of a constant.
That way, if the size of the list changes, you won't have to go through the
program changing all the loops; they will work correctly for any size list:</p><pre class="python">
<span class="py-src-variable">horsemen</span> = [<span class="py-src-string">&quot;war&quot;</span>, <span class="py-src-string">&quot;famine&quot;</span>, <span class="py-src-string">&quot;pestilence&quot;</span>, <span class="py-src-string">&quot;death&quot;</span>]
   
<span class="py-src-variable">i</span> = <span class="py-src-number">0</span>
<span class="py-src-keyword">while</span> <span class="py-src-variable">i</span> &lt; <span class="py-src-variable">len</span>(<span class="py-src-variable">horsemen</span>):
    <span class="py-src-keyword">print</span> <span class="py-src-variable">horsemen</span>[<span class="py-src-variable">i</span>]
    <span class="py-src-variable">i</span> = <span class="py-src-variable">i</span> + <span class="py-src-number">1</span>
</pre><p>The last time the body of the loop is executed, <code>i</code> is
<code>len(horsemen) - 1</code>, which is the index of the last element.  When
<code>i</code> is equal to <code>len(horsemen)</code>, the condition fails and
the body is not executed, which is a good thing, because
<code>len(horsemen)</code> is not a legal index.</p><p>Although a list can contain another list, the nested list still counts as a
single element.  The length of this list is 4:</p><pre class="python">
[<span class="py-src-string">'spam!'</span>, <span class="py-src-number">1</span>, [<span class="py-src-string">'Brie'</span>, <span class="py-src-string">'Roquefort'</span>, <span class="py-src-string">'Pol le Veq'</span>], [<span class="py-src-number">1</span>, <span class="py-src-number">2</span>, <span class="py-src-number">3</span>]]
</pre><h2>8.4 List membership<a name="auto3"></a></h2><a name="index14"></a><a name="index15"></a><a name="index16"></a><p><code>in</code> is a boolean operator that tests membership in a sequence.
We used it previously with strings, but it also works with lists and other
sequences:</p><pre class="python-interpreter">
&gt;&gt;&gt; horsemen = ['war', 'famine', 'pestilence', 'death']
&gt;&gt;&gt; 'pestilence' in horsemen
True
&gt;&gt;&gt; 'debauchery' in horsemen
False
</pre><p>Since <q>pestilence</q> is a member of the <code>horsemen</code> list, the
<code>in</code> operator returns <code>True</code>.  Since <q>debauchery</q> is 
not in the list, <code>in</code> returns <code>False</code>.</p><p>We can use the <code>not</code> in combination with <code>in</code> to test
whether an element is not a member of a list:</p><pre class="python">
&gt;&gt;&gt; <span class="py-src-string">'debauchery'</span> <span class="py-src-keyword">not</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">horsemen</span>
<span class="py-src-variable">True</span>
</pre><h2>8.5 Lists and <code>for</code> loops<a name="auto4"></a></h2><a name="index17"></a><a name="index18"></a><a name="index19"></a><p>The <code>for</code> loop also works with lists.  The generalized syntax of
a <code>for</code> loop is:</p><pre>
for VARIABLE in LIST:
    BODY
</pre><p>This statement is equivalent to:</p><pre class="python">
<span class="py-src-variable">i</span> = <span class="py-src-number">0</span>
<span class="py-src-keyword">while</span> <span class="py-src-variable">i</span> &lt; <span class="py-src-variable">len</span>(<span class="py-src-variable">LIST</span>):
    <span class="py-src-variable">VARIABLE</span> = <span class="py-src-variable">LIST</span>[<span class="py-src-variable">i</span>]
    <span class="py-src-variable">BODY</span>
    <span class="py-src-variable">i</span> = <span class="py-src-variable">i</span> + <span class="py-src-number">1</span>
</pre><p>The <code>for</code> loop is more concise because we can eliminate the loop
variable, <code>i</code>.  Here is the previous loop written with a
<code>for</code> loop.</p><pre class="python">
<span class="py-src-keyword">for</span> <span class="py-src-variable">horseman</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">horsemen</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">horseman</span>
</pre><p>It almost reads like English: <q>For (every) horseman in (the list of)
horsemen, print (the name of the) horseman.</q></p><p>Any list expression can be used in a <code>for</code> loop:</p><pre class="python">
<span class="py-src-keyword">for</span> <span class="py-src-variable">number</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">range</span>(<span class="py-src-number">20</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">number</span> % <span class="py-src-number">2</span> == <span class="py-src-number">0</span>:
        <span class="py-src-keyword">print</span>  <span class="py-src-variable">number</span>
   
<span class="py-src-keyword">for</span> <span class="py-src-variable">fruit</span> <span class="py-src-keyword">in</span> [<span class="py-src-string">&quot;banana&quot;</span>, <span class="py-src-string">&quot;apple&quot;</span>, <span class="py-src-string">&quot;quince&quot;</span>]:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;I like to eat &quot;</span> + <span class="py-src-variable">fruit</span> + <span class="py-src-string">&quot;s!&quot;</span>
</pre><p>The first example prints all the even numbers between one and nineteen.
The second example expresses enthusiasm for various fruits.</p><h2>8.6 List operations<a name="auto5"></a></h2><a name="index20"></a><a name="index21"></a><p>The <code>+</code> operator concatenates lists:</p><a name="index22"></a><pre class="python-interpreter">
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [4, 5, 6]
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; print c
[1, 2, 3, 4, 5, 6]
</pre><p>Similarly, the <code>*</code> operator repeats a list a given number of
times:</p><a name="index23"></a><pre class="python-interpreter">
&gt;&gt;&gt; [0] * 4
[0, 0, 0, 0]
&gt;&gt;&gt; [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
</pre><p>The first example repeats <code>[0]</code> four times.  The second example
repeats the list <code>[1, 2, 3]</code> three times.</p><h2>8.7 List slices<a name="auto6"></a></h2><a name="index24"></a><a name="index25"></a><p>The slice operations we saw with strings also work on lists:</p><pre class="python-interpreter">
&gt;&gt;&gt; a_list = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; a_list[1:3]
['b', 'c']
&gt;&gt;&gt; a_list[:4]
['a', 'b', 'c', 'd']
&gt;&gt;&gt; a_list[3:]
['d', 'e', 'f']
&gt;&gt;&gt; a_list[:]
['a', 'b', 'c', 'd', 'e', 'f']
</pre><h2>8.8 Lists are mutable<a name="auto7"></a></h2><a name="index26"></a><a name="index27"></a><a name="index28"></a><p>Unlike strings, lists are <b>mutable</b>, which means we can change their
elements.  Using the bracket operator on the left side of an assignment, we can update one of the elements:</p><pre class="python-interpreter">
&gt;&gt;&gt; fruit = [&quot;banana&quot;, &quot;apple&quot;, &quot;quince&quot;]
&gt;&gt;&gt; fruit[0] = &quot;pear&quot;
&gt;&gt;&gt; fruit[-1] = &quot;orange&quot;
&gt;&gt;&gt; print fruit
['pear', 'apple', 'orange']
</pre><p>With the slice operator we can update several elements at once:</p><pre class="python-interpreter">
&gt;&gt;&gt; a_list = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; a_list[1:3] = ['x', 'y']
&gt;&gt;&gt; print a_list
['a', 'x', 'y', 'd', 'e', 'f']
</pre><p>We can also remove elements from a list by assigning the empty list to
them:</p><pre class="python-interpreter">
&gt;&gt;&gt; a_list = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; a_list[1:3] = []
&gt;&gt;&gt; print a_list
['a', 'd', 'e', 'f']
</pre><p>And we can add elements to a list by squeezing them into an empty slice at
the desired location:</p><pre class="python-interpreter">
&gt;&gt;&gt; a_list = ['a', 'd', 'f']
&gt;&gt;&gt; a_list[1:1] = ['b', 'c']
&gt;&gt;&gt; print a_list
['a', 'b', 'c', 'd', 'f']
&gt;&gt;&gt; a_list[4:4] = ['e']
&gt;&gt;&gt; print a_list
['a', 'b', 'c', 'd', 'e', 'f']
</pre><h2>8.9 List deletion<a name="auto8"></a></h2><a name="index29"></a><a name="index30"></a><p>Using slices to delete list elements can be awkward, and therefore
error-prone.  Python provides an alternative that is more readable.</p><p><code>del</code> removes an element from a list:</p><pre class="python-interpreter">
&gt;&gt;&gt; a = ['one', 'two', 'three']
&gt;&gt;&gt; del a[1]
&gt;&gt;&gt; a
['one', 'three']
</pre><p>As you might expect, <code>del</code> handles negative indices and causes a
runtime error if the index is out of range.</p><p>You can use a slice as an index for <code>del</code>:</p><pre class="python-interpreter">
&gt;&gt;&gt; a_list = ['a', 'b', 'c', 'd', 'e', 'f']
&gt;&gt;&gt; del a_list[1:5]
&gt;&gt;&gt; print a_list
['a', 'f']
</pre><p>As usual, slices select all the elements up to, but not including, the
second index.</p><h2>8.10 Converting strings to lists<a name="auto9"></a></h2><a name="index31"></a><p>Python has a function called <code>list</code> that takes a sequence
type as an argument and creates a list out of its elements.
</p><pre class="python-interpreter">
&gt;&gt;&gt; list(&quot;Crunchy Frog&quot;)
['C', 'r', 'u', 'n', 'c', 'h', 'y', ' ', 'F', 'r', 'o', 'g']
</pre><p>There is also a <code>str</code> function that takes any Python value as an
argument and returns a string representation of it.
</p><pre class="python-interpreter">
&gt;&gt;&gt; str(5)
'5'
&gt;&gt;&gt; str(None)
'None'
&gt;&gt;&gt; str(list(&quot;nope&quot;))
&quot;['n', 'o', 'p', 'e']&quot;
</pre><p>As we can see from the last example, <code>str</code> can't be used to join
a list of characters together.  To do this we could use the <code>join</code>
function in the <code>string</code> module:
</p><pre class="python-interpreter">
&gt;&gt;&gt; import string
&gt;&gt;&gt; char_list = list(&quot;Frog&quot;)
&gt;&gt;&gt; char_list
['F', 'r', 'o', 'g']
&gt;&gt;&gt; string.join(char_list, '')
'Frog'
</pre><h2>8.11 Objects and values<a name="auto10"></a></h2><a name="index32"></a><a name="index33"></a><p>If we execute these assignment statements,</p><pre class="python">
<span class="py-src-variable">a</span> = <span class="py-src-string">&quot;banana&quot;</span>
<span class="py-src-variable">b</span> = <span class="py-src-string">&quot;banana&quot;</span>
</pre><p>we know that <code>a</code> and <code>b</code> will refer to a string with
the letters <code>&quot;banana&quot;</code>.  But we can't tell whether they point to the 
<em>same</em> string.</p><p>There are two possible states:</p><img src="illustrations/list1.png" /><p>In one case, <code>a</code> and <code>b</code> refer to two different things
that have the same value.  In the second case, they refer to the same thing.
These <q>things</q> have names---they are called <b>objects</b>.
An object is something a variable can refer to.</p><p>Every object has a unique <b>identifier</b>, which we can obtain
with the <code>id</code> function.  By printing the identifier of <code>a</code>
and <code>b</code>, we can tell whether they refer to the same object.</p><pre class="python-interpreter">
&gt;&gt;&gt; id(a)
135044008
&gt;&gt;&gt; id(b)
135044008
</pre><p>In fact, we get the same identifier twice, which means that Python only
created one string, and both <code>a</code> and <code>b</code> refer to it.</p><p>Interestingly, lists behave differently.  When we create two lists, we get
two objects:</p><pre class="python-interpreter">
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = [1, 2, 3]
&gt;&gt;&gt; id(a)
135045528
&gt;&gt;&gt; id(b)
135041704
</pre><p>So the state diagram looks like this:</p><img src="illustrations/list2.png" /><p><code>a</code> and <code>b</code> have the same value but do not refer to
the same object.</p><h2>8.12 Aliasing<a name="auto11"></a></h2><a name="index34"></a><a name="index35"></a><p>Since variables refer to objects, if we assign one variable to another, both 
variables refer to the same object:</p><pre class="python-interpreter">
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a
</pre><p>In this case, the state diagram looks like this:</p><img src="illustrations/list3.png" /><p>Because the same list has two different names, <code>a</code> and
<code>b</code>, we say that it is <b>aliased</b>.  Changes made with
one alias affect the other:</p><pre class="python-interpreter">
&gt;&gt;&gt; b[0] = 5
&gt;&gt;&gt; print a
[5, 2, 3]
</pre><p>Although this behavior can be useful, it is sometimes unexpected or
undesirable.  In general, it is safer to avoid aliasing when you are working
with mutable objects.  Of course, for immutable objects, there's no problem.
That's why Python is free to alias strings when it sees an opportunity to
economize.</p><h2>8.13 Cloning lists<a name="auto12"></a></h2><a name="index36"></a><a name="index37"></a><p>If we want to modify a list and also keep a copy of the original, we need to 
be able to make a copy of the list itself, not just the reference.  This
process is sometimes called <b>cloning</b>, to avoid the ambiguity of 
the word <q>copy.</q></p><p>The easiest way to clone a list is to use the slice operator:</p><pre class="python-interpreter">
&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a[:]
&gt;&gt;&gt; print b
[1, 2, 3]
</pre><p>Taking any slice of <code>a</code> creates a new list.  In this case the
slice happens to consist of the whole list.</p><p>Now we are free to make changes to <code>b</code> without worrying about
<code>a</code>:</p><pre class="python-interpreter">
&gt;&gt;&gt; b[0] = 5
&gt;&gt;&gt; print a
[1, 2, 3]
</pre><h2>8.14 List parameters<a name="auto13"></a></h2><a name="index38"></a><a name="index39"></a><a name="index40"></a><p>Passing a list as an argument actually passes a reference to the list, not a 
copy of the list.  For example, the function <code>head</code> takes a list as
an argument and returns the first element:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">head</span>(<span class="py-src-parameter">a_list</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">a_list</span>[<span class="py-src-number">0</span>]
</pre><p>Here's how it is used:</p><pre class="python-interpreter">
&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; head(numbers)
1
</pre><p>The parameter <code>l</code> and the variable <code>numbers</code> are
aliases for the same object.  The state diagram looks like this:</p><img src="illustrations/stack5.png" /><p>Since the list object is shared by two frames, we drew it between them.</p><p>If a function modifies a list parameter, the caller sees the change.  For
example, <code>delete_head</code> removes the first element from a list:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">delete_head</span>(<span class="py-src-parameter">a_list</span>):
    <span class="py-src-keyword">del</span> <span class="py-src-variable">a_list</span>[<span class="py-src-number">0</span>]
</pre><p>Here's how <code>delete_head</code> is used:</p><pre class="python-interpreter">
&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; delete_head(numbers)
&gt;&gt;&gt; print numbers
[2, 3]
</pre><p>If a function returns a list, it returns a reference to the list.  For
example, <code>tail</code> returns a list that contains all but the first
element of the given list:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">tail</span>(<span class="py-src-parameter">a_list</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">a_list</span>[<span class="py-src-number">1</span>:]
</pre><p>Here's how <code>tail</code> is used:</p><pre class="python-interpreter">
&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; rest = tail(numbers)
&gt;&gt;&gt; print rest
[2, 3]
</pre><p>Because the return value was created with the slice operator, it is a new
list.  Creating <code>rest</code>, and any subsequent changes to
<code>rest</code>, have no effect on <code>numbers</code>.</p><h2>8.15 Nested lists<a name="auto14"></a></h2><a name="nested lists"></a><a name="index41"></a><a name="index42"></a><p>A nested list is a list that appears as an element in another list.  In this 
list, the three-eth is a nested list:</p><pre class="python-interpreter">
&gt;&gt;&gt; nested = [&quot;hello&quot;, 2.0, 5, [10, 20]]
</pre><p>If we print <code>nested[3]</code>, we get <code>[10, 20]</code>.  To extract
an element from the nested list, we can proceed in two steps:</p><pre class="python-interpreter">
&gt;&gt;&gt; elem = nested[3]
&gt;&gt;&gt; elem[0]
10
</pre><p>Or we can combine them:</p><pre class="python-interpreter">
&gt;&gt;&gt; nested[3][1]
20
</pre><p>Bracket operators evaluate from left to right, so this expression gets the
three-eth element of <code>nested</code> and extracts the one-eth element from
it.</p><h2>8.16 Recursive list traversal<a name="auto15"></a></h2><a name="index43"></a><a name="index44"></a><p>Python has a built-in function which finds the sum of a sequence of numbers:
</p><pre class="python-interpreter">
&gt;&gt;&gt; sum([1, 2, 8])
11
</pre><p>Suppose we have what we'll call a <em>nested number list</em>, a list whose
elements are either numbers or nested number lists themselves. If we want to
sum all the numbers in such a list, no matter how deeply nested, the built-in
<code>sum</code> function will not work for us:</p><pre class="python-interpreter">
&gt;&gt;&gt; nested_number_list = [1, 2, [3, 4, [5, 6], 7], 8, [1, [1, [1, 2], 2], 8], 5]
&gt;&gt;&gt; sum(nested_number_list)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: unsupported operand type(s) for +: 'int' and 'list'
</pre><p>To solve this problem, we first notice that our nested number list has a
<b>recursive definition</b>---it is defined in terms of itself.  To sum all the 
numbers in our list we need to traverse it, visiting each of the elements
within its nested structure, adding any numeric elements to our sum, and
<em>repeating this process</em> with any elements which are lists.  Thanks to
recursion, the Python code needed to do this is surprisingly short:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">recursive_sum</span>(<span class="py-src-parameter">nested_list</span>):
    <span class="py-src-variable">sum</span> = <span class="py-src-number">0</span>
    <span class="py-src-keyword">for</span> <span class="py-src-variable">element</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">nested_list</span>:
        <span class="py-src-keyword">if</span> <span class="py-src-variable">type</span>(<span class="py-src-variable">element</span>) == <span class="py-src-variable">type</span>([]):
            <span class="py-src-variable">sum</span> = <span class="py-src-variable">sum</span> + <span class="py-src-variable">recursive_sum</span>(<span class="py-src-variable">element</span>)
        <span class="py-src-keyword">else</span>:
            <span class="py-src-variable">sum</span> = <span class="py-src-variable">sum</span> + <span class="py-src-variable">element</span>
    <span class="py-src-keyword">return</span> <span class="py-src-variable">sum</span>
</pre><p>Recursion is truly one of the most beautiful things in computer science.</p><h2>8.17 Matrixes<a name="auto16"></a></h2><a name="index45"></a><a name="index46"></a><p>Nested lists are often used to represent matrices.  For example, the
matrix:</p><img src="illustrations/matrix.png" /><p>might be represented as:</p><pre class="python-interpreter">
&gt;&gt;&gt; matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</pre><p><code>matrix</code> is a list with three elements, where each element is a
row of the matrix.  We can select an entire row from the matrix in the usual
way:</p><pre class="python-interpreter">
&gt;&gt;&gt; matrix[1]
[4, 5, 6]
</pre><p>Or we can extract a single element from the matrix using the double-index
form:</p><pre class="python-interpreter">
&gt;&gt;&gt; matrix[1][1]
5
</pre><p>The first index selects the row, and the second index selects the column.
Although this way of representing matrices is common, it is not the only
possibility.  A small variation is to use a list of columns instead of a list
of rows.  Later we will see a more radical alternative using a dictionary.</p><a name="index47"></a><a name="index48"></a><a name="index49"></a><h2>8.18 Strings and lists<a name="auto17"></a></h2><a name="index50"></a><a name="index51"></a><p>Two of the most useful functions in the <code>string</code> module involve
lists of strings.  The <code>split</code> function breaks a string into a list
of words.  By default, any number of whitespace characters is considered a word 
boundary:</p><pre class="python-interpreter">
&gt;&gt;&gt; import string
&gt;&gt;&gt; song = &quot;The rain in Spain...&quot;
&gt;&gt;&gt; string.split(song)
['The', 'rain', 'in', 'Spain...']
</pre><p>An optional argument called a <b>delimiter</b> can be used to
specify which characters to use as word boundaries.  The following example uses 
the string <code>ai</code> as the delimiter:</p><pre class="python-interpreter">
&gt;&gt;&gt; string.split(song, 'ai')
['The r', 'n in Sp', 'n...']
</pre><p>Notice that the delimiter doesn't appear in the list.</p><p>The <code>join</code> function is the inverse of <code>split</code>.  It
takes a list of strings and concatenates the elements with a space between each 
pair:</p><pre class="python-interpreter">
&gt;&gt;&gt; a_list = ['The', 'rain', 'in', 'Spain...']
&gt;&gt;&gt; string.join(a_list)
'The rain in Spain...'
</pre><p>Like <code>split</code>, <code>join</code> takes an optional delimiter that
is inserted between elements.  The default delimiter is white space.</p><pre class="python-interpreter">
&gt;&gt;&gt; string.join(a_list, '_')
'The_rain_in_Spain...'
</pre><h2>8.19 The <code>sys</code> module and <code>argv</code><a name="auto18"></a></h2><a name="index52"></a><a name="index53"></a><a name="index54"></a><a name="index55"></a><p>The <code>sys</code> module contains a variable named <code>argv</code>,
which holds a list of strings read in from the <b>command line</b> when
a Python script is run.  These <b>command line arguments</b> can be used to
pass information into a program at the same time it is invoked.</p><pre class="python">
<span class="py-src-comment">#
</span><span class="py-src-comment"># demo_argv.py
</span><span class="py-src-comment">#
</span><span class="py-src-keyword">import</span> <span class="py-src-variable">sys</span>

<span class="py-src-keyword">print</span> <span class="py-src-string">&quot;And the command-line arguments are:&quot;</span>
<span class="py-src-keyword">for</span> <span class="py-src-variable">i</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">range</span>(<span class="py-src-variable">len</span>(<span class="py-src-variable">sys</span>.<span class="py-src-variable">argv</span>)):
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;\targument number&quot;</span>, <span class="py-src-variable">i</span>, <span class="py-src-string">&quot;is&quot;</span>, <span class="py-src-variable">sys</span>.<span class="py-src-variable">argv</span>[<span class="py-src-variable">i</span>]
</pre><p>Running this program from the unix command prompt demonstrates how
<code>sys.argv</code> works:</p><pre class="shell">
$ python demo_argv.py this and that 1 2 3
And the command-line arguments are:
        argument number 0 is demo_argv.py
        argument number 1 is this
        argument number 2 is and
        argument number 3 is that
        argument number 4 is 1
        argument number 5 is 2
        argument number 6 is 3
$ 
</pre><p>Arguments are seperated by white space.  If you want an argument with white
space in it, use quotes:</p><pre class="shell">
$ python demo_argv.py &quot;this and&quot; that &quot;1 2&quot; 3
And the command-line arguments are:
        argument number 0 is demo_argv.py
        argument number 1 is this and
        argument number 2 is that
        argument number 3 is 1 2
        argument number 4 is 3
$ 
</pre><h2>8.20 Glossary<a name="auto19"></a></h2><a name="index56"></a><a name="index57"></a><a name="index58"></a><a name="index59"></a><a name="index60"></a><a name="index61"></a><a name="index62"></a><a name="index63"></a><a name="index64"></a><a name="index65"></a><a name="index66"></a><a name="index67"></a><dl><dt>list:</dt><dd>A named collection of objects, where each object is identified by an index.
</dd><dt>index:</dt><dd>An integer variable or value that indicates an element of a list.</dd><dt>element:</dt><dd>One of the values in a list (or other sequence).  The bracket operator
selects elements of a list.</dd><dt>sequence:</dt><dd>Any of the data types that consist of an ordered set of elements, with each 
element identified by an index.</dd><dt>nested list:</dt><dd>A list that is an element of another list.</dd><dt>list traversal:</dt><dd>The sequential accessing of each element in a list.</dd><dt>mutable type:</dt><dd>A data type in which the elements can be modified.  All mutable types are
compound types.  Lists are mutable data types; strings are not.</dd><dt>object:</dt><dd>A thing to which a variable can refer.</dd><dt>aliases:</dt><dd>Multiple variables that contain references to the same object.</dd><dt>clone:</dt><dd>To create a new object that has the same value as an existing object.
Copying a reference to an object creates an alias but doesn't clone the object.
</dd><dt>recursive definition:</dt><dd>A definition which defines something in terms of itself. To be useful it
must include <em>base cases</em> which are not recursive.  In this way it
differs from a <em>circular definition</em>.  Recursive definitions often
provide an elegant way to express complex data structures.</dd><dt>delimiter:</dt><dd>A character or string used to indicate where a string should be split.</dd></dl><h2>8.21 Exercises<a name="auto20"></a></h2><ol><li><div class="exercise">
Write a loop that traverses:
<pre class="python">
[<span class="py-src-string">'spam!'</span>, <span class="py-src-number">1</span>, [<span class="py-src-string">'Brie'</span>, <span class="py-src-string">'Roquefort'</span>, <span class="py-src-string">'Pol le Veq'</span>], [<span class="py-src-number">1</span>, <span class="py-src-number">2</span>, <span class="py-src-number">3</span>]]
</pre>
and prints the length of each element.  What happens if you send an integer
to <code>len</code>?
</div></li><li><div class="exercise"><pre class="python">
<span class="py-src-variable">a</span> = [<span class="py-src-number">1</span>, <span class="py-src-number">2</span>, <span class="py-src-number">3</span>]
<span class="py-src-variable">b</span> = <span class="py-src-variable">a</span>[:]
<span class="py-src-variable">b</span>[<span class="py-src-number">0</span>] = <span class="py-src-number">5</span>
</pre>
Draw a state diagram for <code>a</code> and <code>b</code> before and after
the third line is executed.
</div></li><li><div class="exercise"><pre class="python">
<span class="py-src-keyword">import</span> <span class="py-src-variable">string</span>

<span class="py-src-variable">song</span> = <span class="py-src-string">&quot;The rain in Spain...&quot;</span>
</pre>
Describe the relationship between <code>string.join(string.split(song))</code>
and <code>song</code>.  Are they the same for all strings?  When would they be
different?
</div></li></ol></div><p><a href="index.html">Table of Contents</a> |
    <a href="dex.html">Index</a></p></body></html>