<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>How to Think Like a Computer Scientist: 13. Classes and functions</title><link href="stylesheet.css" type="text/css" rel="stylesheet" /></head><body bgcolor="white"><h1 class="title">13. Classes and functions</h1><div class="toc"><ol><li><a href="#auto0">Time</a></li><li><a href="#auto1">Pure functions</a></li><li><a href="#auto2">Modifiers</a></li><li><a href="#auto3">Prototype development versus planning</a></li><li><a href="#auto4">Generalization</a></li><li><a href="#auto5">Algorithms</a></li><li><a href="#auto6">Glossary</a></li><li><a href="#auto7">Exercises</a></li></ol></div><div class="content"><span></span><a name="time"></a><a name="index01"></a><a name="index02"></a><h2>13.1 Time<a name="auto0"></a></h2><p>As another example of a user-defined type, we'll define a class called
<code>Time</code> that records the time of day.  The class definition looks
like this:</p><pre class="python">
<span class="py-src-keyword">class</span> <span class="py-src-identifier">Time</span>:
    <span class="py-src-keyword">pass</span>
</pre><p>We can create a new <code>Time</code> object and assign attributes for hours,
minutes, and seconds:</p><pre class="python">
<span class="py-src-variable">time</span> = <span class="py-src-variable">Time</span>()
<span class="py-src-variable">time</span>.<span class="py-src-variable">hours</span> = <span class="py-src-number">11</span>
<span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span> = <span class="py-src-number">59</span>
<span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span> = <span class="py-src-number">30</span>
</pre><p>The state diagram for the <code>Time</code> object looks like this:</p><img src="illustrations/time.png" /><h2>13.2 Pure functions<a name="auto1"></a></h2><a name="index03"></a><a name="index04"></a><p>In the next few sections, we'll write two versions of a function called
<code>add_time</code>, which calculates the sum of two <code>Time</code>s.
They will demonstrate two kinds of functions: pure functions and modifiers.</p><p>The following is a rough version of <code>add_time</code>:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">add_time</span>(<span class="py-src-parameter">t1</span>, <span class="py-src-parameter">t2</span>):
    <span class="py-src-variable">sum</span> = <span class="py-src-variable">Time</span>()
    <span class="py-src-variable">sum</span>.<span class="py-src-variable">hours</span> = <span class="py-src-variable">t1</span>.<span class="py-src-variable">hours</span> + <span class="py-src-variable">t2</span>.<span class="py-src-variable">hours</span>
    <span class="py-src-variable">sum</span>.<span class="py-src-variable">minutes</span> = <span class="py-src-variable">t1</span>.<span class="py-src-variable">minutes</span> + <span class="py-src-variable">t2</span>.<span class="py-src-variable">minutes</span>
    <span class="py-src-variable">sum</span>.<span class="py-src-variable">seconds</span> = <span class="py-src-variable">t1</span>.<span class="py-src-variable">seconds</span> + <span class="py-src-variable">t2</span>.<span class="py-src-variable">seconds</span>
    <span class="py-src-keyword">return</span> <span class="py-src-variable">sum</span>
</pre><p>The function creates a new <code>Time</code> object, initializes its
attributes, and returns a reference to the new object.  This is called a
<b>pure function</b> because it does not modify any of the objects
passed to it as parameters and it has no side effects, such as displaying a
value or getting user input.</p><p>Here is an example of how to use this function.  We'll create two
<code>Time</code> objects: <code>current_time</code>, which contains the current 
time; and <code>bread_time</code>, which contains the amount of time it takes
for a breadmaker to make bread.  Then we'll use <code>add_time</code> to figure
out when the bread will be done.  If you haven't finished writing
<code>print_time</code> yet, take a look ahead to
Section <!-- reference print_time --> before you try this:</p><pre class="python-interpreter">
&gt;&gt;&gt; current_time = Time()
&gt;&gt;&gt; current_time.hours = 9
&gt;&gt;&gt; current_time.minutes = 14
&gt;&gt;&gt; current_time.seconds =  30
&gt;&gt;&gt; bread_time = Time()
&gt;&gt;&gt; bread_time.hours = 3
&gt;&gt;&gt; bread_time.minutes = 35
&gt;&gt;&gt; bread_time.seconds = 0
&gt;&gt;&gt; done_time = add_time(current_time, bread_time)
&gt;&gt;&gt; print_time(done_time)
12:49:30
</pre><p>The output of this program is <code>12:49:30</code>, which is correct. On
the other hand, there are cases where the result is not correct.  Can you
think of one?</p><p>The problem is that this function does not deal with cases where the number
of seconds or minutes adds up to more than sixty.  When that happens, we have
to <q>carry</q> the extra seconds into the minutes column or the extra minutes
into the hours column.</p><p>Here's a second corrected version of the function:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">add_time</span>(<span class="py-src-parameter">t1</span>, <span class="py-src-parameter">t2</span>):
    <span class="py-src-variable">sum</span> = <span class="py-src-variable">Time</span>()
    <span class="py-src-variable">sum</span>.<span class="py-src-variable">hours</span> = <span class="py-src-variable">t1</span>.<span class="py-src-variable">hours</span> + <span class="py-src-variable">t2</span>.<span class="py-src-variable">hours</span>
    <span class="py-src-variable">sum</span>.<span class="py-src-variable">minutes</span> = <span class="py-src-variable">t1</span>.<span class="py-src-variable">minutes</span> + <span class="py-src-variable">t2</span>.<span class="py-src-variable">minutes</span>
    <span class="py-src-variable">sum</span>.<span class="py-src-variable">seconds</span> = <span class="py-src-variable">t1</span>.<span class="py-src-variable">seconds</span> + <span class="py-src-variable">t2</span>.<span class="py-src-variable">seconds</span>
   
    <span class="py-src-keyword">if</span> <span class="py-src-variable">sum</span>.<span class="py-src-variable">seconds</span> &gt;= <span class="py-src-number">60</span>:
        <span class="py-src-variable">sum</span>.<span class="py-src-variable">seconds</span> = <span class="py-src-variable">sum</span>.<span class="py-src-variable">seconds</span> - <span class="py-src-number">60</span>
        <span class="py-src-variable">sum</span>.<span class="py-src-variable">minutes</span> = <span class="py-src-variable">sum</span>.<span class="py-src-variable">minutes</span> + <span class="py-src-number">1</span>
   
    <span class="py-src-keyword">if</span> <span class="py-src-variable">sum</span>.<span class="py-src-variable">minutes</span> &gt;= <span class="py-src-number">60</span>:
        <span class="py-src-variable">sum</span>.<span class="py-src-variable">minutes</span> = <span class="py-src-variable">sum</span>.<span class="py-src-variable">minutes</span> - <span class="py-src-number">60</span>
        <span class="py-src-variable">sum</span>.<span class="py-src-variable">hours</span> = <span class="py-src-variable">sum</span>.<span class="py-src-variable">hours</span> + <span class="py-src-number">1</span>
   
    <span class="py-src-keyword">return</span> <span class="py-src-variable">sum</span>
</pre><p>Although this function is correct, it is starting to get big.  Later we will 
suggest an alternative approach that yields shorter code.</p><h2>13.3 Modifiers<a name="auto2"></a></h2><a name="increment"></a><a name="index05"></a><a name="index06"></a><p>There are times when it is useful for a function to modify one or more of
the objects it gets as parameters.  Usually, the caller keeps a reference to
the objects it passes, so any changes the function makes are visible to the
caller.  Functions that work this way are called <b>modifiers</b>.
</p><p><code>increment</code>, which adds a given number of seconds to a
<code>Time</code> object, would be written most naturally as a modifier.  A
rough draft of the function looks like this:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">increment</span>(<span class="py-src-parameter">time</span>, <span class="py-src-parameter">seconds</span>):
    <span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span> = <span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span> + <span class="py-src-variable">seconds</span>
   
    <span class="py-src-keyword">if</span> <span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span> &gt;= <span class="py-src-number">60</span>:
        <span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span> = <span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span> - <span class="py-src-number">60</span>
        <span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span> = <span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span> + <span class="py-src-number">1</span>
   
    <span class="py-src-keyword">if</span> <span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span> &gt;= <span class="py-src-number">60</span>:
        <span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span> = <span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span> - <span class="py-src-number">60</span>
        <span class="py-src-variable">time</span>.<span class="py-src-variable">hours</span> = <span class="py-src-variable">time</span>.<span class="py-src-variable">hours</span> + <span class="py-src-number">1</span>
</pre><p>The first line performs the basic operation; the remainder deals
with the special cases we saw before.</p><p>Is this function correct?  What happens if the parameter
<code>seconds</code> is much greater than sixty?  In that case, it is not
enough to carry once; we have to keep doing it until <code>seconds</code> is
less than sixty.  One solution is to replace the <code>if</code> statements
with <code>while</code> statements:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">increment</span>(<span class="py-src-parameter">time</span>, <span class="py-src-parameter">seconds</span>):
    <span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span> = <span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span> + <span class="py-src-variable">seconds</span>
   
    <span class="py-src-keyword">while</span> <span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span> &gt;= <span class="py-src-number">60</span>:
        <span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span> = <span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span> - <span class="py-src-number">60</span>
        <span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span> = <span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span> + <span class="py-src-number">1</span>
   
    <span class="py-src-keyword">while</span> <span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span> &gt;= <span class="py-src-number">60</span>:
        <span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span> = <span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span> - <span class="py-src-number">60</span>
        <span class="py-src-variable">time</span>.<span class="py-src-variable">hours</span> = <span class="py-src-variable">time</span>.<span class="py-src-variable">hours</span> + <span class="py-src-number">1</span>
</pre><p>This function is now correct, but it is not the most efficient solution.</p><h2>13.4 Prototype development versus planning<a name="auto3"></a></h2><a name="convert"></a><a name="index07"></a><p>In this chapter, we demonstrated an approach to program development that we
call <b>prototype development</b>. In each case, we wrote a rough
draft (or prototype) that performed the basic calculation and then tested it on 
a few cases, correcting flaws as we found them.</p><p>Although this approach can be effective, it can lead to code that is
unnecessarily complicated---since it deals with many special cases---and
unreliable---since it is hard to know if you have found all the errors.</p><p>An alternative is <b>planned development</b>, in which high-level
insight into the problem can make the programming much easier.  In this case,
the insight is that a <code>Time</code> object is really a three-digit number
in base 60!  The <code>second</code> component is the <q>ones column,</q> the
<code>minute</code> component is the <q>sixties column,</q> and the
<code>hour</code> component is the <q>thirty-six hundreds column.</q></p><p>When we wrote <code>add_time</code> and <code>increment</code>, we were
effectively doing addition in base 60, which is why we had to carry from one
column to the next.</p><p>This observation suggests another approach to the whole problem---we can
convert a <code>Time</code> object into a single number and take advantage of
the fact that the computer knows how to do arithmetic with numbers.  The
following function converts a <code>Time</code> object into an integer:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">convert_to_seconds</span>(<span class="py-src-parameter">t</span>):
    <span class="py-src-variable">minutes</span> = <span class="py-src-variable">t</span>.<span class="py-src-variable">hours</span> * <span class="py-src-number">60</span> + <span class="py-src-variable">t</span>.<span class="py-src-variable">minutes</span>
    <span class="py-src-variable">seconds</span> = <span class="py-src-variable">minutes</span> * <span class="py-src-number">60</span> + <span class="py-src-variable">t</span>.<span class="py-src-variable">seconds</span>
    <span class="py-src-keyword">return</span> <span class="py-src-variable">seconds</span>
</pre><p>Now, all we need is a way to convert from an integer to a <code>Time</code>
object:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">make_time</span>(<span class="py-src-parameter">seconds</span>):
    <span class="py-src-variable">time</span> = <span class="py-src-variable">Time</span>()
    <span class="py-src-variable">time</span>.<span class="py-src-variable">hours</span> = <span class="py-src-variable">seconds</span>/<span class="py-src-number">3600</span>
    <span class="py-src-variable">seconds</span> = <span class="py-src-variable">seconds</span> - <span class="py-src-variable">time</span>.<span class="py-src-variable">hours</span> * <span class="py-src-number">3600</span>
    <span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span> = <span class="py-src-variable">seconds</span>/<span class="py-src-number">60</span>
    <span class="py-src-variable">seconds</span> = <span class="py-src-variable">seconds</span> - <span class="py-src-variable">time</span>.<span class="py-src-variable">minutes</span> * <span class="py-src-number">60</span>
    <span class="py-src-variable">time</span>.<span class="py-src-variable">seconds</span> = <span class="py-src-variable">seconds</span>
    <span class="py-src-keyword">return</span> <span class="py-src-variable">time</span>
</pre><p>You might have to think a bit to convince yourself that this technique
to convert from one base to another is correct.  Assuming you are convinced,
you can use these functions to rewrite <code>add_time</code>:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">add_time</span>(<span class="py-src-parameter">t1</span>, <span class="py-src-parameter">t2</span>):
    <span class="py-src-variable">seconds</span> = <span class="py-src-variable">convert_to_seconds</span>(<span class="py-src-variable">t1</span>) + <span class="py-src-variable">convert_to_seconds</span>(<span class="py-src-variable">t2</span>)
    <span class="py-src-keyword">return</span> <span class="py-src-variable">make_time</span>(<span class="py-src-variable">seconds</span>)
</pre><p>This version is much shorter than the original, and it is much easier to
demonstrate that it is correct (assuming, as usual, that the functions it
calls are correct).</p><h2>13.5 Generalization<a name="auto4"></a></h2><a name="index08"></a><p>In some ways, converting from base 60 to base 10 and back is harder than
just dealing with times.  Base conversion is more abstract; our intuition for
dealing with times is better.</p><p>But if we have the insight to treat times as base 60 numbers and make the
investment of writing the conversion functions (<code>convert_to_seconds</code>
and <code>make_time</code>), we get a program that is shorter, easier to read
and debug, and more reliable.</p><p>It is also easier to add features later.  For example, imagine subtracting
two <code>Time</code>s to find the duration between them.  The naive approach
would be to implement subtraction with borrowing.  Using the conversion
functions would be easier and more likely to be correct.</p><p>Ironically, sometimes making a problem harder (or more general) makes it
easier (because there are fewer special cases and fewer opportunities for
error).</p><h2>13.6 Algorithms<a name="auto5"></a></h2><a name="index09"></a><p>When you write a general solution for a class of problems, as opposed to a
specific solution to a single problem, you have written an
<b>algorithm</b>.  We mentioned this word before but did not define
it carefully.  It is not easy to define, so we will try a couple of approaches.
</p><p>First, consider something that is not an algorithm.  When you learned to
multiply single-digit numbers, you probably memorized the multiplication table. 
In effect, you memorized 100 specific solutions.  That kind of knowledge is not 
algorithmic.</p><p>But if you were <q>lazy,</q> you probably cheated by learning a few tricks.  
For example, to find the product of <code>n</code> and 9, you can write
<code>n-1</code> as the first digit and <code>10-n</code> as the second digit.  
This trick is a general solution for multiplying any single-digit number by 9.  
That's an algorithm!</p><p>Similarly, the techniques you learned for addition with carrying,
subtraction with borrowing, and long division are all algorithms.  One of the
characteristics of algorithms is that they do not require any intelligence to
carry out.  They are mechanical processes in which each step follows from the
last according to a simple set of rules.</p><p>In our opinion, it is embarrassing that humans spend so much time in school
learning to execute algorithms that, quite literally, require no intelligence.
</p><p>On the other hand, the process of designing algorithms is interesting,
intellectually challenging, and a central part of what we call programming.</p><p>Some of the things that people do naturally, without difficulty or conscious 
thought, are the hardest to express algorithmically.  Understanding natural
language is a good example.  We all do it, but so far no one has been able to
explain <em>how</em> we do it, at least not in the form of an algorithm.</p><h2>13.7 Glossary<a name="auto6"></a></h2><a name="index10"></a><a name="index11"></a><a name="index12"></a><a name="index13"></a><a name="index14"></a><a name="index15"></a><a name="index16"></a><a name="index17"></a><dl><dt>pure function:</dt><dd>A function that does not modify any of the objects it receives as
parameters.  Most pure functions are fruitful.</dd><dt>modifier:</dt><dd>A function that changes one or more of the objects it receives as
parameters.  Most modifiers are void.</dd><dt>functional programming style:</dt><dd>A style of program design in which the majority of functions are pure.</dd><dt>prototype development:</dt><dd>A way of developing programs starting with a prototype and gradually
testing and improving it.</dd><dt>planned development:</dt><dd>A way of developing programs that involves high-level insight into the
problem and more planning than incremental development or prototype
development.</dd><dt>algorithm:</dt><dd>A set of instructions for solving a class of problems by a mechanical,
unintelligent process.</dd></dl><h2>13.8 Exercises<a name="auto7"></a></h2><ol><li><div class="exercise">
Write a function <code>print_time</code> that takes a <code>Time</code> object
as an argument and prints it in the form <code>hours:minutes:seconds</code>.
</div></li><li><div class="exercise">
Write a boolean function <code>after</code> that takes two <code>Time</code>
objects, <code>t1</code> and <code>t2</code>, as arguments, and returns
<code>True</code> if <code>t1</code> follows <code>t2</code> chronologically
and <code>False</code> otherwise.
</div></li><li><div class="exercise">
Rewrite the <code>increment</code> function so that it doesn't contain any
loops.
</div></li><li><div class="exercise">
Now rewrite <code>increment</code> as a pure function, and write function calls 
to both versions.
</div></li></ol></div><p><a href="index.html">Table of Contents</a> |
    <a href="dex.html">Index</a></p></body></html>