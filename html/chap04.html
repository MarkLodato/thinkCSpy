<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>How to Think Like a Computer Scientist: 4. Conditionals</title><link href="stylesheet.css" type="text/css" rel="stylesheet" /></head><body bgcolor="white"><h1 class="title">4. Conditionals</h1><div class="toc"><ol><li><a href="#auto0">The modulus operator</a></li><li><a href="#auto1">Boolean values and expressions</a></li><li><a href="#auto2">Logical operators</a></li><li><a href="#auto3">Conditional execution</a></li><li><a href="#auto4">Alternative execution</a></li><li><a href="#auto5">Chained conditionals</a></li><li><a href="#auto6">Nested conditionals</a></li><li><a href="#auto7">The return statement</a></li><li><a href="#auto8">Keyboard input</a></li><li><a href="#auto9">Type conversion</a></li><li><a href="#auto10">Gasp</a></li><li><a href="#auto11">Glossary</a></li><li><a href="#auto12">Exercises</a></li></ol></div><div class="content"><span></span><h2>4.1 The modulus operator<a name="auto0"></a></h2><a name="index01"></a><a name="index02"></a><p>The <b>modulus operator</b> works on integers (and integer
expressions) and yields the remainder when the first operand is divided by the
second.  In Python, the modulus operator is a percent sign (<code>%</code>).
The syntax is the same as for other operators:
</p><pre class="python-interpreter">
&gt;&gt;&gt; quotient = 7 / 3
&gt;&gt;&gt; print quotient
2
&gt;&gt;&gt; remainder = 7 % 3
&gt;&gt;&gt; print remainder
1
</pre><p>So 7 divided by 3 is 2 with 1 left over.</p><p>
The modulus operator turns out to be surprisingly useful.  For example, you
can check whether one number is divisible by another---if <code>x % y</code> is 
zero, then <code>x</code> is divisible by <code>y</code>.</p><p>Also, you can extract the right-most digit or digits from a number.  For
example, <code>x % 10</code> yields the right-most digit of <code>x</code> (in
base 10).  Similarly <code>x % 100</code> yields the last two digits.</p><h2>4.2 Boolean values and expressions<a name="auto1"></a></h2><a name="index03"></a><a name="index04"></a><a name="index05"></a><a name="index06"></a><a name="index07"></a><a name="index08"></a><p>The Python type for storing true and false values is called
<code>bool</code>, named after the British mathematician, George Boole.
George Boole created <em>Boolean algebra</em>, which is the basis of all modern 
computer arithmetic.
</p><p>There are only two <b>boolean values</b>: <code>True</code> and
<code>False</code>.  Capitalization is important, since <code>true</code>
and <code>false</code> are not boolean values.
</p><pre class="python-interpreter">
&gt;&gt;&gt; type(True)
&lt;type 'bool'&gt;
&gt;&gt;&gt; type(true)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'true' is not defined
</pre><p>
A <b>boolean expression</b> is an expression that evaluates to a
boolean value.  The operator <code>==</code> compares two values and produces
a boolean value:</p><pre class="python-interpreter">
&gt;&gt;&gt; 5 == 5
True
&gt;&gt;&gt; 5 == 6
False
</pre><p>In the first statement, the two operands are equal, so the expression
evaluates to <code>True</code>; in the second statement, 5 is not equal to 6,
so we get <code>False</code>.</p><p>The <code>==</code> operator is one of the
<b>comparison operators</b>; the others are:</p><pre class="python">
<span class="py-src-variable">x</span> != <span class="py-src-variable">y</span>               <span class="py-src-comment"># x is not equal to y</span>
<span class="py-src-variable">x</span> &gt; <span class="py-src-variable">y</span>                <span class="py-src-comment"># x is greater than y</span>
<span class="py-src-variable">x</span> &lt; <span class="py-src-variable">y</span>                <span class="py-src-comment"># x is less than y</span>
<span class="py-src-variable">x</span> &gt;= <span class="py-src-variable">y</span>               <span class="py-src-comment"># x is greater than or equal to y</span>
<span class="py-src-variable">x</span> &lt;= <span class="py-src-variable">y</span>               <span class="py-src-comment"># x is less than or equal to y</span>
</pre><p>Although these operations are probably familiar to you, the Python symbols
are different from the mathematical symbols.  A common error is to use a single 
equal sign (<code>=</code>) instead of a double equal sign (<code>==</code>).
Remember that <code>=</code> is an assignment operator and <code>==</code> is a 
comparison operator.   Also, there is no such thing as <code>=&lt;</code> or
<code>=&gt;</code>.</p><h2>4.3 Logical operators<a name="auto2"></a></h2><a name="index09"></a><a name="index10"></a><p>There are three <b>logical operators</b>: <code>and</code>,
<code>or</code>, and <code>not</code>.  The semantics (meaning) of these
operators is similar to their meaning in English.  For example, <code>x &gt; 0
and x &lt; 10</code> is true only if <code>x</code> is greater than 0
<em>and</em> less than 10.</p><p><code>n % 2 == 0 or n % 3 == 0</code> is true if <em>either</em> of the
conditions is true, that is, if the number is divisible by 2 <em>or</em> 3.</p><p>Finally, the <code>not</code> operator negates a boolean expression, so
<code>not(x &gt; y)</code> is true if <code>(x &gt; y)</code> is false,
that is, if <code>x</code> is less than or equal to <code>y</code>.</p><h2>4.4 Conditional execution<a name="auto3"></a></h2><a name="conditional execution"></a><a name="index11"></a><a name="index12"></a><p>In order to write useful programs, we almost always need the ability to
check conditions and change the behavior of the program accordingly.
<b>Conditional statements</b> give us this ability.  The simplest
form is the <code>if</code> statement:</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">x</span> &gt; <span class="py-src-number">0</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;x is positive&quot;</span>
</pre><p>The boolean expression after the <code>if</code> statement is
called the <b>condition</b>.  If it is true, then the indented
statement gets executed.  If not, nothing happens.</p><a name="index13"></a><a name="index14"></a><a name="index15"></a><a name="index16"></a><a name="index17"></a><p>The syntax for an <code>if</code> statement looks like this:</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">BOOLEAN</span> <span class="py-src-variable">EXPRESSION</span>:
    <span class="py-src-variable">STATEMENTS</span>
</pre><p>As with the function definition from last chapter and other compound
statements, the <code>if</code> statement consists of a header and a
body.  The header begins with the keyword <code>if</code> followed by
a <em>boolean expression</em> and ends with a colon (:).</p><p>The indented statements that follow are called a <b>block</b>.  The first
unindented statement marks the end of the block.  A statement block inside a
compound statement is called the <b>body</b> of the statement.</p><p>Each of the statements inside the body are executed in order if the boolean
expression evaluates to <code>True</code>.   The entire block is skipped if the 
boolean expression evaluates to <code>False</code>.</p><a name="index18"></a><a name="index19"></a><a name="index20"></a><p>There is no limit on the number of statements that can appear in the body of 
an <code>if</code> statement, but there has to be at least one.  Occasionally,
it is useful to have a body with no statements (usually as a place keeper for
code you haven't written yet).  In that case, you can use the <code>pass</code>
statement, which does nothing.</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">True</span>:          <span class="py-src-comment"># This is always true</span>
    <span class="py-src-keyword">pass</span>          <span class="py-src-comment"># so this is always executed, but it does nothing</span>
</pre><a name="index21"></a><a name="index22"></a><h2>4.5 Alternative execution<a name="auto4"></a></h2><a name="alternative execution"></a><p>A second form of the <code>if</code> statement is alternative execution,
in which there are two possibilities and the condition determines which one
gets executed.  The syntax looks like this:</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">x</span> % <span class="py-src-number">2</span> == <span class="py-src-number">0</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">x</span>, <span class="py-src-string">&quot;is even&quot;</span>
<span class="py-src-keyword">else</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">x</span>, <span class="py-src-string">&quot;is odd&quot;</span>
</pre><p>If the remainder when <code>x</code> is divided by 2 is 0, then we know that 
<code>x</code> is even, and the program displays a message to that effect.  If
the condition is false, the second set of statements is executed.  Since the
condition must be true or false, exactly one of the alternatives will be
executed.  The alternatives are called <b>branches</b>, because they
are branches in the flow of execution.</p><a name="index23"></a><p>As an aside, if you need to check the parity (evenness or oddness) of
numbers often, you might <q>wrap</q> this code in a function:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">print_parity</span>(<span class="py-src-parameter">x</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">x</span> % <span class="py-src-number">2</span> == <span class="py-src-number">0</span>:
        <span class="py-src-keyword">print</span> <span class="py-src-variable">x</span>, <span class="py-src-string">&quot;is even&quot;</span>
    <span class="py-src-keyword">else</span>:
        <span class="py-src-keyword">print</span> <span class="py-src-variable">x</span>, <span class="py-src-string">&quot;is odd&quot;</span>
</pre><p>For any value of <code>x</code>, <code>print_parity</code> displays an
appropriate message.  When you call it, you can provide any integer expression
as an argument.</p><pre class="python-interpreter">
&gt;&gt;&gt; print_parity(17)
17 is odd.
&gt;&gt;&gt; y = 41
&gt;&gt;&gt; print_parity(y+1)
42 is even.
</pre><h2>4.6 Chained conditionals<a name="auto5"></a></h2><a name="index24"></a><a name="index25"></a><p>Sometimes there are more than two possibilities and we need more than two
branches.  One way to express a computation like that is a
<b>chained conditional</b>:</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">x</span> &lt; <span class="py-src-variable">y</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">x</span>, <span class="py-src-string">&quot;is less than&quot;</span>, <span class="py-src-variable">y</span>
<span class="py-src-keyword">elif</span> <span class="py-src-variable">x</span> &gt; <span class="py-src-variable">y</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">x</span>, <span class="py-src-string">&quot;is greater than&quot;</span>, <span class="py-src-variable">y</span>
<span class="py-src-keyword">else</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">x</span>, <span class="py-src-string">&quot;and&quot;</span>, <span class="py-src-variable">y</span>, <span class="py-src-string">&quot;are equal&quot;</span>
</pre><p><code>elif</code> is an abbreviation of <q>else if</q>.  Again, exactly one
branch will be executed.  There is no limit of the number of <code>elif</code>
statements but only a single (and optional) <code>else</code> statement is
allowed and it must be the last branch in the statement:</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">choice</span> == <span class="py-src-string">'a'</span>:
    <span class="py-src-variable">function_a</span>()
<span class="py-src-keyword">elif</span> <span class="py-src-variable">choice</span> == <span class="py-src-string">'b'</span>:
    <span class="py-src-variable">function_b</span>()
<span class="py-src-keyword">elif</span> <span class="py-src-variable">choice</span> == <span class="py-src-string">'c'</span>:
    <span class="py-src-variable">function_c</span>()
<span class="py-src-keyword">else</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Invalid choice.&quot;</span>
</pre><p>Each condition is checked in order.  If the first is false, the next is
checked, and so on.  If one of them is true, the corresponding branch executes, 
and the statement ends.  Even if more than one condition is true, only the
first true branch executes.</p><h2>4.7 Nested conditionals<a name="auto6"></a></h2><p>One conditional can also be <b>nested</b> within another.  We could have
written the trichotomy example as follows:</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">x</span> == <span class="py-src-variable">y</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">x</span>, <span class="py-src-string">&quot;and&quot;</span>, <span class="py-src-variable">y</span>, <span class="py-src-string">&quot;are equal&quot;</span>
<span class="py-src-keyword">else</span>:
    <span class="py-src-keyword">if</span> <span class="py-src-variable">x</span> &lt; <span class="py-src-variable">y</span>:
        <span class="py-src-keyword">print</span> <span class="py-src-variable">x</span>, <span class="py-src-string">&quot;is less than&quot;</span>, <span class="py-src-variable">y</span>
    <span class="py-src-keyword">else</span>:
        <span class="py-src-keyword">print</span> <span class="py-src-variable">x</span>, <span class="py-src-string">&quot;is greater than&quot;</span>, <span class="py-src-variable">y</span>
</pre><p>The outer conditional contains two branches.  The first branch contains a
simple output statement.  The second branch contains another <code>if</code>
statement, which has two branches of its own.  Those two branches are both
output statements, although they could have been conditional statements as
well.</p><p>Although the indentation of the statements makes the structure apparent,
nested conditionals become difficult to read very quickly. In general, it is a
good idea to avoid them when you can.</p><p>Logical operators often provide a way to simplify nested conditional
statements.  For example, we can rewrite the following code using a
single conditional:</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-number">0</span> &lt; <span class="py-src-variable">x</span>:
    <span class="py-src-keyword">if</span> <span class="py-src-variable">x</span> &lt; <span class="py-src-number">10</span>:
        <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;x is a positive single digit.&quot;</span>
</pre><p>The <code>print</code> statement is executed only if we make it past both
the conditionals, so we can use the <code>and</code> operator:</p><pre class="python-interpreter">
if 0 &lt; x and x &lt; 10:
    print &quot;x is a positive single digit.&quot;
</pre><p>These kinds of conditions are common, so Python provides an alternative
syntax that is similar to mathematical notation:</p><pre class="python-interpreter">
if 0 &lt; x &lt; 10:
    print &quot;x is a positive single digit.&quot;
</pre><p>This condition is semantically the same as the compound boolean expression
and the nested conditional.</p><h2>4.8 The <code>return</code> statement<a name="auto7"></a></h2><a name="index26"></a><a name="index27"></a><p>The <code>return</code> statement allows you to terminate the execution of a
function before you reach the end.  One reason to use it is if you detect an
error condition:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">print_square_root</span>(<span class="py-src-parameter">x</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">x</span> &lt;= <span class="py-src-number">0</span>:
        <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Positive numbers only, please.&quot;</span>
        <span class="py-src-keyword">return</span>

    <span class="py-src-variable">result</span> = <span class="py-src-variable">x</span>**<span class="py-src-number">0.5</span>
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;The square root of x is&quot;</span>, <span class="py-src-variable">result</span>
</pre><p>The function <code>print_square_root</code> has a parameter named
<code>x</code>.  The first thing it does is check whether <code>x</code> is
less than or equal to 0, in which case it displays an error message and then
uses <code>return</code> to exit the function. The flow of execution
immediately returns to the caller, and the remaining lines of the function are
not executed.</p><h2>4.9 Keyboard input<a name="auto8"></a></h2><p>In chapter 2 we were introduced to Python's built-in functions that get
input from the keyboard: <code>raw_input</code> and <code>input</code>.
Now let's look at these again in greater depth.</p><p>When either of these functions are called, the program stops and waits for
the user to type something.  When the user presses Return or the Enter key, the 
program resumes and <code>raw_input</code> returns what the user typed as a
<code>string</code>:</p><pre class="python-interpreter">
&gt;&gt;&gt; my_input = raw_input()
What are you waiting for?
&gt;&gt;&gt; print my_input
What are you waiting for?
</pre><p>Before calling <code>raw_input</code>, it is a good idea to print a message
telling the user what to input.  This message is called a <b>prompt</b>.
We can supply a prompt as an argument to <code>raw_input</code>:</p><a name="index28"></a><pre class="python-interpreter">
&gt;&gt;&gt; name = raw_input(&quot;What...is your name? &quot;)
What...is your name? Arthur, King of the Britons!
&gt;&gt;&gt; print name
Arthur, King of the Britons!
</pre><p>Notice that the prompt is a string, so it must be enclosed in quotation
marks.</p><p>If we expect the response to be an integer, we can use the
<code>input</code> function which evaluates the response as a Python
expression:</p><pre class="python">
<span class="py-src-variable">prompt</span> = <span class="py-src-string">&quot;What...is the airspeed velocity of an unladen swallow?\n&quot;</span>
<span class="py-src-variable">speed</span> = <span class="py-src-variable">input</span>(<span class="py-src-variable">prompt</span>)
</pre><p>If the user types a string of digits, it is converted to an integer and
assigned to <code>speed</code>.  Unfortunately, if the user types characters
that do not make up a valid Python expression, the program crashes:</p><pre class="python-interpreter">
&gt;&gt;&gt; speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
...
SyntaxError: invalid syntax
</pre><p>In the last example, if the user had made the response a valid Python
expression by putting quotes around it, it would not have given an error:
</p><pre class="python-interpreter">
&gt;&gt;&gt; speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
&quot;What do you mean, an African or a European swallow?&quot;
&gt;&gt;&gt; speed
'What do you mean, an African or a European swallow?'
&gt;&gt;&gt;
</pre><p>To avoid this kind of error, it is a good idea to use <code>raw_input</code> 
to get a string and then use conversion commands to convert it to other types.
</p><h2>4.10 Type conversion<a name="auto9"></a></h2><a name="index29"></a><a name="index30"></a><p>Each Python type comes with a built-in command that attemps to convert values
of another type into that type.  The <code>int(ARGUMENT)</code> command, for
example, takes any value and converts it to an integer, if possible, or
complains otherwise:</p><pre class="python-interpreter">
&gt;&gt;&gt; int(&quot;32&quot;)
32
&gt;&gt;&gt; int(&quot;Hello&quot;)
ValueError: invalid literal for int() with base 10: 'Hello'
</pre><p><code>int</code> can also convert floating-point values to integers, but
remember that it truncates the fractional part:</p><pre class="python-interpreter">
&gt;&gt;&gt; int(-2.3)
-2
&gt;&gt;&gt; int(3.99999)
3
&gt;&gt;&gt; int(&quot;42&quot;)
42
&gt;&gt;&gt; int(1.0)
1
</pre><p>The <code>float(ARGUMENT)</code> command converts integers and strings to
floating-point numbers:</p><pre class="python-interpreter">
&gt;&gt;&gt; float(32)
32.0
&gt;&gt;&gt; float(&quot;3.14159&quot;)
3.14159
&gt;&gt;&gt; float(1)
1.0
</pre><p>It may seem odd that Python distinguishes the integer value <code>1</code>
from the floating-point value <code>1.0</code>.  They may represent the same
number, but they belong to different types.  The reason is that they
are represented differently inside the computer.</p><p>The <code>str(ARGUMENT)</code> command converts any argument given to it to
type <code>string</code>:</p><pre class="python-interpreter">
&gt;&gt;&gt; str(32)
'32'
&gt;&gt;&gt; str(3.14149)
'3.14149'
&gt;&gt;&gt; str(True)
'True'
&gt;&gt;&gt; str(true)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'true' is not defined
</pre><p><code>str(ARGUMENT)</code> with work with any value and convert it into
a string.  As mentioned earlier, <code>True</code> is boolean value;
<code>true</code> is not.</p><p>For boolean values, the situation is especially interesting:</p><pre class="python-interpreter">
&gt;&gt;&gt; bool(1)
True
&gt;&gt;&gt; bool(0)
False
&gt;&gt;&gt; bool(&quot;Ni!&quot;)
True
&gt;&gt;&gt; bool(&quot;&quot;)
False
&gt;&gt;&gt; bool(3.14159)
True
&gt;&gt;&gt; bool(0.0)
False
</pre><p>Python assigns boolean values to values of other types.  For numerical
types like integers and floating-points, zero values are false and non-zero
values are true.  For strings, empty strings are false and non-empty strings
are true.</p><h2>4.11 Gasp<a name="auto10"></a></h2><p>Gasp (<b>G</b>raphics <b>A</b>PI for <b>S</b>tudents of <b>P</b>ython)
will enable us to write programs involving graphics.
</p><p>
To start gasp, try the following:
</p><pre class="python-interpreter">
&gt;&gt;&gt; from gasp import *
&gt;&gt;&gt; begin_graphics()
&gt;&gt;&gt; Circle((200, 200), 60)
Circle instance at (200, 200) with radius 60
&gt;&gt;&gt; Line((100, 400), (580, 200))
Line instance from (100, 400) to (590, 250)
&gt;&gt;&gt; Box((400, 350), 120, 100)
Box instance at (400, 350) with width 120 and height 100
&gt;&gt;&gt; end_graphics()
&gt;&gt;&gt;
</pre><p>Before the last command, which closes the graphics canvas, you should see a
graphics window that looks like this:</p><p><img src="illustrations/gasp01.png" alt="Gasp illustration 1" /></p><p>We will be using gasp from here on to illustrate (pun intended) computer
programming concepts and to add to our fun while learning.
</p><h2>4.12 Glossary<a name="auto11"></a></h2><a name="index31"></a><a name="index32"></a><a name="index33"></a><a name="index34"></a><a name="index35"></a><a name="index36"></a><a name="index37"></a><a name="index38"></a><a name="index39"></a><a name="index40"></a><a name="index41"></a><a name="index42"></a><a name="index43"></a><a name="index44"></a><a name="index45"></a><dl><dt>modulus operator:</dt><dd>An operator, denoted with a percent sign (<code>%</code>), that works on
integers and yields the remainder when one number is divided by another.</dd><dt>boolean value:</dt><dd>There are exactly two boolean values: <code>True</code> and
<code>False</code>.  Boolean values result when a boolean expression is
evaluated by the Python interepreter.  They have type <code>bool</code>.
</dd><dt>boolean expression:</dt><dd>An expression that is either true or false.</dd><dt>comparison operator:</dt><dd> One of the operators that compares two
values: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, 
<code>&gt;=</code>, and <code>&lt;=</code>.</dd><dt>logical operator:</dt><dd>One of the operators that combines boolean expressions: <code>and</code>,
<code>or</code>, and <code>not</code>.</dd><dt>conditional statement:</dt><dd>A statement that controls the flow of execution depending on some
condition.</dd><dt>condition:</dt><dd>The boolean expression in a conditional statement that determines which
branch is executed.</dd><dt>block:</dt><dd>A group of consecutive statements with the same indentation.</dd><dt>body:</dt><dd>The block of statements in a compound statement that follows the header.
</dd><dt>branch:</dt><dd>One of the possible paths of the flow of execution determined by 
conditional execution.</dd><dt>chained conditional:</dt><dd>A conditional branch with more than two possible flows of execution.
In Python chained conditionals are written with
<code class="Python">if ... elif ... else</code> statements.</dd><dt>nesting:</dt><dd>One program structure within another, such as a conditional statement
inside a branch of another conditional statement.</dd><dt>prompt:</dt><dd>A visual cue that tells the user to input data.</dd><dt>type conversion:</dt><dd>An explicit statement that takes a value of one type and computes a
corresponding value of another type.</dd></dl><h2>4.13 Exercises<a name="auto12"></a></h2><ol><li><div class="exercise"><p>Try to evaluate the following numerical expressions in your head, then use
the Python interpreter to check your results:</p><ol style="list-style-type: lower-alpha;"><li><code>&gt;&gt;&gt; 5 % 2</code></li><li><code>&gt;&gt;&gt; 9 % 5</code></li><li><code>&gt;&gt;&gt; 15 % 12</code></li><li><code>&gt;&gt;&gt; 12 % 15</code></li><li><code>&gt;&gt;&gt; 6 % 6</code></li><li><code>&gt;&gt;&gt; 0 % 7</code></li><li><code>&gt;&gt;&gt; 7 % 0</code></li></ol><p>What happened with the last example?  Why?  If you were able to correctly
anticipate the computer's response in all but the last one, it is time to move
on.  If not, take time now to make up examples of your own.  Explore the
modulus operator until you are confident you understand how it works.</p></div></li><li><div class="exercise"><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">x</span> &lt; <span class="py-src-variable">y</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">x</span>, <span class="py-src-string">&quot;is less than&quot;</span>, <span class="py-src-variable">y</span>
<span class="py-src-keyword">elif</span> <span class="py-src-variable">x</span> &gt; <span class="py-src-variable">y</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">x</span>, <span class="py-src-string">&quot;is greater than&quot;</span>, <span class="py-src-variable">y</span>
<span class="py-src-keyword">else</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-variable">x</span>, <span class="py-src-string">&quot;and&quot;</span>, <span class="py-src-variable">y</span>, <span class="py-src-string">&quot;are equal&quot;</span>
</pre><em>Wrap</em> this code in a function called <code>compare(x, y)</code>.
Call <code>compare</code> three times: one each where the first
argument is less than, greater than, and equal to the second argument.
</div></li><li><div class="exercise"><p>
To better understand boolean expressions, it is helpful to construct
truth tables.  Two boolean expressions are <em>logically equivalent</em>
if and only if they have the same truth table.
</p><p>
The following Python script prints out the truth table for the
any boolean expression in two variables: p and q:
</p><pre class="python">
<span class="py-src-variable">expression</span> = <span class="py-src-variable">raw_input</span>(<span class="py-src-string">&quot;Enter a boolean expression in two variables, p and q: &quot;</span>)

<span class="py-src-keyword">print</span> <span class="py-src-string">&quot; p      q      %s&quot;</span>  % <span class="py-src-variable">expression</span>
<span class="py-src-variable">length</span> = <span class="py-src-variable">len</span>( <span class="py-src-string">&quot; p      q      %s&quot;</span>  % <span class="py-src-variable">expression</span>)
<span class="py-src-keyword">print</span> <span class="py-src-variable">length</span>*<span class="py-src-string">&quot;=&quot;</span>

<span class="py-src-keyword">for</span> <span class="py-src-variable">p</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">True</span>, <span class="py-src-variable">False</span>:
    <span class="py-src-keyword">for</span> <span class="py-src-variable">q</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">True</span>, <span class="py-src-variable">False</span>:
        <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;%-7s %-7s %-7s&quot;</span> % (<span class="py-src-variable">p</span>, <span class="py-src-variable">q</span>, <span class="py-src-variable">eval</span>(<span class="py-src-variable">expression</span>))
</pre><p>
You will learn how this script works in later chapters.  For now, you will
use it to learn about boolean expressions.  Copy this program to a file named
<code>p_and_q.py</code>, then run it from the command line and give it:
<code>p or q</code>, when prompted for a boolean expression.  You should
get the following output:
</p><pre class="boxed">
 p      q      p or q
=====================
True    True    True   
True    False   True   
False   True    True   
False   False   False
</pre><p>
Now that we see how it works, let's wrap it in a function to make it easier
to use:
</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">truth_table</span>(<span class="py-src-parameter">expression</span>):
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot; p      q      %s&quot;</span>  % <span class="py-src-variable">expression</span>
    <span class="py-src-variable">length</span> = <span class="py-src-variable">len</span>( <span class="py-src-string">&quot; p      q      %s&quot;</span>  % <span class="py-src-variable">expression</span>)
    <span class="py-src-keyword">print</span> <span class="py-src-variable">length</span>*<span class="py-src-string">&quot;=&quot;</span>

    <span class="py-src-keyword">for</span> <span class="py-src-variable">p</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">True</span>, <span class="py-src-variable">False</span>:
        <span class="py-src-keyword">for</span> <span class="py-src-variable">q</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">True</span>, <span class="py-src-variable">False</span>:
            <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;%-7s %-7s %-7s&quot;</span> % (<span class="py-src-variable">p</span>, <span class="py-src-variable">q</span>, <span class="py-src-variable">eval</span>(<span class="py-src-variable">expression</span>))
</pre><p>
We can import it into a Python shell and call <code>truth_table</code>
with a string containing our boolean expression in p and q as an argument:
</p><pre class="python-interpreter">
&gt;&gt;&gt; from p_and_q import *
&gt;&gt;&gt; truth_table(&quot;p or q&quot;)
 p      q      p or q
=====================
True    True    True   
True    False   True   
False   True    True   
False   False   False
&gt;&gt;&gt;
</pre><p>
Use the <code>truth_table</code> functions with the following boolean
expressions, recording the truth table produced each time:
</p><ol style="list-style-type: lower-alpha;"><li>not(p or q)</li><li>p and q</li><li>not(p and q)</li><li>not(p) or not(q)</li><li>not(p) and not(q)</li></ol><p>
Which of these are logically equivalent?
</p></div></li><li><div class="exercise"><p>
Enter the following expressions into the Python shell:
</p><pre class="python">
<span class="py-src-variable">True</span> <span class="py-src-keyword">or</span> <span class="py-src-variable">False</span>
<span class="py-src-variable">True</span> <span class="py-src-keyword">and</span> <span class="py-src-variable">False</span>
<span class="py-src-keyword">not</span>(<span class="py-src-variable">False</span>) <span class="py-src-keyword">and</span> <span class="py-src-variable">True</span>
<span class="py-src-variable">True</span> <span class="py-src-keyword">or</span> <span class="py-src-number">7</span>
<span class="py-src-variable">False</span> <span class="py-src-keyword">or</span> <span class="py-src-number">7</span>
<span class="py-src-variable">True</span> <span class="py-src-keyword">and</span> <span class="py-src-number">0</span>
<span class="py-src-variable">False</span> <span class="py-src-keyword">or</span> <span class="py-src-number">8</span>
<span class="py-src-string">&quot;happy&quot;</span> <span class="py-src-keyword">and</span> <span class="py-src-string">&quot;sad&quot;</span>
<span class="py-src-string">&quot;happy&quot;</span> <span class="py-src-keyword">or</span> <span class="py-src-string">&quot;sad&quot;</span>
<span class="py-src-string">&quot;&quot;</span> <span class="py-src-keyword">and</span> <span class="py-src-string">&quot;sad&quot;</span>
<span class="py-src-string">&quot;happy&quot;</span> <span class="py-src-keyword">and</span> <span class="py-src-string">&quot;&quot;</span>
</pre><p>
Analyze these results.  What observations can you make about values of
different types and logical operators?  Can you write these observations
in the form of simple <em>rules</em> about <code>and</code> and
<code>or</code> expressions?
</p></div></li><li><div class="exercise"><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">choice</span> == <span class="py-src-string">'a'</span>:
    <span class="py-src-variable">function_a</span>()
<span class="py-src-keyword">elif</span> <span class="py-src-variable">choice</span> == <span class="py-src-string">'b'</span>:
    <span class="py-src-variable">function_b</span>()
<span class="py-src-keyword">elif</span> <span class="py-src-variable">choice</span> == <span class="py-src-string">'c'</span>:
    <span class="py-src-variable">function_c</span>()
<span class="py-src-keyword">else</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Invalid choice.&quot;</span>
</pre><p>
Wrap this code in a function called <code>dispatch(choice)</code>. Then
define <code>function_a</code>, <code>function_b</code>, and
<code>function_c</code> so that they print out a message saying they were
called.  For example:
</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">function_a</span>():
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;function_a was called...&quot;</span>
</pre><p>
Put the four functions (<code>dispatch</code>, <code>function_a</code>,
<code>function_b</code>, and <code>function_c</code> into a script named
<code>ch4prob4.py</code>.  At the bottom of this script add a call to
<code>dispatch('b')</code>.  Your output should be:
</p><pre class="boxed">
function_b was called...
</pre><p>
Finally, modify the script so that user can enter 'a', 'b', or 'c'.  Test
it by importing your script into the Python shell.
</p></div></li><li><div class="exercise"><p>
Write a function named <code>is_divisible_by_3</code> that takes a single
integer as an argument and prints &quot;This number is divisible by three.&quot; if
the argument is evenly divisible by 3 and &quot;This number is not divisible by
three.&quot; otherwise.
</p><p>
Now write a similar function named <code>is_divisible_by_5</code>.
</p></div></li><li><div class="exercise"><p>
Generalize the functions you wrote in the previous exercise into a function
named <code>is_divisible_by_n(x, n)</code> that takes two integer arguments
and prints out whether the first is divisible by the second.  Save this in
a file named <code>ch04e06.py</code>. Import it into a shell and try it out. 
A sample session might look like this:
</p><pre class="python-interpreter">
&gt;&gt;&gt; from ch04e06 import *
&gt;&gt;&gt; is_divisible_by_n(20, 4)
Yes, 20 is divisible by 4
&gt;&gt;&gt; is_divisible_by_n(21, 8)
No, 21 is not divisible by 8
</pre></div></li><li><div class="exercise">
What will be the output of the following?
<pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-string">&quot;Ni!&quot;</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">'We are the Knights who say, &quot;Ni!&quot;'</span>
<span class="py-src-keyword">else</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Stop it! No more of this!&quot;</span>

<span class="py-src-keyword">if</span> <span class="py-src-number">0</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;And now for something completely different...&quot;</span>
<span class="py-src-keyword">else</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;What's all this, then?&quot;</span>
</pre>

Explain what happened and why it happened.
</div></li><li><div class="exercise">
The following gasp script, in a file named <code>house.py</code>, draws
a simple house on a gasp canvas:

<pre class="python">
<span class="py-src-keyword">from</span> <span class="py-src-variable">gasp</span> <span class="py-src-keyword">import</span> *             <span class="py-src-comment"># import everything from the gasp library</span>

<span class="py-src-variable">begin_graphics</span>()               <span class="py-src-comment"># open the graphics canvas</span>

<span class="py-src-variable">Box</span>((<span class="py-src-number">20</span>, <span class="py-src-number">20</span>), <span class="py-src-number">100</span>, <span class="py-src-number">100</span>)        <span class="py-src-comment"># the house</span>
<span class="py-src-variable">Box</span>((<span class="py-src-number">55</span>, <span class="py-src-number">20</span>), <span class="py-src-number">30</span>, <span class="py-src-number">50</span>)          <span class="py-src-comment"># the door</span>
<span class="py-src-variable">Box</span>((<span class="py-src-number">40</span>, <span class="py-src-number">80</span>), <span class="py-src-number">20</span>, <span class="py-src-number">20</span>)          <span class="py-src-comment"># the left window</span>
<span class="py-src-variable">Box</span>((<span class="py-src-number">80</span>, <span class="py-src-number">80</span>), <span class="py-src-number">20</span>, <span class="py-src-number">20</span>)          <span class="py-src-comment"># the right window</span>
<span class="py-src-variable">Line</span>((<span class="py-src-number">20</span>, <span class="py-src-number">120</span>), (<span class="py-src-number">70</span>, <span class="py-src-number">160</span>))     <span class="py-src-comment"># the left roof</span>
<span class="py-src-variable">Line</span>((<span class="py-src-number">70</span>, <span class="py-src-number">160</span>), (<span class="py-src-number">120</span>, <span class="py-src-number">120</span>))    <span class="py-src-comment"># the right roof</span>

<span class="py-src-variable">pause</span>()                        <span class="py-src-comment"># keep the canvas open until a key is pressed</span>
<span class="py-src-variable">end_graphics</span>()                 <span class="py-src-comment"># close the canvas (which would happen anyway,</span>
                               <span class="py-src-comment"># since the script ends here, but it is better
</span>                               <span class="py-src-comment"># to be explicit).
</span></pre><ul><li>Run this script and confirm that you get a window that looks like this:
  <br /><img src="illustrations/gasp02.png" alt="Gasp illustration 2" /><br /></li><li>Wrap the house code in a function named <code>draw_house()</code>.</li><li>Run the script now.  Do you see a house?  Why not?</li><li>Add a call to <code>draw_house()</code> at the botton of the script so
  that the house returns to the screen.</li><li><em>Parameterize</em> the function with x and y parameters
  -- the header should then become <code>def draw_house(x, y):</code>, so that
  you can pass in the location of the house on the canvas.</li><li>Use <code>draw_house</code> to place five houses on the canvas in
  different locations.</li></ul></div></li></ol></div><p><a href="index.xhtml">Table of Contents</a> |
    <a href="dex.html">Index</a></p></body></html>