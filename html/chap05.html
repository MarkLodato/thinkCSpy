<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>How to Think Like a Computer Scientist: 5. Fruitful functions</title><link href="stylesheet.css" type="text/css" rel="stylesheet" /></head><body bgcolor="white"><h1 class="title">5. Fruitful functions</h1><div class="toc"><ol><li><a href="#auto0">Return values</a></li><li><a href="#auto1">Program development</a></li><li><a href="#auto2">Composition</a></li><li><a href="#auto3">Boolean functions</a></li><li><a href="#auto4">More recursion</a></li><li><a href="#auto5">Leap of faith</a></li><li><a href="#auto6">One more example</a></li><li><a href="#auto7">Checking types</a></li><li><a href="#auto8">Glossary</a></li><li><a href="#auto9">Exercises</a></li></ol></div><div class="content"><span></span><h2>5.1 Return values<a name="auto0"></a></h2><a name="index01"></a><p>Some of the built-in functions we have used, such as the math functions,
have produced results.  Calling the function generates a new value, which we
usually assign to a variable or use as part of an expression.</p><pre class="python">
<span class="py-src-variable">e</span> = <span class="py-src-variable">math</span>.<span class="py-src-variable">exp</span>(<span class="py-src-number">1.0</span>)
<span class="py-src-variable">height</span> = <span class="py-src-variable">radius</span> * <span class="py-src-variable">math</span>.<span class="py-src-variable">sin</span>(<span class="py-src-variable">angle</span>)
</pre><p>But so far, none of the functions we have written has returned a value.</p><p>In this chapter, we are going to write functions that return values, which
we will call <b>fruitful functions</b>, for want of a better name.
The first example is <code>area</code>, which returns the area of a circle with 
the given radius:</p><pre class="python">
<span class="py-src-keyword">import</span> <span class="py-src-variable">math</span>
   
<span class="py-src-keyword">def</span> <span class="py-src-identifier">area</span>(<span class="py-src-parameter">radius</span>):
    <span class="py-src-variable">temp</span> = <span class="py-src-variable">math</span>.<span class="py-src-variable">pi</span> * <span class="py-src-variable">radius</span>**<span class="py-src-number">2</span>
    <span class="py-src-keyword">return</span> <span class="py-src-variable">temp</span>
</pre><p>We have seen the <code>return</code> statement before, but in a fruitful
function the <code>return</code> statement includes a
<b>return value</b>.  This statement means: <q>Return immediately
from this function and use the following expression as a return value.</q>
The expression provided can be arbitrarily complicated, so we could have
written this function more concisely:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">area</span>(<span class="py-src-parameter">radius</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">math</span>.<span class="py-src-variable">pi</span> * <span class="py-src-variable">radius</span>**<span class="py-src-number">2</span>
</pre><p>On the other hand, <b>temporary variables</b> like
<code>temp</code> often make debugging easier.</p><a name="index02"></a><a name="index03"></a><p>Sometimes it is useful to have multiple return statements, one in each
branch of a conditional:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">absolute_value</span>(<span class="py-src-parameter">x</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">x</span> &lt; <span class="py-src-number">0</span>:
        <span class="py-src-keyword">return</span> -<span class="py-src-variable">x</span>
    <span class="py-src-keyword">else</span>:
        <span class="py-src-keyword">return</span> <span class="py-src-variable">x</span>
</pre><p>Since these <code>return</code> statements are in an alternative
conditional, only one will be executed.  As soon as one is executed, the
function terminates without executing any subsequent statements.</p><p>Code that appears after a <code>return</code> statement, or any other place
the flow of execution can never reach, is called <b>dead code</b>.
</p><a name="index04"></a><p>In a fruitful function, it is a good idea to ensure that every possible path 
through the program hits a <code>return</code> statement.  For example:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">absolute_value</span>(<span class="py-src-parameter">x</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">x</span> &lt; <span class="py-src-number">0</span>:
        <span class="py-src-keyword">return</span> -<span class="py-src-variable">x</span>
    <span class="py-src-keyword">elif</span> <span class="py-src-variable">x</span> &gt; <span class="py-src-number">0</span>:
        <span class="py-src-keyword">return</span> <span class="py-src-variable">x</span>
</pre><p>This program is not correct because if <code>x</code> happens to be 0,
neither condition is true, and the function ends without hitting a
<code>return</code> statement.  In this case, the return value is a special
value called <code>None</code>:</p><a name="index05"></a><pre class="python-interpreter">
&gt;&gt;&gt; print absolute_value(0)
None
</pre><p><code>None</code> is the unique value of a type called the
<code>NoneType</code>:
</p><pre class="python-interpreter">
&gt;&gt;&gt; type(None)
&lt;type 'NoneType'&gt;
</pre><h2>5.2 Program development<a name="auto1"></a></h2><a name="program development"></a><a name="index06"></a><p>At this point, you should be able to look at complete functions and tell
what they do.  Also, if you have been doing the exercises, you have written
some small functions.  As you write larger functions, you might start to have
more difficulty, especially with runtime and semantic errors.</p><p>To deal with increasingly complex programs, we are going to suggest a
technique called <b>incremental development</b>.  The goal of
incremental development is to avoid long debugging sessions by adding and
testing only a small amount of code at a time.</p><a name="index07"></a><a name="index08"></a><p>As an example, suppose you want to find the distance between two points,
given by the coordinates (x<sub>1</sub>, y<sub>1</sub>) and
(x<sub>2</sub>, y<sub>2</sub>).  By the Pythagorean theorem, the distance
is:</p><p>
distance = sqrt((x<sub>2</sub> - x<sub>1</sub>)<sup>2</sup> +
(y<sub>2</sub> - y<sub>1</sub>)<sup>2</sup>)
</p><p>The first step is to consider what a <code>distance</code> function should
look like in Python. In other words, what are the inputs (parameters) and what
is the output (return value)?</p><p>In this case, the two points are the inputs, which we can represent using
four parameters.  The return value is the distance, which is a floating-point
value.</p><p>Already we can write an outline of the function:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">distance</span>(<span class="py-src-parameter">x1</span>, <span class="py-src-parameter">y1</span>, <span class="py-src-parameter">x2</span>, <span class="py-src-parameter">y2</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-number">0.0</span>
</pre><p>Obviously, this version of the function doesn't compute distances; it
always returns zero.  But it is syntactically correct, and it will run, which
means that we can test it before we make it more complicated.</p><p>To test the new function, we call it with sample values:</p><pre class="python-interpreter">
&gt;&gt;&gt; distance(1, 2, 4, 6)
0.0
</pre><p>We chose these values so that the horizontal distance equals 3 and the
vertical distance equals 4; that way, the result is 5
(the hypotenuse of a 3-4-5 triangle). When testing a function, it is useful to
know the right answer.</p><p>At this point we have confirmed that the function is syntactically
correct, and we can start adding lines of code.  After each incremental change, 
we test the function again.  If an error occurs at any point, we know where it
must be---in the last line we added.</p><p>A logical first step in the computation is to find the differences
x<sub>2</sub> - x<sub>1</sub> and y<sub>2</sub> - y<sub>1</sub>.  We will
store those values in temporary variables named <code>dx</code> and
<code>dy</code> and print them.</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">distance</span>(<span class="py-src-parameter">x1</span>, <span class="py-src-parameter">y1</span>, <span class="py-src-parameter">x2</span>, <span class="py-src-parameter">y2</span>):
    <span class="py-src-variable">dx</span> = <span class="py-src-variable">x2</span> - <span class="py-src-variable">x1</span>
    <span class="py-src-variable">dy</span> = <span class="py-src-variable">y2</span> - <span class="py-src-variable">y1</span>
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;dx is&quot;</span>, <span class="py-src-variable">dx</span>
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;dy is&quot;</span>, <span class="py-src-variable">dy</span>
    <span class="py-src-keyword">return</span> <span class="py-src-number">0.0</span>
</pre><p>If the function is working, the outputs should be 3 and 4.  If so, we know
that the function is getting the right parameters and performing the first
computation correctly.  If not, there are only a few lines to check.</p><p>Next we compute the sum of squares of <code>dx</code> and
<code>dy</code>:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">distance</span>(<span class="py-src-parameter">x1</span>, <span class="py-src-parameter">y1</span>, <span class="py-src-parameter">x2</span>, <span class="py-src-parameter">y2</span>):
    <span class="py-src-variable">dx</span> = <span class="py-src-variable">x2</span> - <span class="py-src-variable">x1</span>
    <span class="py-src-variable">dy</span> = <span class="py-src-variable">y2</span> - <span class="py-src-variable">y1</span>
    <span class="py-src-variable">dsquared</span> = <span class="py-src-variable">dx</span>**<span class="py-src-number">2</span> + <span class="py-src-variable">dy</span>**<span class="py-src-number">2</span>
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;dsquared is: &quot;</span>, <span class="py-src-variable">dsquared</span>
    <span class="py-src-keyword">return</span> <span class="py-src-number">0.0</span>
</pre><p>Notice that we removed the <code>print</code> statements we wrote in the
previous step.  Code like that is called <b>scaffolding</b> because
it is helpful for building the program but is not part of the final product.
</p><p>Again, we would run the program at this stage and check the output
(which should be 25).</p><p>Finally, if we have imported the math module, we can use the
<code>sqrt</code> function to compute and return the result:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">distance</span>(<span class="py-src-parameter">x1</span>, <span class="py-src-parameter">y1</span>, <span class="py-src-parameter">x2</span>, <span class="py-src-parameter">y2</span>):
    <span class="py-src-variable">dx</span> = <span class="py-src-variable">x2</span> - <span class="py-src-variable">x1</span>
    <span class="py-src-variable">dy</span> = <span class="py-src-variable">y2</span> - <span class="py-src-variable">y1</span>
    <span class="py-src-variable">dsquared</span> = <span class="py-src-variable">dx</span>**<span class="py-src-number">2</span> + <span class="py-src-variable">dy</span>**<span class="py-src-number">2</span>
    <span class="py-src-variable">result</span> = <span class="py-src-variable">math</span>.<span class="py-src-variable">sqrt</span>(<span class="py-src-variable">dsquared</span>)
    <span class="py-src-keyword">return</span> <span class="py-src-variable">result</span>
</pre><p>If that works correctly, you are done.  Otherwise, you might want to print
the value of <code>result</code> before the return statement.</p><p>When you start out, you should add only a line or two of code at a time.  As
you gain more experience, you might find yourself writing and debugging bigger
chunks.  Either way, the incremental development process can save you a lot of
debugging time.</p><p>The key aspects of the process are:</p><ol><li>Start with a working program and make small incremental changes.  At any
point, if there is an error, you will know exactly where it is.</li><li>Use temporary variables to hold intermediate values so you can output and
check them.</li><li>Once the program is working, you might want to remove some of the
scaffolding or consolidate multiple statements into compound expressions, but
only if it does not make the program difficult to read.</li></ol><h2>5.3 Composition<a name="auto2"></a></h2><a name="index09"></a><a name="index10"></a><p>As you should expect by now, you can call one function from within another.  
This ability is called <b>composition</b>.</p><p>As an example, we'll write a function that takes two points, the center of
the circle and a point on the perimeter, and computes the area of the circle.
</p><p>Assume that the center point is stored in the variables <code>xc</code> and
<code>yc</code>, and the perimeter point is in <code>xp</code> and
<code>yp</code>. The first step is to find the radius of the circle, which is
the distance between the two points.  Fortunately, there is a function,
<code>distance</code>, that does that:</p><pre class="python">
<span class="py-src-variable">radius</span> = <span class="py-src-variable">distance</span>(<span class="py-src-variable">xc</span>, <span class="py-src-variable">yc</span>, <span class="py-src-variable">xp</span>, <span class="py-src-variable">yp</span>)
</pre><p>The second step is to find the area of a circle with that radius and return
it:</p><pre class="python">
<span class="py-src-variable">result</span> = <span class="py-src-variable">area</span>(<span class="py-src-variable">radius</span>)
<span class="py-src-keyword">return</span> <span class="py-src-variable">result</span>
</pre><p>Wrapping that up in a function, we get:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">area2</span>(<span class="py-src-parameter">xc</span>, <span class="py-src-parameter">yc</span>, <span class="py-src-parameter">xp</span>, <span class="py-src-parameter">yp</span>):
    <span class="py-src-variable">radius</span> = <span class="py-src-variable">distance</span>(<span class="py-src-variable">xc</span>, <span class="py-src-variable">yc</span>, <span class="py-src-variable">xp</span>, <span class="py-src-variable">yp</span>)
    <span class="py-src-variable">result</span> = <span class="py-src-variable">area</span>(<span class="py-src-variable">radius</span>)
    <span class="py-src-keyword">return</span> <span class="py-src-variable">result</span>
</pre><p>We called this function <code>area2</code> to distinguish it from the
<code>area</code> function defined earlier.  There can only be one function
with a given name within a given module.</p><p>The temporary variables <code>radius</code> and <code>result</code> are
useful for development and debugging, but once the program is working, we can
make it more concise by composing the function calls:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">area2</span>(<span class="py-src-parameter">xc</span>, <span class="py-src-parameter">yc</span>, <span class="py-src-parameter">xp</span>, <span class="py-src-parameter">yp</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">area</span>(<span class="py-src-variable">distance</span>(<span class="py-src-variable">xc</span>, <span class="py-src-variable">yc</span>, <span class="py-src-variable">xp</span>, <span class="py-src-variable">yp</span>))
</pre><h2>5.4 Boolean functions<a name="auto3"></a></h2><a name="boolean"></a><a name="index11"></a><a name="index12"></a><p>Functions can return boolean values, which is often convenient for hiding
complicated tests inside functions.  For example:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">is_divisible</span>(<span class="py-src-parameter">x</span>, <span class="py-src-parameter">y</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">x</span> % <span class="py-src-variable">y</span> == <span class="py-src-number">0</span>:
        <span class="py-src-keyword">return</span> <span class="py-src-variable">True</span> 
    <span class="py-src-keyword">else</span>:
        <span class="py-src-keyword">return</span> <span class="py-src-variable">False</span>
</pre><p>The name of this function is <code>is_divisible</code>.  It is common to give
boolean functions names that sound like yes/no questions.
<code>is_divisible</code> returns either <code>True</code> or <code>False</code> 
to indicate whether the <code>x</code> is or is not divisible by <code>y</code>.
</p><p>We can make the function more concise by taking advantage of the fact that
the condition of the <code>if</code> statement is itself a boolean expression.  
We can return it directly, avoiding the <code>if</code> statement altogether:
</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">is_divisible</span>(<span class="py-src-parameter">x</span>, <span class="py-src-parameter">y</span>):
    <span class="py-src-keyword">return</span> <span class="py-src-variable">x</span> % <span class="py-src-variable">y</span> == <span class="py-src-number">0</span>
</pre><p>This session shows the new function in action:</p><pre class="python-interpreter">
&gt;&gt;&gt;   is_divisible(6, 4)
False
&gt;&gt;&gt;   is_divisible(6, 3)
True
</pre><p>Boolean functions are often used in conditional statements:</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">is_divisible</span>(<span class="py-src-variable">x</span>, <span class="py-src-variable">y</span>):
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;x is divisible by y&quot;</span>
<span class="py-src-keyword">else</span>:
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;x is not divisible by y&quot;</span>
</pre><p>It might be tempting to write something like:</p><pre class="python">
<span class="py-src-keyword">if</span> <span class="py-src-variable">is_divisible</span>(<span class="py-src-variable">x</span>, <span class="py-src-variable">y</span>) == <span class="py-src-variable">True</span>:
</pre><p>But the extra comparison is unnecessary.</p><h2>5.5 More recursion<a name="auto4"></a></h2><a name="index13"></a><a name="index14"></a><a name="index15"></a><a name="index16"></a><a name="index17"></a><p>So far, you have only learned a small subset of Python, but you might
be interested to know that this subset is a <em>complete</em> programming
language, which means that anything that can be computed can be expressed in
this language.  Any program ever written could be rewritten using only the
language features you have learned so far (actually, you would need a few
commands to control devices like the keyboard, mouse, disks, etc., but that's
all).</p><p>Proving that claim is a nontrivial exercise first accomplished by Alan
Turing, one of the first computer scientists (some would argue that he was a
mathematician, but a lot of early computer scientists started as
mathematicians).  Accordingly, it is known as the Turing Thesis.  If you take a 
course on the Theory of Computation, you will have a chance to see the proof.
</p><p>To give you an idea of what you can do with the tools you have learned so
far, we'll evaluate a few recursively defined mathematical functions.  A
recursive definition is similar to a circular definition, in the sense that the 
definition contains a reference to the thing being defined.  A truly circular
definition is not very useful:</p><dl><dt>frabjuous:</dt><dd>An adjective used to describe something that is frabjuous.</dd></dl><a name="index18"></a><a name="index19"></a><a name="index20"></a><p>If you saw that definition in the dictionary, you might be annoyed. On the
other hand, if you looked up the definition of the mathematical function
factorial, you might get something like this:</p><pre>
    0! = 1
    n! = n (n-1)!
</pre><p>This definition says that the factorial of 0 is 1, and the factorial
of any other value, n, is n multiplied by the factorial of n-1.</p><p>So 3! is 3 times 2!, which is 2 times 1!, which is 1 times 0!. Putting it
all together, 3! equals 3 times 2 times 1 times 1, which is 6.</p><a name="index21"></a><a name="index22"></a><p>If you can write a recursive definition of something, you can usually write
a Python program to evaluate it. The first step is to decide what the
parameters are for this function.  With little effort, you should conclude that 
<code>factorial</code> takes a single parameter:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">factorial</span>(<span class="py-src-parameter">n</span>):
</pre><p>If the argument happens to be 0, all we have to do is return 1:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">factorial</span>(<span class="py-src-parameter">n</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">n</span> == <span class="py-src-number">0</span>:
        <span class="py-src-keyword">return</span> <span class="py-src-number">1</span>
</pre><p>Otherwise, and this is the interesting part, we have to make a recursive
call to find the factorial of n-1 and then multiply it by n:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">factorial</span>(<span class="py-src-parameter">n</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">n</span> == <span class="py-src-number">0</span>:
        <span class="py-src-keyword">return</span> <span class="py-src-number">1</span>
    <span class="py-src-keyword">else</span>:
        <span class="py-src-variable">recurse</span> = <span class="py-src-variable">factorial</span>(<span class="py-src-variable">n</span>-<span class="py-src-number">1</span>)
        <span class="py-src-variable">result</span> = <span class="py-src-variable">n</span> * <span class="py-src-variable">recurse</span>
        <span class="py-src-keyword">return</span> <span class="py-src-variable">result</span>
</pre><p>The flow of execution for this program is similar to the flow of
<code>countdown</code>in the last chapter.  If we call <code>factorial</code>
with the value 3:</p><blockquote>
Since 3 is not 0, we take the second branch and calculate the factorial
of <code>n-1</code>...

<blockquote>
Since 2 is not 0, we take the second branch and calculate the factorial of
<code>n-1</code>...

<blockquote>
Since 1 is not 0, we take the second branch and calculate the factorial
of <code>n-1</code>...

<blockquote>
Since 0 <em>is</em> 0, we take the first branch and return 1 without making
any more recursive calls.
</blockquote>

The return value (1) is multiplied by <code>n</code>, which is 1, and the
result is returned.
</blockquote>

The return value (1) is multiplied by <code>n</code>, which is 2, and the
result is returned.
</blockquote>

The return value (2) is multiplied by <code>n</code>, which is 3, and the
result, 6, becomes the return value of the function call that started the whole
process.
</blockquote><p>Here is what the stack diagram looks like for this sequence of function
calls:</p><img src="illustrations/stack3.png" /><p>The return values are shown being passed back up the stack.  In each frame,
the return value is the value of <code>result</code>, which is the product of
<code>n</code> and <code>recurse</code>.</p><p>Notice that in the last frame, the local variables <code>recurse</code> and
<code>result</code> do not exist, because the branch that creates them did not
execute.</p><h2>5.6 Leap of faith<a name="auto5"></a></h2><a name="index23"></a><a name="index24"></a><p>Following the flow of execution is one way to read programs, but it can
quickly become labyrinthine.  An alternative is what we call the <q>leap of
faith.</q> When you come to a function call, instead of following the flow of
execution, you <em>assume</em> that the function works correctly and returns
the appropriate value.</p><p>In fact, you are already practicing this leap of faith when you use built-in 
functions.  When you call <code>math.cos</code> or <code>math.exp</code>, you
don't examine the implementations of those functions.  You just assume that
they work because the people who wrote the built-in libraries were good
programmers.</p><p>The same is true when you call one of your own functions.  For example,
we wrote the function <code>is_divisible</code> that determines whether one
number is divisible by another.  Once we have convinced ourselves that this
function is correct---by testing and examining the code---we can use the
function without looking at the code again.</p><p>The same is true of recursive programs.  When you get to the recursive call, 
instead of following the flow of execution, you should assume that the
recursive call works (yields the correct result) and then ask yourself,
<q>Assuming that I can find the factorial of <code>n-1</code>, can I compute
the factorial of <code>n</code>?</q>  In this case, it is clear that you can,
by multiplying by <code>n</code>.</p><p>Of course, it's a bit strange to assume that the function works correctly
when you haven't finished writing it, but that's why it's called a leap of
faith!</p><h2>5.7 One more example<a name="auto6"></a></h2><a name="one more example"></a><p>In the previous example, we used temporary variables to spell out the steps
and to make the code easier to debug, but we could have saved a few lines:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">factorial</span>(<span class="py-src-parameter">n</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">n</span> == <span class="py-src-number">0</span>:
        <span class="py-src-keyword">return</span> <span class="py-src-number">1</span>
    <span class="py-src-keyword">else</span>:
        <span class="py-src-keyword">return</span> <span class="py-src-variable">n</span> * <span class="py-src-variable">factorial</span>(<span class="py-src-variable">n</span>-<span class="py-src-number">1</span>)
</pre><p>From now on, we will tend to use the more concise form, but we recommend
that you use the more explicit version while you are developing code.  When you 
have it working, you can tighten it up if you are feeling inspired.</p><a name="index25"></a><p>After <code>factorial</code>, the most common example of a recursively
defined mathematical function is <code>fibonacci</code>, which has the
following definition:</p><pre>
   fibonacci(0) = 1
   fibonacci(1) = 1
   fibonacci(n) = fibonacci(n-1) + fibonacci(n-2);
</pre><p>Translated into Python, it looks like this:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">fibonacci</span>(<span class="py-src-parameter">n</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">n</span> == <span class="py-src-number">0</span> <span class="py-src-keyword">or</span> <span class="py-src-variable">n</span> == <span class="py-src-number">1</span>:
        <span class="py-src-keyword">return</span> <span class="py-src-number">1</span>
    <span class="py-src-keyword">else</span>:
        <span class="py-src-keyword">return</span> <span class="py-src-variable">fibonacci</span>(<span class="py-src-variable">n</span>-<span class="py-src-number">1</span>) + <span class="py-src-variable">fibonacci</span>(<span class="py-src-variable">n</span>-<span class="py-src-number">2</span>)
</pre><p>If you try to follow the flow of execution here, even for fairly small
values of <code>n</code>, your head explodes.  But according to the leap of
faith, if you assume that the two recursive calls work correctly, then it is
clear that you get the right result by adding them together.</p><h2>5.8 Checking types<a name="auto7"></a></h2><a name="index26"></a><a name="index27"></a><a name="index28"></a><p>What happens if we call <code>factorial</code> and give it 1.5 as an
argument?</p><pre class="python-interpreter">
&gt;&gt;&gt; factorial (1.5)
...
RuntimeError: maximum recursion depth exceeded in cmp
</pre><p>It looks like an infinite recursion.  But how can that be?  There is a base
case---when <code>n == 0</code>.  The problem is that the values of
<code>n</code><em>miss</em> the base case.</p><a name="index29"></a><a name="index30"></a><p>In the first recursive call, the value of <code>n</code> is 0.5.  In the
next, it is -0.5.  From there, it gets smaller and smaller, but it will never
be 0.</p><p>We have two choices.  We can try to generalize the <code>factorial</code>
function to work with floating-point numbers, or we can make
<code>factorial</code> check the type of its parameter.  The first option is
called the gamma function and it's a little beyond the scope of this book.  So
we'll go for the second.</p><a name="index31"></a><p>We can use <code>type</code> to compare the type of the parameter to the
type we are expecting.  While we're at it, we also make sure the parameter is
positive:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">factorial</span>(<span class="py-src-parameter">n</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">type</span>(<span class="py-src-variable">n</span>) != <span class="py-src-variable">int</span>:
        <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Factorial is only defined for integers.&quot;</span>
        <span class="py-src-keyword">return</span> -<span class="py-src-number">1</span>
    <span class="py-src-keyword">if</span> <span class="py-src-variable">n</span> &lt; <span class="py-src-number">0</span>:
        <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;Factorial is only defined for positive integers.&quot;</span>
        <span class="py-src-keyword">return</span> -<span class="py-src-number">1</span>
    <span class="py-src-keyword">if</span> <span class="py-src-variable">n</span> == <span class="py-src-number">0</span>:
        <span class="py-src-keyword">return</span> <span class="py-src-number">1</span>
    <span class="py-src-keyword">else</span>:
        <span class="py-src-keyword">return</span> <span class="py-src-variable">n</span> * <span class="py-src-variable">factorial</span>(<span class="py-src-variable">n</span>-<span class="py-src-number">1</span>)
</pre><p>Now we have three base cases.  The first catches nonintegers.  The second
catches negative integers.  In both cases, the program prints an error message
and returns a special value, -1, to indicate that something went wrong:</p><pre class="python-interpreter">
&gt;&gt;&gt; factorial(&quot;fred&quot;)
Factorial is only defined for integers.
-1
&gt;&gt;&gt; factorial(-2)
Factorial is only defined for positive integers.
-1
</pre><p>If we get past both checks, then we know that <code>n</code> is a positive
integer, and we can prove that the recursion terminates.</p><p>This program demonstrates a pattern sometimes called a
<b>guardian</b>.  The first two conditionals act as guardians,
protecting the code that follows from values that might cause an error.  The
guardians make it possible to prove the correctness of the code.</p><h2>5.9 Glossary<a name="auto8"></a></h2><a name="index32"></a><a name="index33"></a><a name="index34"></a><a name="index35"></a><a name="index36"></a><a name="index37"></a><a name="index38"></a><a name="index39"></a><dl><dt>fruitful function:</dt><dd>A function that yields a return value.</dd><dt>return value:</dt><dd>The value provided as the result of a function call.</dd><dt>temporary variable:</dt><dd>A variable used to store an intermediate value in a complex calculation.
</dd><dt>dead code:</dt><dd>Part of a program that can never be executed, often because it appears
after a <code>return</code> statement.</dd><dt><code>None</code>:</dt><dd>A special Python value returned by functions that have no return statement, 
or a return statement without an argument.</dd><dt>incremental development:</dt><dd>A program development plan intended to avoid debugging by adding and
testing only a small amount of code at a time.</dd><dt>scaffolding:</dt><dd>Code that is used during program development but is not part of the final
version.</dd><dt>guardian:</dt><dd>A condition that checks for and handles circumstances that might cause an
error.</dd></dl><h2>5.10 Exercises<a name="auto9"></a></h2><ol><li><div class="exercise">
Write a <code>compare</code> function that returns <code>1</code> if
<code>x &gt; y</code>, <code>0</code> if <code>x == y</code>, and
<code>-1</code> if <code>x &lt; y</code>.
</div></li><li><div class="exercise">
Use incremental development to write a function called <code>hypotenuse</code>
that returns the length of the hypotenuse of a right triangle given the lengths 
of the two legs as parameters.  Record each stage of the incremental
development process as you go.
</div></li><li><div class="exercise">
Write a function <code>slope(x1, y1, x2, y2)</code> that returns the slope of
the line through the points (x1, y1) and (x2, y2).  Then use this function in a 
function called <code>intercept(x1, y1, x2, y2)</code> that returns the
y-intercept of the line through the points <code>(x1, y1)</code> and
<code>(x2, y2)</code>.
</div></li><li><div class="exercise">
Write a function called <code>isEven</code> that takes an integer as an
argument and returns <code>True</code> if the argument is an <b>even number</b>
and <code>False</code> if it is <b>odd</b>.
</div></li><li><div class="exercise">
Now write the function <code>isOdd</code> so that it uses a call to
<code>isEven</code> to determine if its argument is an <b>odd integer</b>.
</div></li><li><div class="exercise">
Write a function, <code>isFactor</code>, with two parameters, <code>n</code>
and <code>f</code>, which returns <code>True</code> when <code>f</code> is
a <b>factor</b> of <code>n</code>, and <code>False</code> otherwise.
</div></li><li><div class="exercise">
Write a function, <code>isMultiple</code>, with two parameters, <code>n</code>
and <code>m</code>, which returns <code>True</code> when <code>m</code> is
a <b>multiple</b> of <code>n</code>, and <code>False</code> otherwise.
</div></li><li><div class="exercise">
As an exercise, write a function <code>isBetween(x, y, z)</code> that
returns <code>True</code> if y &lt; x &lt; z or <code>False</code> otherwise.
</div></li></ol></div><p><a href="index.html">Table of Contents</a> |
    <a href="dex.html">Index</a></p></body></html>