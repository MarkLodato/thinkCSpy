<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>How to Think Like a Computer Scientist: 17. Linked lists</title><link href="stylesheet.css" type="text/css" rel="stylesheet" /></head><body bgcolor="white"><h1 class="title">17. Linked lists</h1><div class="toc"><ol><li><a href="#auto0">Embedded references</a></li><li><a href="#auto1">The Node class</a></li><li><a href="#auto2">Lists as collections</a></li><li><a href="#auto3">Lists and recursion</a></li><li><a href="#auto4">Infinite lists</a></li><li><a href="#auto5">The fundamental ambiguity theorem</a></li><li><a href="#auto6">Modifying lists</a></li><li><a href="#auto7">Wrappers and helpers</a></li><li><a href="#auto8">The LinkedList class</a></li><li><a href="#auto9">Invariants</a></li><li><a href="#auto10">Glossary</a></li><li><a href="#auto11">Exercises</a></li></ol></div><div class="content"><span></span><a name="list"></a><a name="index01"></a><h2>17.1 Embedded references<a name="auto0"></a></h2><a name="index02"></a><a name="index03"></a><a name="index04"></a><a name="index05"></a><a name="index06"></a><a name="index07"></a><a name="index08"></a><p>We have seen examples of attributes that refer to other objects, which we
called <b>embedded references</b>.  A common data structure, the
<b>linked list</b>, takes advantage of this feature.</p><p>Linked lists are made up of <b>nodes</b>, where each node contains 
a reference to the next node in the list.  In addition, each node contains a
unit of data called the <b>cargo</b>.</p><p>A linked list is considered a <b>recursive data structure</b>
because it has a recursive definition.</p><p>A linked list is either:</p><ol><li>the empty list, represented by <code>None</code>, or</li><li>a node that contains a cargo object and a reference to a linked list.</li></ol><a name="index09"></a><a name="index10"></a><p>Recursive data structures lend themselves to recursive methods.</p><h2>17.2 The <code>Node</code> class<a name="auto1"></a></h2><a name="index11"></a><a name="index12"></a><p>As usual when writing a new class, we'll start with the initialization and
<code>__str__</code> methods so that we can test the basic mechanism of
creating and displaying the new type:</p><pre class="python">
<span class="py-src-keyword">class</span> <span class="py-src-identifier">Node</span>:
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">__init__</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">cargo</span>=<span class="py-src-parameter">None</span>, <span class="py-src-parameter">next</span>=<span class="py-src-parameter">None</span>):
        <span class="py-src-variable">self</span>.<span class="py-src-variable">cargo</span> = <span class="py-src-variable">cargo</span>
        <span class="py-src-variable">self</span>.<span class="py-src-variable">next</span>  = <span class="py-src-variable">next</span>
   
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">__str__</span>(<span class="py-src-parameter">self</span>):
        <span class="py-src-keyword">return</span> <span class="py-src-variable">str</span>(<span class="py-src-variable">self</span>.<span class="py-src-variable">cargo</span>)
</pre><p>As usual, the parameters for the initialization method are optional. By
default, both the cargo and the link, <code>next</code>, are set to
<code>None</code>.</p><p>The string representation of a node is just the string representation of the 
cargo.  Since any value can be passed to the <code>str</code> function, we can
store any value in a list.</p><p>To test the implementation so far, we can create a <code>Node</code> and
print it:</p><pre class="python-interpreter">
&gt;&gt;&gt; node = Node(&quot;test&quot;)
&gt;&gt;&gt; print node
test
</pre><p>To make it interesting, we need a list with more than one node:</p><pre class="python-interpreter">
&gt;&gt;&gt; node1 = Node(1)
&gt;&gt;&gt; node2 = Node(2)
&gt;&gt;&gt; node3 = Node(3)
</pre><p>This code creates three nodes, but we don't have a list yet because the
nodes are not <b>linked</b>.  The state diagram looks like this:</p><img src="illustrations/link1.png" /><p>To link the nodes, we have to make the first node refer to the second and
the second node refer to the third:</p><pre class="python-interpreter">
&gt;&gt;&gt; node1.next = node2
&gt;&gt;&gt; node2.next = node3
</pre><p>The reference of the third node is <code>None</code>, which indicates that
it is the end of the list.  Now the state diagram looks like this:</p><img src="illustrations/link2.png" /><p>Now you know how to create nodes and link them into lists.  What might be
less clear at this point is why.</p><h2>17.3 Lists as collections<a name="auto2"></a></h2><a name="index13"></a><p>Lists are useful because they provide a way to assemble multiple objects
into a single entity, sometimes called a <b>collection</b>.  In the
example, the first node of the list serves as a reference to the entire list.
</p><a name="index14"></a><a name="index15"></a><p>To pass the list as a parameter, we only have to pass a reference to the
first node.  For example, the function <code>printList</code> takes a single
node as an argument.  Starting with the head of the list, it prints each node
until it gets to the end:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">printList</span>(<span class="py-src-parameter">node</span>):
    <span class="py-src-keyword">while</span> <span class="py-src-variable">node</span>:
        <span class="py-src-keyword">print</span> <span class="py-src-variable">node</span>,
        <span class="py-src-variable">node</span> = <span class="py-src-variable">node</span>.<span class="py-src-variable">next</span>
    <span class="py-src-keyword">print</span>
</pre><p>To invoke this method, we pass a reference to the first node:</p><pre class="python-interpreter">
&gt;&gt;&gt; printList(node1)
1 2 3
</pre><p>Inside <code>printList</code> we have a reference to the first node of the
list, but there is no variable that refers to the other nodes.  We have to use
the <code>next</code> value from each node to get to the next node.</p><p>To traverse a linked list, it is common to use a loop variable like
<code>node</code> to refer to each of the nodes in succession.</p><a name="index16"></a><a name="index17"></a><a name="index18"></a><p>This diagram shows the value of <code>list</code> and the values that
<code>node</code> takes on:</p><img src="illustrations/link3.png" /><h2>17.4 Lists and recursion<a name="auto3"></a></h2><a name="listrecursion"></a><a name="index19"></a><a name="index20"></a><p>It is natural to express many list operations using recursive methods.  For
example, the following is a recursive algorithm for printing a list backwards:
</p><ol><li>Separate the list into two pieces: the first node (called the head); and
the rest (called the tail).</li><li>Print the tail backward.</li><li>Print the head.</li></ol><p>Of course, Step 2, the recursive call, assumes that we have a way of
printing a list backward.  But if we assume that the recursive call works---
the leap of faith---then we can convince ourselves that this algorithm works.
</p><a name="index21"></a><a name="index22"></a><p>All we need are a base case and a way of proving that for any list, we will
eventually get to the base case.  Given the recursive definition of a list, a
natural base case is the empty list, represented by <code>None</code>:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">printBackward</span>(<span class="py-src-parameter">list</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">list</span> == <span class="py-src-variable">None</span>: <span class="py-src-keyword">return</span>
    <span class="py-src-variable">head</span> = <span class="py-src-variable">list</span>
    <span class="py-src-variable">tail</span> = <span class="py-src-variable">list</span>.<span class="py-src-variable">next</span>
    <span class="py-src-variable">printBackward</span>(<span class="py-src-variable">tail</span>)
    <span class="py-src-keyword">print</span> <span class="py-src-variable">head</span>,
</pre><p>The first line handles the base case by doing nothing.  The next two lines
split the list into <code>head</code> and <code>tail</code>.  The last two
lines print the list.  The comma at the end of the last line keeps Python from
printing a newline after each node.</p><p>We invoke this method as we invoked <code>printList</code>:</p><pre class="python-interpreter">
&gt;&gt;&gt; printBackward(node1)
3 2 1
</pre><p>The result is a backward list.</p><p>You might wonder why <code>printList</code> and <code>printBackward</code>
are functions and not methods in the <code>Node</code> class.  The reason is
that we want to use <code>None</code> to represent the empty list and it is not
legal to invoke a method on <code>None</code>.  This limitation makes it
awkward to write list-manipulating code in a clean object-oriented style.</p><p>Can we prove that <code>printBackward</code> will always terminate?  In
other words, will it always reach the base case?  In fact, the answer is no.
Some lists will make this method crash.</p><h2>17.5 Infinite lists<a name="auto4"></a></h2><a name="index23"></a><a name="index24"></a><a name="index25"></a><a name="index26"></a><p>There is nothing to prevent a node from referring back to an earlier node in 
the list, including itself.  For example, this figure shows a list with two
nodes, one of which refers to itself:</p><img src="illustrations/link4.png" /><p>If we invoke <code>printList</code> on this list, it will loop forever.  If
we invoke <code>printBackward</code>, it will recurse infinitely.  This sort of 
behavior makes infinite lists difficult to work with.</p><p>Nevertheless, they are occasionally useful.  For example, we might
represent a number as a list of digits and use an infinite list to represent a
repeating fraction.</p><p>Regardless, it is problematic that we cannot prove that
<code>printList</code> and <code>printBackward</code> terminate.  The best we
can do is the hypothetical statement, <q>If the list contains no loops, then
these methods will terminate.</q>  This sort of claim is called a
<b>precondition</b>.  It imposes a constraint on one of the
parameters and describes the behavior of the method if the constraint is
satisfied.  You will see more examples soon.</p><a name="index27"></a><h2>17.6 The fundamental ambiguity theorem<a name="auto5"></a></h2><a name="index28"></a><a name="index29"></a><p>One part of <code>printBackward</code> might have raised an eyebrow:</p><pre class="python">
<span class="py-src-variable">head</span> = <span class="py-src-variable">list</span>
<span class="py-src-variable">tail</span> = <span class="py-src-variable">list</span>.<span class="py-src-variable">next</span>
</pre><p>After the first assignment, <code>head</code> and <code>list</code> have the 
same type and the same value.  So why did we create a new variable?</p><p>The reason is that the two variables play different roles.  We think of
<code>head</code> as a reference to a single node, and we think of
<code>list</code> as a reference to the first node of a list.  These
<q>roles</q> are not part of the program; they are in the mind of the
programmer.</p><a name="index30"></a><a name="index31"></a><p>In general we can't tell by looking at a program what role a variable plays.
This ambiguity can be useful, but it can also make programs difficult to read.  
We often use variable names like <code>node</code> and <code>list</code> to
document how we intend to use a variable and sometimes create additional
variables to disambiguate.</p><p>We could have written <code>printBackward</code> without <code>head</code>
and <code>tail</code>, which makes it more concise but possibly less clear:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">printBackward</span>(<span class="py-src-parameter">list</span>) :
    <span class="py-src-keyword">if</span> <span class="py-src-variable">list</span> == <span class="py-src-variable">None</span> : <span class="py-src-keyword">return</span>
    <span class="py-src-variable">printBackward</span>(<span class="py-src-variable">list</span>.<span class="py-src-variable">next</span>)
    <span class="py-src-keyword">print</span> <span class="py-src-variable">list</span>,
</pre><p>Looking at the two function calls, we have to remember that
<code>printBackward</code> treats its argument as a collection and
<code>print</code> treats its argument as a single object.</p><p>The <b>fundamental ambiguity theorem</b> describes the ambiguity
that is inherent in a reference to a node:</p><blockquote><em>A variable that refers to a node might treat the node as a single object or 
as the first in a list of nodes.</em></blockquote><h2>17.7 Modifying lists<a name="auto6"></a></h2><a name="index32"></a><a name="index33"></a><p>There are two ways to modify a linked list.  Obviously, we can change the
cargo of one of the nodes, but the more interesting operations are the ones
that add, remove, or reorder the nodes.</p><p>As an example, let's write a method that removes the second node in the list 
and returns a reference to the removed node:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">removeSecond</span>(<span class="py-src-parameter">list</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">list</span> == <span class="py-src-variable">None</span>: <span class="py-src-keyword">return</span>
    <span class="py-src-variable">first</span> = <span class="py-src-variable">list</span>
    <span class="py-src-variable">second</span> = <span class="py-src-variable">list</span>.<span class="py-src-variable">next</span>
    <span class="py-src-comment"># make the first node refer to the third
</span>    <span class="py-src-variable">first</span>.<span class="py-src-variable">next</span> = <span class="py-src-variable">second</span>.<span class="py-src-variable">next</span>
    <span class="py-src-comment"># separate the second node from the rest of the list
</span>    <span class="py-src-variable">second</span>.<span class="py-src-variable">next</span> = <span class="py-src-variable">None</span>
    <span class="py-src-keyword">return</span> <span class="py-src-variable">second</span>
</pre><p>Again, we are using temporary variables to make the code more readable.
Here is how to use this method:</p><pre class="python-interpreter">
&gt;&gt;&gt; printList(node1)
1 2 3
&gt;&gt;&gt; removed = removeSecond(node1)
&gt;&gt;&gt; printList(removed)
2
&gt;&gt;&gt; printList(node1)
1 3
</pre><p>This state diagram shows the effect of the operation:</p><img src="illustrations/link5.png" /><p>What happens if you invoke this method and pass a list with only one element 
(a <b>singleton</b>)?  What happens if you pass the empty list as an
argument?  Is there a precondition for this method?  If so, fix the method to
handle a violation of the precondition in a reasonable way.</p><a name="index34"></a><h2>17.8 Wrappers and helpers<a name="auto7"></a></h2><a name="index35"></a><a name="index36"></a><a name="index37"></a><a name="index38"></a><p>It is often useful to divide a list operation into two methods.  For example,
to print a list backward in the conventional list format <code>[3, 2, 1]</code> 
we can use the <code>printBackward</code> method to print <code>3, 2,</code>
but we need a separate method to print the brackets and the first node.  Let's
call it <code>printBackwardNicely</code>:</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">printBackwardNicely</span>(<span class="py-src-parameter">list</span>) :
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;[&quot;</span>,
    <span class="py-src-keyword">if</span> <span class="py-src-variable">list</span> != <span class="py-src-variable">None</span> :
        <span class="py-src-variable">head</span> = <span class="py-src-variable">list</span>
        <span class="py-src-variable">tail</span> = <span class="py-src-variable">list</span>.<span class="py-src-variable">next</span>
        <span class="py-src-variable">printBackward</span>(<span class="py-src-variable">tail</span>)
        <span class="py-src-keyword">print</span> <span class="py-src-variable">head</span>,
    <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;]&quot;</span>,
</pre><p>Again, it is a good idea to check methods like this to see if they work with 
special cases like an empty list or a singleton.</p><a name="index39"></a><p>When we use this method elsewhere in the program, we invoke
<code>printBackwardNicely</code> directly, and it invokes
<code>printBackward</code> on our behalf.  In that sense,
<code>printBackwardNicely</code> acts as a <b>wrapper</b>, and it
uses <code>printBackward</code> as a <b>helper</b>.</p><h2>17.9 The <code>LinkedList</code> class<a name="auto8"></a></h2><a name="index40"></a><a name="index41"></a><p>There are some subtle problems with the way we have been implementing lists. 
In a reversal of cause and effect, we'll propose an alternative implementation
first and then explain what problems it solves.</p><p>First, we'll create a new class called <code>LinkedList</code>.  Its
attributes are an integer that contains the length of the list and a reference
to the first node.  <code>LinkedList</code> objects serve as handles for
manipulating lists of <code>Node</code> objects:</p><pre class="python">
<span class="py-src-keyword">class</span> <span class="py-src-identifier">LinkedList</span>:
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">__init__</span>(<span class="py-src-parameter">self</span>):
        <span class="py-src-variable">self</span>.<span class="py-src-variable">length</span> = <span class="py-src-number">0</span>
        <span class="py-src-variable">self</span>.<span class="py-src-variable">head</span>   = <span class="py-src-variable">None</span>
</pre><p>One nice thing about the <code>LinkedList</code> class is that it provides
a natural place to put wrapper functions like <code>printBackwardNicely</code>, 
which we can make a method of the <code>LinkedList</code> class:</p><pre class="python">
<span class="py-src-keyword">class</span> <span class="py-src-identifier">LinkedList</span>:
    ...
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">printBackward</span>(<span class="py-src-parameter">self</span>):
        <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;[&quot;</span>,
        <span class="py-src-keyword">if</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">head</span> != <span class="py-src-variable">None</span>:
            <span class="py-src-variable">self</span>.<span class="py-src-variable">head</span>.<span class="py-src-variable">printBackward</span>()
        <span class="py-src-keyword">print</span> <span class="py-src-string">&quot;]&quot;</span>,
   
<span class="py-src-keyword">class</span> <span class="py-src-identifier">Node</span>:
    ...
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">printBackward</span>(<span class="py-src-parameter">self</span>):
    <span class="py-src-keyword">if</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">next</span> != <span class="py-src-variable">None</span>:
        <span class="py-src-variable">tail</span> = <span class="py-src-variable">self</span>.<span class="py-src-variable">next</span>
        <span class="py-src-variable">tail</span>.<span class="py-src-variable">printBackward</span>()
    <span class="py-src-keyword">print</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">cargo</span>,
</pre><p>Just to make things confusing, we renamed <code>printBackwardNicely</code>.
Now there are two methods named <code>printBackward</code>: one in the
<code>Node</code> class (the helper); and one in the <code>LinkedList</code>
class (the wrapper).  When the wrapper invokes 
<code>self.head.printBackward</code>, it is invoking the helper, because 
<code>self.head</code> is a <code>Node</code> object.</p><p>Another benefit of the <code>LinkedList</code> class is that it makes it
easier to add or remove the first element of a list.  For example,
<code>addFirst</code> is a method for <code>LinkedList</code>s; it takes an
item of cargo as an argument and puts it at the beginning of the list:</p><pre class="python">
<span class="py-src-keyword">class</span> <span class="py-src-identifier">LinkedList</span>:
    ...
    <span class="py-src-keyword">def</span> <span class="py-src-identifier">addFirst</span>(<span class="py-src-parameter">self</span>, <span class="py-src-parameter">cargo</span>):
        <span class="py-src-variable">node</span> = <span class="py-src-variable">Node</span>(<span class="py-src-variable">cargo</span>)
        <span class="py-src-variable">node</span>.<span class="py-src-variable">next</span> = <span class="py-src-variable">self</span>.<span class="py-src-variable">head</span>
        <span class="py-src-variable">self</span>.<span class="py-src-variable">head</span> = <span class="py-src-variable">node</span>
        <span class="py-src-variable">self</span>.<span class="py-src-variable">length</span> = <span class="py-src-variable">self</span>.<span class="py-src-variable">length</span> + <span class="py-src-number">1</span>
</pre><p>As usual, you should check code like this to see if it handles the special
cases.  For example, what happens if the list is initially empty?</p><h2>17.10 Invariants<a name="auto9"></a></h2><a name="index42"></a><a name="index43"></a><a name="index44"></a><p>Some lists are <q>well formed</q>; others are not.  For example, if a list
contains a loop, it will cause many of our methods to crash, so we might want
to require that lists contain no loops.  Another requirement is that the
<code>length</code> value in the <code>LinkedList</code> object should be equal 
to the actual number of nodes in the list.</p><p>Requirements like these are called <b>invariants</b> because,
ideally, they should be true of every object all the time.  Specifying
invariants for objects is a useful programming practice because it makes it
easier to prove the correctness of code, check the integrity of data structures,
and detect errors.</p><p>One thing that is sometimes confusing about invariants is that there are
times when they are violated.  For example, in the middle of
<code>addFirst</code>, after we have added the node but before we have
incremented <code>length</code>, the invariant is violated.  This kind of
violation is acceptable; in fact, it is often impossible to modify an object
without violating an invariant for at least a little while.  Normally, we
require that every method that violates an invariant must restore the
invariant.</p><p>If there is any significant stretch of code in which the invariant is
violated, it is important for the comments to make that clear, so that no
operations are performed that depend on the invariant.</p><a name="index45"></a><h2>17.11 Glossary<a name="auto10"></a></h2><a name="index46"></a><a name="index47"></a><a name="index48"></a><a name="index49"></a><a name="index50"></a><a name="index51"></a><a name="index52"></a><a name="index53"></a><a name="index54"></a><a name="index55"></a><a name="index56"></a><a name="index57"></a><a name="index58"></a><a name="index59"></a><a name="index60"></a><dl><dt>embedded reference:</dt><dd>A reference stored in an attribute of an object.</dd><dt>linked list:</dt><dd>A data structure that implements a collection using a sequence of linked
nodes.</dd><dt>node:</dt><dd>An element of a list, usually implemented as an object that contains a
reference to another object of the same type.</dd><dt>cargo:</dt><dd>An item of data contained in a node.</dd><dt>link:</dt><dd>An embedded reference used to link one object to another.</dd><dt>precondition:</dt><dd>An assertion that must be true in order for a method to work correctly.</dd><dt>fundamental ambiguity theorem:</dt><dd>A reference to a list node can be treated as a single object or as the
first in a list of nodes.</dd><dt>singleton:</dt><dd>A linked list with a single node.</dd><dt>wrapper:</dt><dd>A method that acts as a middleman between a caller and a helper method,
often making the method easier or less error-prone to invoke.</dd><dt>helper:</dt><dd>A method that is not invoked directly by a caller but is used by another
method to perform part of an operation.</dd><dt>invariant:</dt><dd>An assertion that should be true of an object at all times (except perhaps
while the object is being modified).</dd></dl><h2>17.12 Exercises<a name="auto11"></a></h2><ol><li><div class="exercise">
By convention, lists are often printed in brackets with commas between the
elements, as in <code>[1, 2, 3]</code>.  Modify <code>printList</code> so that
it generates output in this format.
</div></li></ol></div><p><a href="index.html">Table of Contents</a> |
    <a href="dex.html">Index</a></p></body></html>