<html>
<head>
  <title>Files and exceptions</title>
</head>
<body>

<h1>Files and exceptions</h1>
<span class="index" value="file" />

<p>While a program is running, its data is in memory.  When the program ends,
or the computer shuts down, data in memory disappears.  To store data
permanently, you have to put it in a <b>file</b>.  Files are usually
stored on a hard drive, usb drive, or CD.</p>

<p>When there are a large number of files, they are often organized into
<b>directories</b> (also called <q>folders</q>).  Each file is
identified by a unique name, or a combination of a file name and a directory
name.</p>

<p>By reading and writing files, programs can exchange information with each
other and generate printable formats like PDF.</p>

<p>Working with files is a lot like working with books.  To use a book, you
have to open it.  When you're done, you have to close it.  While the book is
open, you can either write in it or read from it.  In either case, you know
where you are in the book.  Most of the time, you read the whole book in its
natural order, but you can also skip around.</p>

<p>All of this applies to files as well.  To open a file, you specify its name
and indicate whether you want to read or write.</p>

<p>Opening a file creates a file object.  In this example, the variable
<code>f</code> refers to the new file object.</p>

<pre class="python-interpreter">
>>> f = open("test.dat","w")
>>> print f
&lt;open file 'test.dat', mode 'w' at 0x2aaaaab80cd8>
</pre>

<p>The open function takes two arguments.  The first is the name of the file,
and the second is the mode.  Mode <code>"w"</code> means that we are opening
the file for writing.</p>

<p>If there is no file named <code>test.dat</code>, it will be created.  If
there already is one, it will be replaced by the file we are writing.</p>

<p>When we print the file object, we see the name of the file, the mode, and
the location of the object.</p>

<p>To put data in the file we invoke the <code>write</code> method on the file
object:</p>

<pre class="python-interpreter">
>>> f.write("Now is the time")
>>> f.write("to close the file")
</pre>

<p>Closing the file tells the system that we are done writing and makes the
file available for reading:</p>

<pre class="python-interpreter">
>>> f.close()
</pre>

<p>Now we can open the file again, this time for reading, and read the contents 
into a string.  This time, the mode argument is <code>"r"</code> for reading:
</p>

<pre class="python-interpreter">
>>> f = open("test.dat","r")
</pre>

<p>If we try to open a file that doesn't exist, we get an error:</p>

<span class="index" value="runtime error" />

<pre class="python-interpreter">
>>> f = open("test.cat","r")
IOError: [Errno 2] No such file or directory: 'test.cat'
</pre>

<p>Not surprisingly, the <code>read</code> method reads data from the file.
With no arguments, it reads the entire contents of the file:</p>

<pre class="python-interpreter">
>>> text = f.read()
>>> print text
Now is the timeto close the file
</pre>

<p>There is no space between <q>time</q> and <q>to</q> because we did not write 
a space between the strings.</p>

<p><code>read</code> can also take an argument that indicates how many
characters to read:</p>

<pre class="python-interpreter">
>>> f = open("test.dat","r")
>>> print f.read(5)
Now i
</pre>

<p>If not enough characters are left in the file, <code>read</code> returns the 
remaining characters.  When we get to the end of the file, <code>read</code>
returns the empty string:</p>

<pre class="python-interpreter">
>>> print f.read(1000006)
s the timeto close the file
>>> print f.read()
   
>>>
</pre>

<p>The following function copies a file, reading and writing up to fifty
characters at a time.  The first argument is the name of the original file; the 
second is the name of the new file:</p>

<pre class="python">
def copyFile(oldFile, newFile):
    f1 = open(oldFile, "r")
    f2 = open(newFile, "w")
    while True:
        text = f1.read(50)
        if text == "":
            break
        f2.write(text)
    f1.close()
    f2.close()
    return
</pre>

<p>The <code>break</code> statement is new.  Executing it breaks out of the
loop; the flow of execution moves to the first statement after the loop.</p>

<span class="index" value="break statement" />
<span class="index" value="statement!break" />

<p>In this example, the <code>while</code> loop is infinite because the value
<code>True</code> is always true.  The <em>only</em> way to get out of the
loop is the execute <code>break</code>, which happens when <code>text</code> is 
the empty string, which happens when we get to the end of the file.</p>


<h2>Text files</h2>
<span class="index" value="text file" />
<span class="index" value="file!text" />

<p>A <b>text file</b> is a file that contains printable characters
and whitespace, organized into lines separated by newline characters.  Since
Python is specifically designed to process text files, it provides methods that 
make the job easy.</p>

<p>To demonstrate, we'll create a text file with three lines of text separated
by newlines:</p>

<pre class="python-interpreter">
>>> f = open("test.dat","w")
>>> f.write("line one\nline two\nline three\n")
>>> f.close()
</pre>

<p>The <code>readline</code> method reads all the characters up to and
including the next newline character:</p>

<pre class="python-interpreter">
>>> f = open("test.dat","r")
>>> print f.readline()
line one
   
>>>
</pre>

<p><code>readlines</code> returns all of the remaining lines as a list of
strings:</p>

<pre class="python-interpreter">
>>> print f.readlines()
['line two\012', 'line three\012']
</pre>

<p>In this case, the output is in list format, which means that the strings
appear with quotation marks and the newline character appears as the escape
sequence <code>\\012</code>.</p>

<p>At the end of the file, <code>readline</code> returns the empty string
and <code>readlines</code> returns the empty list:</p>

<pre class="python-interpreter">
>>> print f.readline()
   
>>> print f.readlines()
[]
</pre>

<p>The following is an example of a line-processing program.
<code>filterFile</code> makes a copy of <code>oldFile</code>, omitting any
lines that begin with <code>#</code>:</p>

<pre class="python">
def filterFile(oldFile, newFile):
    f1 = open(oldFile, "r")
    f2 = open(newFile, "w")
    while True:
        text = f1.readline()
        if text == "":
           break
        if text[0] == '#':
           continue
        f2.write(text)
    f1.close()
    f2.close()
    return
</pre>

<p>The <code>continue</code> statement ends the current iteration of the loop,
but continues looping.  The flow of execution moves to the top of the loop,
checks the condition, and proceeds accordingly.</p>

<span class="index" value="continue statement" />
<span class="index" value="statement!continue" />

<p>Thus, if <code>text</code> is the empty string, the loop exits.  If the
first character of <code>text</code> is a hash mark, the flow of execution goes 
to the top of the loop.  Only if both conditions fail do we copy
<code>text</code> into the new file.</p>


<h2>Writing variables</h2>
<span class="index" value="format operator" />
<span class="index" value="format string" />
<span class="index" value="operator!format" />

<p>The argument of <code>write</code> has to be a string, so if we want to put
other values in a file, we have to convert them to strings first.  The easiest
way to do that is with the <code>str</code> function:</p>

<pre class="python-interpreter">
>>> x = 52
>>> f.write (str(x))
</pre>

<p>An alternative is to use the <b>format operator</b>,
<code>%</code>.  When applied to integers, <code>%</code> is the modulus
operator.  But when the first operand is a string, <code>%</code> is the format 
operator.</p>

<p>The first operand is the <b>format string</b>, and the second
operand is a tuple of expressions.  The result is a string that contains
the values of the expressions, formatted according to the format string.</p>

<p>As a simple example, the <b>format sequence</b> <code>"%d"</code>
means that the first expression in the tuple should be formatted as an integer. 
Here the letter <em>d</em> stands for <q>decimal</q>:</p>

<pre class="python-interpreter">
>>> cars = 52
>>> "%d" % cars
'52'
</pre>

<p>The result is the string <code>'52'</code>, which is not to be confused
with the integer value <code>52</code>.</p>

<p>A format sequence can appear anywhere in the format string, so we can embed
a value in a sentence:</p>

<pre class="python-interpreter">
>>> cars = 52
>>> "In July we sold %d cars." % cars
'In July we sold 52 cars.'
</pre>

<p>The format sequence <code>"%f"</code> formats the next item in the tuple as
a floating-point number, and <code>"%s"</code> formats the next item as a
string:</p>

<pre class="python-interpreter">
>>> "In %d days we made %f million %s." % (34,6.1,'dollars')
'In 34 days we made 6.100000 million dollars.'
</pre>

<p>By default, the floating-point format prints six decimal places.</p>

<p>The number of expressions in the tuple has to match the number of format
sequences in the string.  Also, the types of the expressions have to match the
format sequences:</p>

<span class="index" value="runtime error" />

<pre class="python-interpreter">
>>> "%d %d %d" % (1,2)
TypeError: not enough arguments for format string
>>> "%d" % 'dollars'
TypeError: illegal argument type for built-in operation
</pre>

<p>In the first example, there aren't enough expressions; in the second, the
expression is the wrong type.</p>

<p>For more control over the format of numbers, we can specify the number of
digits as part of the format sequence:</p>

<pre class="python-interpreter">
>>> "%6d" % 62
'    62'
>>> "%12f" % 6.1
'    6.100000'
</pre>

<p>The number after the percent sign is the minimum number of spaces the number 
will take up.  If the value provided takes fewer digits, leading spaces are
added.  If the number of spaces is negative, trailing spaces are added:</p>

<pre class="python-interpreter">
>>> "%-6d" % 62
'62    '
</pre>

<p>For floating-point numbers, we can also specify the number of digits after
the decimal point:</p>

<pre class="python-interpreter">
>>> "%12.2f" % 6.1
'        6.10'
</pre>

<p>In this example, the result takes up twelve spaces and includes two digits
after the decimal.  This format is useful for printing dollar amounts with the
decimal points aligned.</p>

<span class="index" value="dictionary" />

<p>For example, imagine a dictionary that contains student names as keys and
hourly wages as values.  Here is a function that prints the contents of the
dictionary as a formatted report:</p>

<pre class="python">
def report (wages) :
    students = wages.keys()
    students.sort()
    for student in students:
        print "%-20s %12.02f" % (student, wages[student])
</pre>

<p>To test this the function, we'll create a small dictionary and print the
contents:</p>

<pre class="python-interpreter">
>>> wages = {'mary': 6.23, 'joe': 5.45, 'joshua': 4.25}
>>> report (wages)
joe                          5.45
joshua                       4.25
mary                         6.23
</pre>

<p>By controlling the width of each value, we guarantee that the columns will
line up, as long as the names contain fewer than twenty-one characters and the
wages are less than one billion dollars an hour.</p>


<h2>Directories</h2>
<span class="index" value="directory" />

<p>When you create a new file by opening it and writing, the new file goes in
the current directory (wherever you were when you ran the program).  Similarly, 
when you open a file for reading, Python looks for it in the current directory.
</p>

<p>If you want to open a file somewhere else, you have to specify the
<b>path</b> to the file, which is the name of the directory
(or folder) where the file is located:</p>

<pre class="python-interpreter">
>>>   f = open("/usr/share/dict/words","r")
>>>   print f.readline()
Aarhus
</pre>

<p>This example opens a file named <code>words</code> that resides in a
directory named <code>dict</code>, which resides in <code>share</code>, which
resides in <code>usr</code>, which resides in the top-level directory of the
system, called <code>/</code>.</p>

<span class="index" value="path" />
<span class="index" value="delimiter" />

<p>You cannot use <code>/</code> as part of a filename; it is reserved as a
delimiter between directory and filenames.</p>

<p>The file <code>/usr/share/dict/words</code> contains a list of words
in alphabetical order, of which the first is the name of a Danish university.
</p>


<h2>Pickling</h2>
<span class="index" value="pickling" />

<p>In order to put values into a file, you have to convert them to strings.
You have already seen how to do that with <code>str</code>:</p>

<pre class="python-interpreter">
>>> f.write (str(12.3))
>>> f.write (str([1,2,3]))
</pre>

<p>The problem is that when you read the value back, you get a string.  The
original type information has been lost.  In fact, you can't even tell where
one value ends and the next begins:</p>

<pre class="python-interpreter">
>>>   f.readline()
'12.3[1, 2, 3]'
</pre>

<p>The solution is <b>pickling</b>, so called because it
<q>preserves</q> data structures.  The <code>pickle</code> module contains the
necessary commands.  To use it, import <code>pickle</code> and then open the
file in the usual way:</p>

<pre class="python-interpreter">
>>> import pickle
>>> f = open("test.pck","w")
</pre>

<p>To store a data structure, use the <code>dump</code> method and then close
the file in the usual way:</p>

<pre class="python-interpreter">
>>> pickle.dump(12.3, f)
>>> pickle.dump([1,2,3], f)
>>> f.close()
</pre>

<p>Then we can open the file for reading and load the data structures we
dumped:</p>

<pre class="python-interpreter">
>>> f = open("test.pck","r")
>>> x = pickle.load(f)
>>> x
12.3
>>> type(x)
&lt;type 'float'>
>>> y = pickle.load(f)
>>> y
[1, 2, 3]
>>> type(y)
&lt;type 'list'>
</pre>

<p>Each time we invoke <code>load</code>, we get a single value from the file,
complete with its original type.</p>


<h2>Exceptions</h2>
<span class="index" value="try statement" />
<span class="index" value="statement!try" />
<span class="index" value="raise exception" />
<span class="index" value="handle exception" />
<span class="index" value="except statement" />
<span class="index" value="statement!except" />
<span class="index" value="exception" />

<p>Whenever a runtime error occurs, it creates an <b>exception</b>.
Usually, the program stops and Python prints an error message.</p>

<p>For example, dividing by zero creates an exception:</p>

<pre class="python-interpreter">
>>> print 55/0
ZeroDivisionError: integer division or modulo
</pre>

<p>So does accessing a nonexistent list item:</p>

<pre class="python-interpreter">
>>> a = []
>>> print a[5]
IndexError: list index out of range
</pre>

<p>Or accessing a key that isn't in the dictionary:</p>

<pre class="python">
>>> b = {}
>>> print b['what']
KeyError: what
</pre>

<p>In each case, the error message has two parts: the type of error before the
colon, and specifics about the error after the colon.  Normally Python also
prints a traceback of where the program was, but we have omitted that from the
examples.</p>

<span class="index" value="traceback" />

<p>Sometimes we want to execute an operation that could cause an exception, but 
we don't want the program to stop.  We can <b>handle</b> the
exception using the <code>try</code> and <code>except</code> statements.</p>

<p>For example, we might prompt the user for the name of a file and then try to 
open it.  If the file doesn't exist, we don't want the program to crash; we
want to handle the exception:</p>

<pre class="python">
filename = raw_input('Enter a file name: ')
try:
    f = open (filename, "r")
except:
    print 'There is no file named', filename
</pre>

<p>The <code>try</code> statement executes the statements in the first block.
If no exceptions occur, it ignores the <code>except</code> statement.  If any
exception occurs, it executes the statements in the <code>except</code> branch
and then continues.</p>

<p>We can encapsulate this capability in a function: <code>exists</code> takes
a filename and returns true if the file exists, false if it doesn't:</p>

<pre class="python">
def exists(filename):
    try:
        f = open(filename)
        f.close()
        return 1
    except:
        return 0
</pre>

<p>You can use multiple <code>except</code> blocks to handle different kinds of
exceptions.  The <em>Python Reference Manual</em> has the details.</p>

<p>If your program detects an error condition, you can make it
<b>raise</b> an exception.  Here is an example that gets input from
the user and checks for the value 17.  Assuming that 17 is not valid input for
some reason, we raise an exception.</p>

<pre class="python">
def inputNumber():
    x = input('Pick a number: ')
    if x == 17:
        raise 'BadNumberError', '17 is a bad number'
    return x
</pre>

<p>The <code>raise</code> statement takes two arguments: the exception type and 
specific information about the error.  <code>BadNumberError</code> is a new
kind of exception we invented for this application.</p>

<p>If the function that called <code>inputNumber</code> handles the error, then 
the program can continue; otherwise, Python prints the error message and exits:
</p>

<pre class="python-interpreter">
>>> inputNumber()
Pick a number: 17
BadNumberError: 17 is a bad number
</pre>

<p>The error message includes the exception type and the additional information 
you provided.</p>

<div class="exercise">
As an exercise, write a function that uses <code>inputNumber</code> to input a
number from the keyboard and that handles the <code>BadNumberError</code>
exception.
</div>


<h2>Glossary</h2>
<span class="index" value="file" />
<span class="index" value="text file" />
<span class="index" value="break statement" />
<span class="index" value="statement!break" />
<span class="index" value="continue statement" />
<span class="index" value="statement!continue" />
<span class="index" value="format operator" />
<span class="index" value="format string" />
<span class="index" value="operator!format" />
<span class="index" value="directory" />
<span class="index" value="pickle" />
<span class="index" value="try" />
<span class="index" value="raise exception" />
<span class="index" value="raise exception" />
<span class="index" value="handle exception" />
<span class="index" value="except statement" />
<span class="index" value="exception" />

<dl>
<dt>file:</dt>
<dd>A named entity, usually stored on a hard drive, floppy disk, or CD-ROM,
that contains a stream of characters.</dd>

<dt>directory:</dt>
<dd>A named collection of files, also called a folder.</dd>

<dt>path:</dt>
<dd>A sequence of directory names that specifies the exact location of a file.
</dd>

<dt>text file:</dt>
<dd>A file that contains printable characters organized into lines separated by 
newline characters.</dd>

<dt>break statement:</dt>
<dd>A statement that causes the flow of execution to exit a loop.</dd>

<dt>continue statement:</dt>
<dd>A statement that causes the current iteration of a loop to end.  The flow
of execution goes to the top of the loop, evaluates the condition, and proceeds 
accordingly.</dd>

<dt>format operator:</dt>
<dd>The <code>%</code> operator takes a format string and a tuple of
expressions and yields a string that includes the expressions, formatted
according to the format string.</dd>

<dt>format string:</dt>
<dd>A string that contains printable characters and format sequences that
indicate how to format values.</dd>

<dt>format sequence:</dt>
<dd>A sequence of characters beginning with <code>%</code> that indicates how
to format a value.</dd>

<dt>pickle:</dt>
<dd>To write a data value in a file along with its type information so that it
can be reconstituted later.</dd>

<dt>exception:</dt>
<dd>An error that occurs at runtime.</dd>

<dt>handle:</dt>
<dd>To prevent an exception from terminating a program using the
<code>try</code> and <code>except</code> statements.</dd>

<dt>raise:</dt>
<dd>To signal an exception using the <code>raise</code> statement.</dd>
</dl>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
 &nbsp;
</div></li>

<li><div class="exercise">
 &nbsp;
</div></li>
</ol>


</body>
</html>
