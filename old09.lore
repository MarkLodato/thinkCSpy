<html>
<head>
  <title>Tuples</title>
</head>
<body>

<h1>Tuples</h1>
<a name="tuplechap" />
<span class="index" value="tuple" />

<h2>Mutability and tuples</h2>
<span class="index" value="tuple" />
<span class="index" value="data type!tuple" />
<span class="index" value="data type!immutable" />

<p>So far, you have seen two compound types: strings, which are made up of
characters; and lists, which are made up of elements of any type.  One of the
differences we noted is that the elements of a list can be modified, but the
characters in a string cannot.  In other words, strings are
<b>immutable</b> and lists are <b>mutable</b>.</p>

<span class="index" value="mutable" />
<span class="index" value="immutable" />

<p>There is another type in Python called a <b>tuple</b> that is
similar to a list except that it is immutable.  Syntactically, a tuple is a
comma-separated list of values:</p>

<pre class="python-interpreter">
>>> tup = 'a', 'b', 'c', 'd', 'e'
</pre>

<p>Although it is not necessary, it is conventional to enclose tuples in
parentheses:</p>

<pre class="python-interpreter">
>>> tup = ('a', 'b', 'c', 'd', 'e')
</pre>

<p>To create a tuple with a single element, we have to include the final
comma:</p>

<pre class="python-interpreter">
>>> tup = ('a',)
>>> type(tup)
&lt;type 'tuple'>
</pre>

<p>Without the comma, Python treats <code>('a')</code> as a string in
parentheses:</p>

<pre class="python-interpreter">
>>> tup = ('a')
>>> type(tup)
&lt;type 'str'>
</pre>

<p>Syntax issues aside, the operations on tuples are the same as the operations 
on lists.  The index operator selects an element from a tuple.</p>

<pre class="python-interpreter">
>>> tup = ('a', 'b', 'c', 'd', 'e')
>>> tup[0]
'a'
</pre>

<p>And the slice operator selects a range of elements.</p>

<pre class="python-interpreter">
>>> tup[1:3]
('b', 'c')
</pre>

<p>But if we try to modify one of the elements of the tuple, we get a error:
</p>

<span class="index" value="runtime error" />

<pre class="python-interpreter">
>>> tup[0] = 'A'
TypeError: 'tuple' object does not support item assignment
</pre>

<p>Of course, even if we can't modify the elements of a tuple, we can replace
it with a different tuple:</p>

<pre class="python-interpreter">
>>> tup = ('A',) + tup[1:]
>>> tup
('A', 'b', 'c', 'd', 'e')
</pre>

<p>Alternatively, we could first convert it to a list, modify it, and convert
it back into a tuple:</p>

<pre class="python-interpreter">
>>> tup = ('A', 'b', 'c', 'd', 'e')
>>> tup = list(tup)
>>> tup
['A', 'b', 'c', 'd', 'e']
>>> tup[0] = 'a'
>>> tup = tuple(tup)
>>> tup
('a', 'b', 'c', 'd', 'e')
</pre>


<h2>Tuple assignment</h2>
<a name="tuple assignment" />
<span class="index" value="tuple assignment" />
<span class="index" value="assignment!tuple" />

<p>Once in a while, it is useful to swap the values of two variables.  With
conventional assignment statements, we have to use a temporary variable.  For
example, to swap <code>a</code> and <code>b</code>:</p>

<pre class="python-interpreter">
>>> temp = a
>>> a = b
>>> b = temp
</pre>

<p>If we have to do this often, this approach becomes cumbersome.  Python
provides a form of <b>tuple assignment</b> that solves this problem
neatly:</p>

<pre class="python-interpreter">
>>> a, b = b, a
</pre>

<p>The left side is a tuple of variables; the right side is a tuple of values.  
Each value is assigned to its respective variable.  All the expressions on the
right side are evaluated before any of the assignments.  This feature makes
tuple assignment quite versatile.</p>

<p>Naturally, the number of variables on the left and the number of values on
the right have to be the same:</p>

<pre class="python-interpreter">
>>> a, b, c, d = 1, 2, 3
ValueError: need more than 3 values to unpack 
</pre>


<h2>Tuples as return values</h2>
<span class="index" value="tuple" />
<span class="index" value="value!tuple" />
<span class="index" value="return value!tuple" />
<span class="index" value="function!tuple as return value" />

<p>Functions can return tuples as return values.  For example, we could write a 
function that swaps two parameters:</p>

<pre class="python">
def swap(x, y):
    return y, x
</pre>

<p>Then we can assign the return value to a tuple with two variables:</p>

<pre class="python">
a, b = swap(a, b)
</pre>

<p>In this case, there is no great advantage in making <code>swap</code> a
function.  In fact, there is a danger in trying to encapsulate
<code>swap</code>, which is the following tempting mistake:</p>

<pre class="python">
def swap(x, y):      # incorrect version
     x, y = y, x
</pre>

<p>If we call this function like this:</p>

<pre class="python">
swap(a, b)
</pre>

<p>then <code>a</code> and <code>x</code> are aliases for the same value.
Changing <code>x</code> inside <code>swap</code> makes <code>x</code> refer to
a different value, but it has no effect on <code>a</code> in
<code>__main__</code>.  Similarly, changing <code>y</code> has no effect on
<code>b</code>.</p>

<p>This function runs without producing an error message, but it doesn't do
what we intended.  This is an example of a semantic error.</p>

<span class="index" value="semantic error" />


<h2>Random numbers</h2>
<span class="index" value="random number" />
<span class="index" value="number!random" />

<p>Most computer programs do the same thing every time they execute, so they
are said to be <b>deterministic</b>.  Determinism is usually a good
thing, since we expect the same calculation to yield the same result.  For some 
applications, though, we want the computer to be unpredictable.  Games are an
obvious example, but there are more.</p>

<p>Making a program truly nondeterministic turns out to be not so easy, but
there are ways to make it at least seem nondeterministic.  One of them is to
generate random numbers and use them to determine the outcome of the program.
Python provides a built-in function that generates
<b>pseudorandom</b> numbers, which are not truly random in
the mathematical sense, but for our purposes they will do.</p>

<p>The <code>random</code> module contains a function called
<code>random</code> that returns a floating-point number between 0.0 and 1.0.
Each time you call <code>random</code>, you get the next number in a long
series.  To see a sample, run this loop:</p>

<pre class="python">
import random
   
for i in range(10):
    x = random.random()
    print x
</pre>

<p>To generate a random number between 0.0 and an upper bound like
<code>high</code>, multiply <code>x</code> by <code>high</code>.</p>


<h2>List of random numbers</h2>

<p>The first step is to generate a list of random values.
<code>randomList</code> takes an integer parameter and returns a list of random
numbers with the given length.  It starts with a list of <code>n</code> zeros.  
Each time through the loop, it replaces one of the elements with a random
number.  The return value is a reference to the complete list:</p>

<pre class="python">
def randomList(n):
    s = [0] * n
    for i in range(n):
        s[i] = random.random()
    return s
</pre>

<p>We'll test this function with a list of eight elements.  For purposes of
debugging, it is a good idea to start small.</p>

<pre class="python-interpreter">
>>> randomList(8)
0.15156642489
0.498048560109
0.810894847068
0.360371157682
0.275119183077
0.328578797631
0.759199803101
0.800367163582
</pre>

<p>The numbers generated by <code>random</code> are supposed to be distributed
uniformly, which means that every value is equally likely.</p>

<p>If we divide the range of possible values into equal-sized <q>buckets</q>,
and count the number of times a random value falls in each bucket, we should
get roughly the same number in each.</p>

<p>We can test this theory by writing a program to divide the range into
buckets and count the number of values in each.</p>


<h2>Counting</h2>
<span class="index" value="counting" />

<p>A good approach to problems like this is to divide the problem into
subproblems and look for subproblems that fit a computational pattern
you have seen before.</p>

<p>In this case, we want to traverse a list of numbers and count the number of
times a value falls in a given range.  That sounds familiar.  We wrote a
program earlier that traversed a string and counted the number of times a given 
letter appeared.</p>

<p>So, we can proceed by copying the old program and adapting it for the
current problem.  The original program was:</p>

<pre class="python">
count = 0
for char in fruit:
    if char == 'a':
        count = count + 1
print count
</pre>

<p>The first step is to replace <code>fruit</code> with <code>numbers</code> and
<code>char</code> with <code>num</code>.  That doesn't change the program;
it just makes it more readable.</p>

<p>The second step is to change the test.  We aren't interested in finding
letters.  We want to see if <code>num</code> is between the given values
<code>low</code> and <code>high</code>.</p>

<pre class="python">
count = 0
for num in numbers:
    if low &lt; num &lt; high:
        count = count + 1
print count
</pre>

<p>The last step is to encapsulate this code in a function called
<code>inBucket</code>.  The parameters are the list and the values
<code>low</code> and <code>high</code>.</p>

<pre class="python">
def inBucket(numbers, low, high):
    count = 0
    for num in numbers:
        if low &lt; num &lt; high:
            count = count + 1
    return count
</pre>

<p>By copying and modifying an existing program, we were able to write this
function quickly and save a lot of debugging time.  This development plan is
called <b>pattern matching</b>.  If you find yourself working on a
problem you have solved before, reuse the solution.</p>


<h2>Many buckets</h2>

<p>As the number of buckets increases, <code>inBucket</code> gets a little
unwieldy.  With two buckets, it's not bad:</p>

<pre class="python">
low = inBucket(a, 0.0, 0.5)
high = inBucket(a, 0.5, 1)
</pre>

<p>But with four buckets it is getting cumbersome.</p>

<pre class="python">
bucket1 = inBucket(a, 0.0, 0.25)
bucket2 = inBucket(a, 0.25, 0.5)
bucket3 = inBucket(a, 0.5, 0.75)
bucket4 = inBucket(a, 0.75, 1.0)
</pre>

<p>There are two problems.  One is that we have to make up new variable names
for each result.  The other is that we have to compute the range for each
bucket.</p>

<p>We'll solve the second problem first.  If the number of buckets is
<code>numBuckets</code>, then the width of each bucket is
<code>1.0 / numBuckets</code>.</p>

<p>We'll use a loop to compute the range of each bucket.  The loop variable,
<code>i</code>, counts from 1 to <code>numBuckets-1</code>:</p>

<pre class="python">
bucketWidth = 1.0 / numBuckets
for i in range(numBuckets):
    low = i * bucketWidth
    high = low + bucketWidth
    print low, "to", high
</pre>

<p>To compute the low end of each bucket, we multiply the loop variable by the
bucket width.  The high end is just a <code>bucketWidth</code> away.</p>

<p>With <code>numBuckets = 8</code>, the output is:</p>

<pre class="python">
0.0 to 0.125
0.125 to 0.25
0.25 to 0.375
0.375 to 0.5
0.5 to 0.625
0.625 to 0.75
0.75 to 0.875
0.875 to 1.0
</pre>

<p>You can confirm that each bucket is the same width, that they don't overlap, 
and that they cover the entire range from 0.0 to 1.0.</p>

<p>Now back to the first problem.  We need a way to store eight integers, using 
the loop variable to indicate one at a time.  By now you should be thinking,
<q>List!</q></p>

<p>We have to create the bucket list outside the loop, because we only want to
do it once.  Inside the loop, we'll call <code>inBucket</code> repeatedly and
update the <code>i</code>-eth element of the list:</p>

<pre class="python">
numBuckets = 8
buckets = [0] * numBuckets
bucketWidth = 1.0 / numBuckets
for i in range(numBuckets):
    low = i * bucketWidth
    high = low + bucketWidth
    buckets[i] = inBucket(numlist, low, high)
print buckets
</pre>

<p>With a numlist of 1000 values, this code produces a bucket list like
this:</p>

<pre class="shell">
[138, 124, 128, 118, 130, 117, 114, 131]
</pre>

<p>These numbers are fairly close to 125, which is what we expected.  At least, 
they are close enough that we can believe the random number generator is
working.</p>


<h2>A single-pass solution</h2>
<span class="index" value="histogram" />

<p>Although this program works, it is not as efficient as it could be.  Every
time it calls <code>inBucket</code>, it traverses the entire list.  As the
number of buckets increases, that gets to be a lot of traversals.</p>

<p>It would be better to make a single pass through the list and compute for
each value the index of the bucket in which it falls.  Then we can increment
the appropriate counter.</p>

<p>In the previous section we took an index, <code>i</code>, and multiplied it
by the <code>bucketWidth</code> to find the lower bound of a given bucket.  Now 
we want to take a value in the range 0.0 to 1.0 and find the index of the
bucket where it falls.</p>

<p>Since this problem is the inverse of the previous problem, we might guess
that we should divide by <code>bucketWidth</code> instead of multiplying.  That 
guess is correct.</p>

<p>Since <code>bucketWidth = 1.0 / numBuckets</code>, dividing by
<code>bucketWidth</code> is the same as multiplying by <code>numBuckets</code>. 
If we multiply a number in the range 0.0 to 1.0 by <code>numBuckets</code>, we
get a number in the range from 0.0 to <code>numBuckets</code>.  If we round
that number to the next lower integer, we get exactly what we are looking
for---a bucket index:</p>

<pre class="python">
numBuckets = 8
buckets = [0] * numBuckets
for i in list:
    index = int(i * numBuckets)
    buckets[index] = buckets[index] + 1
</pre>

<p>We used the <code>int</code> function to convert a floating-point number to
an integer.</p>

<p>Is it possible for this calculation to produce an index that is out of range 
(either negative or greater than <code>len(buckets)-1</code>)?</p>

<p>A list like <code>buckets</code> that contains counts of the number of
values in each range is called a <b>histogram</b>.</p>


<h2>Glossary</h2>
<span class="index" value="mutable type" />
<span class="index" value="immutable type" />
<span class="index" value="tuple" />
<span class="index" value="tuple assignment" />
<span class="index" value="assignment!tuple" />
<span class="index" value="deterministic" />
<span class="index" value="pseudorandom" />
<span class="index" value="histogram" />
<span class="index" value="pattern matching" />

<dl>
<dt>immutable type:</dt>
<dd>A type in which the elements cannot be modified.  Assignments to elements
or slices of immutable types cause an error.</dd>

<dt>mutable type:</dt>
<dd>A data type in which the elements can be modified.  All mutable types are
compound types.  Lists and dictionaries are mutable data types; strings and
tuples are not.</dd>

<dt>tuple:</dt>
<dd>A sequence type that is similar to a list except that it is immutable.
Tuples can be used wherever an immutable type is required, such as a key in a
dictionary.</dd>

<dt>tuple assignment:</dt>
<dd>An assignment to all of the elements in a tuple using a single assignment
statement. Tuple assignment occurs in parallel rather than in sequence, making
it useful for swapping values.</dd>

<dt>deterministic:</dt>
<dd>A program that does the same thing each time it is called.</dd>

<dt>pseudorandom:</dt>
<dd>A sequence of numbers that appear to be random but that are actually the
result of a deterministic computation.</dd>

<dt>histogram:</dt>
<dd>A list of integers in which each element counts the number of times
something happens.</dd>

<dt>pattern matching:</dt>
<dd>A program development plan that involves identifying a familiar
computational pattern and copying the solution to a similar problem.</dd>
</dl>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
<pre class="python">
def swap(x, y):      # incorrect version
     x, y = y, x
</pre>
Draw a state diagram for this function so that you can see why it doesn't work.
</div></li>

<li><div class="exercise">
Generate a random number between <code>low</code> and <code>high</code>.
</div></li>

<li><div class="exercise">
Generate a random integer between <code>low</code> and <code>high</code>,
including both end points.
</div></li>

<li><div class="exercise">
Test the counting proceedure with some longer lists
(2000, 4000, 8000, 16000, ...), and see if the number of values in each bucket
tends to level off.
</div></li>

<li><div class="exercise">
Write a function called <code>histogram</code> that takes a list of floating
point numbers between 0.0 and 1.0 and a number of buckets as arguments and
returns a histogram with the given number of buckets.
</div></li>
</ol>


</body>
</html>
