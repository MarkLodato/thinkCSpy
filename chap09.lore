<html>
<head>
  <title>Lists</title>
</head>
<body>

<h1>Lists</h1>
<span class="index" value="list" />
<span class="index" value="data type!list" />
<span class="index" value="element" />
<span class="index" value="sequence" />
<span class="index" value="nested list" />
<span class="index" value="list!nested" />
<span class="index" value="data type!mutable" />


<p>A <b>list</b> is an ordered set of values, where each value is identified by 
an index.  The values that make up a list are called its <b>elements</b>.
Lists are similar to strings, which are ordered sets of characters, except that 
the elements of a list can have any type.  Lists and strings---and other things 
that behave like ordered sets---are called <b>sequences</b>.</p>


<h2>List values</h2>

<p>There are several ways to create a new list; the simplest is to
enclose the elements in square brackets (<code>[</code> and <code>]</code>):
</p>

<pre class="python">
[10, 20, 30, 40]
["spam", "bungee", "swallow"]
</pre>

<p>The first example is a list of four integers.  The second is a list of three 
strings.  The elements of a list don't have to be the same type.  The following 
list contains a string, a float, an integer, and (mirabile dictu) another
list:</p>

<pre class="python">
["hello", 2.0, 5, [10, 20]]
</pre>

<p>A list within another list is said to be <b>nested</b>.</p>

<span class="index" value="list!nested" />

<p>Finally, there is a special list that contains no elements.  It is called
the empty list, and is denoted <code>[]</code>.</p>

<p>Like numeric 0 values and the empty string, the empty list is false in
a boolean expression:</p>

<pre class="python">
>>> if []:
...    print 'This is true."
... else:
...    print 'This is false."
...
This is false.
>>>
</pre>

<p>With all these ways to create lists, it would be disappointing if we
couldn't assign list values to variables or pass lists as parameters to
functions.  We can:</p>

<pre class="python-interpreter">
>>> vocabulary = ["ameliorate", "castigate", "defenestrate"]
>>> numbers = [17, 123]
>>> empty = []
>>> print vocabulary, numbers, empty
['ameliorate', 'castigate', 'defenestrate'] [17, 123] []
</pre>


<h2>Accessing elements</h2>
<span class="index" value="list!element"/>

<p>The syntax for accessing the elements of a list is the same as the syntax
for accessing the characters of a string---the bracket operator
(<code>[]</code> -- not to be confused with an empty list).  The expression
inside the brackets specifies the index.  Remember that the indices start at
0:</p>

<pre class="python">
>>> print numbers[0]
17
</pre>

<p>Any integer expression can be used as an index:</p>

<pre class="python-interpreter">
>>> numbers[9-8]
5
>>> numbers[1.0]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: list indices must be integers
</pre>

<p>If you try to read or write an element that does not exist, you get a
runtime error:</p>

<span class="index" value="runtime error" />

<pre class="python-interpreter">
>>> numbers[2]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: list index out of range
</pre>

<p>If an index has a negative value, it counts backward from the end of the
list:</p>

<pre class="python-interpreter">
>>> numbers[-1]
5
>>> numbers[-2]
17
>>> numbers[-3]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: list index out of range
</pre>

<p><code>numbers[-1]</code> is the last element of the list,
<code>numbers[-2]</code> is the second to last, and <code>numbers[-3]</code>
doesn't exist.</p>

<p>It is common to use a loop variable as a list index.</p>

<pre class="python">
horsemen = ["war", "famine", "pestilence", "death"]
   
i = 0
while i &lt; 4:
    print horsemen[i]
    i += 1
</pre>

<p>This <code>while</code> loop counts from 0 to 4.  When the loop variable
<code>i</code> is 4, the condition fails and the loop terminates.  So the
body of the loop is only executed when <code>i</code> is 0, 1, 2, and 3.</p>

<p>Each time through the loop, the variable <code>i</code> is used as an index
into the list, printing the <code>i</code>-eth element.  This pattern of
computation is called a <b>list traversal</b>.</p>

<span class="index" value="list!traversal" />
<span class="index" value="traversal!list" />


<h2>List length</h2>
<span class="index" value="length" />
<span class="index" value="list!length" />

<p>The function <code>len</code> returns the length of a list, which is equal
to the number of its elements.  It is a good idea to use this value as the
upper bound of a loop instead of a constant.  That way, if the size of the list 
changes, you won't have to go through the program changing all the loops; they
will work correctly for any size list:</p>

<pre class="python">
horsemen = ["war", "famine", "pestilence", "death"]
   
i = 0
num = len(horsemen)
while i &lt; num:
    print horsemen[i]
    i += 1
</pre>

<p>The last time the body of the loop is executed, <code>i</code> is
<code>len(horsemen) - 1</code>, which is the index of the last element.  When
<code>i</code> is equal to <code>len(horsemen)</code>, the condition fails and
the body is not executed, which is a good thing, because
<code>len(horsemen)</code> is not a legal index.</p>

<p>Although a list can contain another list, the nested list still counts as a
single element.  The length of this list is 4:</p>

<pre class="python">
['spam!', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
</pre>


<h2>List membership</h2>
<span class="index" value="list!membership" />
<span class="index" value="in operator" />
<span class="index" value="operator!in" />

<p><code>in</code> is a boolean operator that tests membership in a sequence.
We used it previously with strings, but it also works with lists and other
sequences:</p>

<pre class="python-interpreter">
>>> horsemen = ['war', 'famine', 'pestilence', 'death']
>>> 'pestilence' in horsemen
True
>>> 'debauchery' in horsemen
False
</pre>

<p>Since <q>pestilence</q> is a member of the <code>horsemen</code> list, the
<code>in</code> operator returns <code>True</code>.  Since <q>debauchery</q> is 
not in the list, <code>in</code> returns <code>False</code>.</p>

<p>We can use the <code>not</code> in combination with <code>in</code> to test
whether an element is not a member of a list:</p>

<pre class="python">
>>> 'debauchery' not in horsemen
True
</pre>


<h2>List operations</h2>
<span class="index" value="list operation" />
<span class="index" value="operation!list" />

<p>The <code>+</code> operator concatenates lists:</p>

<span class="index" value="concatenation!list" />

<pre class="python-interpreter">
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print c
[1, 2, 3, 4, 5, 6]
</pre>

<p>Similarly, the <code>*</code> operator repeats a list a given number of
times:</p>

<span class="index" value="repetition!list" />

<pre class="python-interpreter">
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
</pre>

<p>The first example repeats <code>[0]</code> four times.  The second example
repeats the list <code>[1, 2, 3]</code> three times.</p>


<h2>List slices</h2>
<span class="index" value="slice" />
<span class="index" value="list!slice" />

<p>The slice operations we saw with strings also work on lists:</p>

<pre class="python-interpreter">
>>> a_list = ['a', 'b', 'c', 'd', 'e', 'f']
>>> a_list[1:3]
['b', 'c']
>>> a_list[:4]
['a', 'b', 'c', 'd']
>>> a_list[3:]
['d', 'e', 'f']
>>> a_list[:]
['a', 'b', 'c', 'd', 'e', 'f']
</pre>


<h2>The <code>range</code> function</h2>

<p>Lists that contain consecutive integers are common, so Python provides a
simple way to create them:</p>

<pre class="python-interpreter">
>>> range(1, 5)
[1, 2, 3, 4]
</pre>

<p>The <code>range</code> function takes two arguments and returns a list that
contains all the integers from the first to the second, including the first but 
<em>not the second</em>.</p>

<p>There are two other forms of <code>range</code>.  With a single argument, it
creates a list that starts at 0:</p>

<pre class="python-interpreter">
>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>

<p>If there is a third argument, it specifies the space between successive
values, which is called the <b>step size</b>.  This example counts
from 1 to 10 by steps of 2:</p>

<pre class="python-interpreter">
>>> range(1, 10, 2)
[1, 3, 5, 7, 9]
</pre>

<p>If the step size is negative, then <code>start</code> must be greater than
<code>stop</code></p>

<pre class="python-interpreter">
>>> range(20, 4, -5)
[20, 15, 10, 5]
</pre>

<p>or the result will be an empty list.</p>

<pre class="python-interpreter">
>>> range(10, 20, -5)
[]
</pre>


<h2>Lists are mutable</h2>
<span class="index" value="mutable" />
<span class="index" value="sequence!mutable" />
<span class="index" value="data type!mutable" />

<p>Unlike strings, lists are <b>mutable</b>, which means we can change their
elements.  Using the bracket operator on the left side of an assignment, we can update one of the elements:</p>

<pre class="python-interpreter">
>>> fruit = ["banana", "apple", "quince"]
>>> fruit[0] = "pear"
>>> fruit[-1] = "orange"
>>> print fruit
['pear', 'apple', 'orange']
</pre>

<p>The bracket operator applied to a list can appear anywhere in an expression.
When it appears on the left side of an assignment, it changes one of the
elements in the list, so the first element of <code>fruit</code> has been
changed from <code>'banana'</code> to <code>'pear'</code>, and the last
from <code>'quince'</code> to <code>'orange'</code>.  An assignment to 
an element of a list is called <b>item assignment</b>.  Item assignment does
not work for strings:</p>

<pre class="python-interpreter">
>>> my_string = 'TEST'
>>> my_string[2] = 'X'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'str' object does not support item assignment
</pre>

<p>but it does for lists:</p>

<pre class="python-interpreter">
>>> my_list = ['T', 'E', 'S', 'T']
>>> my_list[2] = 'X'
>>> my_list
['T', 'E', 'X', 'T']
</pre>

<p>With the slice operator we can update several elements at once:</p>

<pre class="python-interpreter">
>>> a_list = ['a', 'b', 'c', 'd', 'e', 'f']
>>> a_list[1:3] = ['x', 'y']
>>> print a_list
['a', 'x', 'y', 'd', 'e', 'f']
</pre>

<p>We can also remove elements from a list by assigning the empty list to
them:</p>

<pre class="python-interpreter">
>>> a_list = ['a', 'b', 'c', 'd', 'e', 'f']
>>> a_list[1:3] = []
>>> print a_list
['a', 'd', 'e', 'f']
</pre>

<p>And we can add elements to a list by squeezing them into an empty slice at
the desired location:</p>

<pre class="python-interpreter">
>>> a_list = ['a', 'd', 'f']
>>> a_list[1:1] = ['b', 'c']
>>> print a_list
['a', 'b', 'c', 'd', 'f']
>>> a_list[4:4] = ['e']
>>> print a_list
['a', 'b', 'c', 'd', 'e', 'f']
</pre>


<h2>List deletion</h2>
<span class="index" value="deletion!list" />
<span class="index" value="list deletion" />

<p>Using slices to delete list elements can be awkward, and therefore
error-prone.  Python provides an alternative that is more readable.</p>

<p><code>del</code> removes an element from a list:</p>

<pre class="python-interpreter">
>>> a = ['one', 'two', 'three']
>>> del a[1]
>>> a
['one', 'three']
</pre>

<p>As you might expect, <code>del</code> handles negative indices and causes a
runtime error if the index is out of range.</p>

<p>You can use a slice as an index for <code>del</code>:</p>

<pre class="python-interpreter">
>>> a_list = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del a_list[1:5]
>>> print a_list
['a', 'f']
</pre>

<p>As usual, slices select all the elements up to, but not including, the
second index.</p>


<h2>Objects and values</h2>
<span class="index" value="object" />
<span class="index" value="value" />

<p>If we execute these assignment statements,</p>

<pre class="python">
a = "banana"
b = "banana"
</pre>

<p>we know that <code>a</code> and <code>b</code> will refer to a string with
the letters <code>"banana"</code>.  But we can't tell whether they point to the 
<em>same</em> string.</p>

<p>There are two possible states:</p>

<img src="illustrations/list1.png" />

<p>In one case, <code>a</code> and <code>b</code> refer to two different things
that have the same value.  In the second case, they refer to the same thing.
These <q>things</q> have names---they are called <b>objects</b>.
An object is something a variable can refer to.</p>

<p>Every object has a unique <b>identifier</b>, which we can obtain
with the <code>id</code> function.  By printing the identifier of <code>a</code>
and <code>b</code>, we can tell whether they refer to the same object.</p>

<pre class="python-interpreter">
>>> id(a)
135044008
>>> id(b)
135044008
</pre>

<p>In fact, we get the same identifier twice, which means that Python only
created one string, and both <code>a</code> and <code>b</code> refer to it.
Your actual id value will be probably be different.</p>

<p>Interestingly, lists behave differently.  When we create two lists, we get
two objects:</p>

<pre class="python-interpreter">
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> id(a)
135045528
>>> id(b)
135041704
</pre>

<p>So the state diagram looks like this:</p>

<img src="illustrations/list2.png" />

<p><code>a</code> and <code>b</code> have the same value but do not refer to
the same object.</p>


<h2>Aliasing</h2>
<span class="index" value="aliasing" />
<span class="index" value="reference!aliasing" />

<p>Since variables refer to objects, if we assign one variable to another, both 
variables refer to the same object:</p>

<pre class="python-interpreter">
>>> a = [1, 2, 3]
>>> b = a
>>> id(a) == id(b)
True
</pre>

<p>In this case, the state diagram looks like this:</p>

<img src="illustrations/list3.png" />

<p>Because the same list has two different names, <code>a</code> and
<code>b</code>, we say that it is <b>aliased</b>.  Changes made with
one alias affect the other:</p>

<pre class="python-interpreter">
>>> b[0] = 5
>>> print a
[5, 2, 3]
</pre>

<p>Although this behavior can be useful, it is sometimes unexpected or
undesirable.  In general, it is safer to avoid aliasing when you are working
with mutable objects.  Of course, for immutable objects, there's no problem.
That's why Python is free to alias strings when it sees an opportunity to
economize.</p>


<h2>Cloning lists</h2>
<span class="index" value="list!cloning" />
<span class="index" value="cloning" />

<p>If we want to modify a list and also keep a copy of the original, we need to 
be able to make a copy of the list itself, not just the reference.  This
process is sometimes called <b>cloning</b>, to avoid the ambiguity of 
the word <q>copy.</q></p>

<p>The easiest way to clone a list is to use the slice operator:</p>

<pre class="python-interpreter">
>>> a = [1, 2, 3]
>>> b = a[:]
>>> print b
[1, 2, 3]
</pre>

<p>Taking any slice of <code>a</code> creates a new list.  In this case the
slice happens to consist of the whole list.</p>

<p>Now we are free to make changes to <code>b</code> without worrying about
<code>a</code>:</p>

<pre class="python-interpreter">
>>> b[0] = 5
>>> print a
[1, 2, 3]
</pre>


<h2>Lists and <code>for</code> loops</h2>
<span class="index" value="for loop" />
<span class="index" value="list!for loop" />
<span class="index" value="traversal" />

<p>The <code>for</code> loop also works with lists.  The generalized syntax of
a <code>for</code> loop is:</p>

<pre>
for VARIABLE in LIST:
    BODY
</pre>

<p>This statement is equivalent to:</p>

<pre class="python">
i = 0
while i &lt; len(LIST):
    VARIABLE = LIST[i]
    BODY
    i += 1
</pre>

<p>The <code>for</code> loop is more concise because we can eliminate the loop
variable, <code>i</code>.  Here is the previous loop written with a
<code>for</code> loop.</p>

<pre class="python">
for horseman in horsemen:
    print horseman
</pre>

<p>It almost reads like English: <q>For (every) horseman in (the list of)
horsemen, print (the name of the) horseman.</q></p>

<p>Any list expression can be used in a <code>for</code> loop:</p>

<pre class="python">
for number in range(20):
    if number % 3 == 0:
        print  number
   
for fruit in ["banana", "apple", "quince"]:
    print "I like to eat " + fruit + "s!"
</pre>

<p>The first example prints all the multiples of 3 between 0 and 19.  The
second example expresses enthusiasm for various fruits.</p>

<p>Since lists are mutable, it is often desirable to traverse a list, modifying
each of its elements.  The following squares all the numbers from
<code>1</code> to <code>5</code>:</p>

<pre class="python">
numbers = [1, 2, 3, 4, 5]

for index in range(len(numbers)):
    numbers[index] = numbers[index]**2
</pre>

<p>Take a moment to think about <code>range(len(numbers))</code> until you
understand how it works.  We are interested here in both the <em>value</em>
and its <em>index</em> within the list, so that we can assign a new value to
it.</p>

<p>This pattern is common enough that Python provides a nicer way to impliment
it:</p>

<pre class="python">
numbers = [1, 2, 3, 4, 5]

for index, value in enumerate(numbers):
    numbers[index] = value**2
</pre>

<p><code>enumerate</code> generates both the index and the value associated
with it during the list traversal.  Try this next example to see more
clearly how <code>enumerate</code> works:</p>

<pre class="python-interpreter">
>>> for a, b in enumerate(['banana', 'apple', 'pear', 'quince']):
...    print a, b
...
0 banana
1 apple
2 pear
3 quince
>>>
</pre>


<h2>List parameters</h2>
<span class="index" value="list!as parameter" />
<span class="index" value="parameter" />
<span class="index" value="parameter!list" />

<p>Passing a list as an argument actually passes a reference to the list, not a 
copy of the list.  Since lists are mutable changes made to the parameter
change the argument as well.  For example, the function below takes a list
as an argument and multiplies each element in the list by 2:</p>

<pre class="python">
def double_stuff(a_list):
    for i, value in enumerate(a_list):
        a_list[i] = 2 * value
</pre>

<p>If we put <code>double_stuff</code> in a file named <code>ch09.py</code>, we
can test it out like this:</p>

<pre class="python-interpreter">
>>> from ch09 import double_stuff
>>> things = [2, 5, 'Spam', 9.5]
>>> double_stuff(things)
>>> things
[4, 10, 'SpamSpam', 19.0]
>>>
</pre>

<p>The parameter <code>a_list</code> and the variable <code>things</code> are
aliases for the same object.  The state diagram looks like this:</p>

<img src="illustrations/stack5.png" />

<p>Since the list object is shared by two frames, we drew it between them.</p>

<p>If a function modifies a list parameter, the caller sees the change.</p>


<h2>Pure functions and modifiers</h2>
<span class="index" value="modifier" />
<span class="index" value="function type!modifier" />
<span class="index" value="side effect" />
<span class="index" value="pure function" />
<span class="index" value="function type!pure" />

<p>Functions which take lists as arguments and change them during execution
are called <b>modifiers</b> and the changes they make are called
<b>side effects</b>.</p>

<p>A <b>pure function</b> does not produce side effects.  It communicates
with the calling program only through parameters, which it does not modify,
and a return value.  Here is <code>double_stuff</code> written as a pure
function:</p>

<pre class="python">
def double_stuff(a_list):
    new_list = []
    for value in a_list:
        new_list += [2 * value]
    return new_list
</pre>

<p>This version of <code>double_stuff</code> does not change its arguments: 
</p>

<pre class="python-interpreter">
>>> from ch09 import double_stuff
>>> things = [2, 5, 'Spam', 9.5]
>>> double_stuff(things)
[4, 10, 'SpamSpam', 19.0]
>>> things
[2, 5, 'Spam', 9.5]
>>>
</pre>

<p>To use the pure function version of <code>double_stuff</code> to modify
<code>things</code>, you would assign the return value back to
<code>things</code>:

<pre class="python-interpreter">
>>> things = double_stuff(things)
>>> things
[4, 10, 'SpamSpam', 19.0]
>>>
</pre>


<h2>Which is better?</h2>
<span class="index" value="functional programming style" />

<p>Anything that can be done with modifiers can also be done with pure
functions.  In fact, some programming languages only allow pure functions.
There is some evidence that programs that use pure functions are faster to
develop and less error-prone than programs that use modifiers.  Nevertheless,
modifiers are convenient at times, and in some cases, functional programs are
less efficient.</p>

<p>In general, we recommend that you write pure functions whenever it is
reasonable to do so and resort to modifiers only if there is a compelling
advantage.  This approach might be called a
<em>functional programming style</em>.</p>


<h2>Nested lists</h2>
<a name="nested lists" />
<span class="index" value="nested list" />
<span class="index" value="list!nested" />

<p>A nested list is a list that appears as an element in another list.  In this 
list, the element with index 3 is a nested list:</p>

<pre class="python-interpreter">
>>> nested = ["hello", 2.0, 5, [10, 20]]
</pre>

<p>If we print <code>nested[3]</code>, we get <code>[10, 20]</code>.  To
extract an element from the nested list, we can proceed in two steps:</p>

<pre class="python-interpreter">
>>> elem = nested[3]
>>> elem[0]
10
</pre>

<p>Or we can combine them:</p>

<pre class="python-interpreter">
>>> nested[3][1]
20
</pre>

<p>Bracket operators evaluate from left to right, so this expression gets the
three-eth element of <code>nested</code> and extracts the one-eth element from
it.</p>


<h2>Matrices</h2>
<span class="index" value="matrix" />
<span class="index" value="list!nested" />

<p>Nested lists are often used to represent matrices.  For example, the
matrix:</p>

<img src="illustrations/matrix.png" />

<p>might be represented as:</p>

<pre class="python-interpreter">
>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</pre>

<p><code>matrix</code> is a list with three elements, where each element is a
row of the matrix.  We can select an entire row from the matrix in the usual
way:</p>

<pre class="python-interpreter">
>>> matrix[1]
[4, 5, 6]
</pre>

<p>Or we can extract a single element from the matrix using the double-index
form:</p>

<pre class="python-interpreter">
>>> matrix[1][1]
5
</pre>

<span class="index" value="row" />
<span class="index" value="column" />

<p>The first index selects the row, and the second index selects the column.
Although this way of representing matrices is common, it is not the only
possibility.  A small variation is to use a list of columns instead of a list
of rows.  Later we will see a more radical alternative using a dictionary.</p>


<h2>Strings and lists</h2>
<span class="index" value="command!list" />
<span class="index" value="command!str" />
<span class="index" value="join function" />
<span class="index" value="split function" />

<p>Python has a command called <code>list</code> that takes a sequence
type as an argument and creates a list out of its elements.
</p>

<pre class="python-interpreter">
>>> list("Crunchy Frog")
['C', 'r', 'u', 'n', 'c', 'h', 'y', ' ', 'F', 'r', 'o', 'g']
</pre>

<p>There is also a <code>str</code> command that takes any Python value as an
argument and returns a string representation of it.
</p>

<pre class="python-interpreter">
>>> str(5)
'5'
>>> str(None)
'None'
>>> str(list("nope"))
"['n', 'o', 'p', 'e']"
</pre>

<p>As we can see from the last example, <code>str</code> can't be used to join
a list of characters together.  To do this we could use the <code>join</code>
function in the <code>string</code> module:
</p>

<pre class="python-interpreter">
>>> import string
>>> char_list = list("Frog")
>>> char_list
['F', 'r', 'o', 'g']
>>> string.join(char_list, '')
'Frog'
</pre>

<p>Two of the most useful functions in the <code>string</code> module involve
lists of strings.  The <code>split</code> function breaks a string into a list
of words.  By default, any number of whitespace characters is considered a word 
boundary:</p>

<pre class="python-interpreter">
>>> import string
>>> song = "The rain in Spain..."
>>> string.split(song)
['The', 'rain', 'in', 'Spain...']
</pre>

<p>An optional argument called a <b>delimiter</b> can be used to
specify which characters to use as word boundaries.  The following example uses 
the string <code>ai</code> as the delimiter:</p>

<pre class="python-interpreter">
>>> string.split(song, 'ai')
['The r', 'n in Sp', 'n...']
</pre>

<p>Notice that the delimiter doesn't appear in the list.</p>

<p><code>string.join</code> is the inverse of <code>string.split</code>.  It
takes two arguments: a list of strings and a <em>seperator</em> which will be
placed between each element in the list in the resultant string.</p>

<pre class="python-interpreter">
>>> import string
>>> words = ['crunchy', 'raw', 'unboned', 'real', 'dead', 'frog']
>>> string.join(words, ' ')
'crunchy raw unboned real dead frog'
>>> string.join(words, '**')
'crunchy**raw**unboned**real**dead**frog'
</pre>


<h2>Glossary</h2>
<span class="index" value="list" />
<span class="index" value="index" />
<span class="index" value="sequence" />
<span class="index" value="element" />
<span class="index" value="nested list" />
<span class="index" value="step size" />
<span class="index" value="list traversal" />
<span class="index" value="mutable type" />
<span class="index" value="object" />
<span class="index" value="aliasing" />
<span class="index" value="clone" />
<span class="index" value="modifier" />
<span class="index" value="side effect" />
<span class="index" value="pure function" />
<span class="index" value="delimiter" />

<dl>
<dt>list:</dt>
<dd>A named collection of objects, where each object is identified by an index.
</dd>

<dt>index:</dt>
<dd>An integer variable or value that indicates an element of a list.</dd>

<dt>element:</dt>
<dd>One of the values in a list (or other sequence).  The bracket operator
selects elements of a list.</dd>

<dt>sequence:</dt>
<dd>Any of the data types that consist of an ordered set of elements, with each 
element identified by an index.</dd>

<dt>nested list:</dt>
<dd>A list that is an element of another list.</dd>

<dt>step size:</dt>
<dd>The interval between successive elements of a linear sequence.  The third
(and optional argument) to the <code>range</code> function is called the
step size. If not specified, it defaults to 1.</dd>

<dt>list traversal:</dt>
<dd>The sequential accessing of each element in a list.</dd>

<dt>mutable type:</dt>
<dd>A data type in which the elements can be modified.  All mutable types are
compound types.  Lists are mutable data types; strings are not.</dd>

<dt>object:</dt>
<dd>A thing to which a variable can refer.</dd>

<dt>aliases:</dt>
<dd>Multiple variables that contain references to the same object.</dd>

<dt>clone:</dt>
<dd>To create a new object that has the same value as an existing object.
Copying a reference to an object creates an alias but doesn't clone the object.
</dd>

<dt>modifier:</dt>
<dd>A function which changes its arguments inside the function body.
Only mutable types can be changed by modifiers.</dd>

<dt>side effect:</dt>
<dd>A change in the state of a program made by calling a function that is
not a result of reading the return value from the function.  Side effects
can only be produced by modifiers.</dd>

<dt>pure function:</dt>
<dd>A function which has no side effects.  Pure functions only make changes
to the calling program through their return values.</dd>

<dt>delimiter:</dt>
<dd>A character or string used to indicate where a string should be split.</dd>
</dl>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
Write a loop that traverses:
<pre class="python">
['spam!', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
</pre>
and prints the length of each element.  What happens if you send an integer
to <code>len</code>?  Change <code>1</code> to <code>'one'</code> and run
your solution again.
</div></li>

<li><div class="exercise">
Open a file named <code>ch09e02.py</code> and with the following content:
<pre class="python">
#  Add your doctests here:
"""
"""

# Write your Python code here:


if __name__ == '__main__':
    import doctest
    doctest.testmod() 
</pre>
Add each of the following sets of doctests to the docstring at the top
of the file and write Python code to make the doctests pass.
<ol style="list-style-type: lower-alpha">
<li><pre class="python">
"""
  >>> a_list[3]
  42
  >>> a_list[6]
  'Ni!'
  >>> len(a_list)
  8
"""
</pre></li>
<li><pre class="python">
"""
  >>> b_list[1:]
  ['Stills', 'Nash']
  >>> group = b_list + c_list
  >>> group[-1]
  'Young'
"""
</pre></li>
<li><pre class="python">
"""
  >>> 'war' in mystery_list
  False
  >>> 'peace' in mystery_list
  True
  >>> 'justice' in mystery_list
  True
  >>> 'oppression' in mystery_list
  False
  >>> 'equality' in mystery_list
  True
"""
</pre></li>
<li><pre class="python">
"""
  >>> range(a, b, c)
  [5, 9, 13, 17]
"""
</pre></li>
</ol>
Only add one set of doctests at a time.  The next set of doctests should
not be added until the previous set pass.
</div></li>

<li><div class="exercise">
What is the Python interpreter's response to the following?
<pre class="python-interpreter">
>>> range(10, 0, -2) 
</pre>
The three arguments to the <em>range</em> function are <em>start</em>,
<em>stop</em>, and <em>step</em>, respectively.  In this example,
<code>start</code> is greater than <code>stop</code>.  What happens if
<code>start &lt; stop</code> and <code>step &lt; 0</code>?  Write a rule
for the relationships among <code>start</code>, <code>stop</code>, and
<code>step</code>.
</div></li>

<li><div class="exercise">
<pre class="python">
a = [1, 2, 3]
b = a[:]
b[0] = 5
</pre>
Draw a state diagram for <code>a</code> and <code>b</code> before and after
the third line is executed.
</div></li>

<li><div class="exercise">
What will be the output of the following program?
<pre class="python">
this = ['I', 'am', 'not', 'a', 'crook']
that = ['I', 'am', 'not', 'a', 'crook']
print "Test 1: %s" % (id(this) == id(that))
that = this
print "Test 2: %s" % (id(this) == id(that))
</pre>
Provide a <em>detailed</em> explaination of the results.
</div></li>

<li><div class="exercise">
Open a file named <code>ch09e07.py</code> and use the same proceedure as
in exercise 2 to make the following doctests pass: 
<ol style="list-style-type: lower-alpha">
<li><pre class="python">
"""
  >>> 
"""
</pre></li>
</ol>
</div></li>

<li><div class="exercise">
<pre class="python">
import string

song = "The rain in Spain..."
</pre>
Describe the relationship between <code>string.join(string.split(song))</code>
and <code>song</code>.  Are they the same for all strings?  When would they be
different?
</div></li>
</ol>

</body>
</html>
