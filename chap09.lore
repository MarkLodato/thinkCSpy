<html>
<head>
  <title>Lists</title>
</head>
<body>

<h1>Lists</h1>
<span class="index" value="list" />
<span class="index" value="data type!list" />
<span class="index" value="element" />
<span class="index" value="sequence" />
<span class="index" value="nested list" />
<span class="index" value="list!nested" />
<span class="index" value="data type!mutable" />


<p>A <b>list</b> is an ordered set of values, where each value is identified by 
an index.  The values that make up a list are called its <b>elements</b>.
Lists are similar to strings, which are ordered sets of characters, except that 
the elements of a list can have any type.  Lists and strings---and other things 
that behave like ordered sets---are called <b>sequences</b>.</p>


<h2>List values</h2>

<p>There are several ways to create a new list; the simplest is to
enclose the elements in square brackets (<code>[</code> and <code>]</code>):
</p>

<pre class="python">
[10, 20, 30, 40]
["spam", "bungee", "swallow"]
</pre>

<p>The first example is a list of four integers.  The second is a list of three 
strings.  The elements of a list don't have to be the same type.  The following 
list contains a string, a float, an integer, and (mirabile dictu) another
list:</p>

<pre class="python">
["hello", 2.0, 5, [10, 20]]
</pre>

<p>A list within another list is said to be <b>nested</b>.</p>

<span class="index" value="list!nested" />

<p>Lists that contain consecutive integers are common, so Python provides a
simple way to create them:</p>

<pre class="python-interpreter">
>>> range(1, 5)
[1, 2, 3, 4]
</pre>

<p>The <code>range</code> function takes two arguments and returns a list that
contains all the integers from the first to the second, including the first but 
not including the second!</p>

<p>There are two other forms of <code>range</code>.  With a single argument, it
creates a list that starts at 0:</p>

<pre class="python-interpreter">
>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>

<p>If there is a third argument, it specifies the space between successive
values, which is called the <b>step size</b>.  This example counts
from 1 to 10 by steps of 2:</p>

<pre class="python-interpreter">
>>> range(1, 10, 2)
[1, 3, 5, 7, 9]
</pre>

<p>Finally, there is a special list that contains no elements.  It is called
the empty list, and is denoted <code>[]</code>.</p>

<p>With all these ways to create lists, it would be disappointing if we
couldn't assign list values to variables or pass lists as parameters to
functions.  We can:</p>

<pre class="python-interpreter">
>>> vocabulary = ["ameliorate", "castigate", "defenestrate"]
>>> numbers = [17, 123]
>>> empty = []
>>> print vocabulary, numbers, empty
['ameliorate', 'castigate', 'defenestrate'] [17, 123] []
</pre>


<h2>Accessing elements</h2>
<span class="index" value="list!element"/>

<p>The syntax for accessing the elements of a list is the same as the syntax
for accessing the characters of a string---the bracket operator
(<code>[]</code> -- not to be confused with an empty list).  The expression
inside the brackets specifies the index.  Remember that the indices start at
0:</p>

<pre class="python">
>>> print numbers[0]
17
</pre>

<p>Any integer expression can be used as an index:</p>

<pre class="python-interpreter">
>>> numbers[9-8]
5
>>> numbers[1.0]
TypeError: list indices must be integers
</pre>

<p>If you try to read or write an element that does not exist, you get a
runtime error:</p>

<span class="index" value="runtime error" />

<pre class="python-interpreter">
>>> numbers[2] = 5
IndexError: list assignment index out of range
</pre>

<p>If an index has a negative value, it counts backward from the end of the
list:</p>

<pre class="python-interpreter">
>>> numbers[-1]
5
>>> numbers[-2]
17
>>> numbers[-3]
IndexError: list index out of range
</pre>

<p><code>numbers[-1]</code> is the last element of the list,
<code>numbers[-2]</code> is the second to last, and <code>numbers[-3]</code>
doesn't exist.</p>

<p>It is common to use a loop variable as a list index.</p>

<pre class="python">
horsemen = ["war", "famine", "pestilence", "death"]
   
i = 0
while i &lt; 4:
    print horsemen[i]
    i += 1
</pre>

<p>This <code>while</code> loop counts from 0 to 4.  When the loop variable
<code>i</code> is 4, the condition fails and the loop terminates.  So the
body of the loop is only executed when <code>i</code> is 0, 1, 2, and 3.</p>

<p>Each time through the loop, the variable <code>i</code> is used as an index
into the list, printing the <code>i</code>-eth element.  This pattern of
computation is called a <b>list traversal</b>.</p>

<span class="index" value="list!traversal" />
<span class="index" value="traversal!list" />


<h2>List length</h2>
<span class="index" value="length" />
<span class="index" value="list!length" />

<p>The function <code>len</code> returns the length of a list, which is equal
to the number of its elements.  It is a good idea to use this value as the
upper bound of a loop instead of a constant.  That way, if the size of the list 
changes, you won't have to go through the program changing all the loops; they
will work correctly for any size list:</p>

<pre class="python">
horsemen = ["war", "famine", "pestilence", "death"]
   
i = 0
num = len(horsemen)
while i &lt; num:
    print horsemen[i]
    i += 1
</pre>

<p>The last time the body of the loop is executed, <code>i</code> is
<code>len(horsemen) - 1</code>, which is the index of the last element.  When
<code>i</code> is equal to <code>len(horsemen)</code>, the condition fails and
the body is not executed, which is a good thing, because
<code>len(horsemen)</code> is not a legal index.</p>

<p>Although a list can contain another list, the nested list still counts as a
single element.  The length of this list is 4:</p>

<pre class="python">
['spam!', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
</pre>


<h2>List membership</h2>
<span class="index" value="list!membership" />
<span class="index" value="in operator" />
<span class="index" value="operator!in" />

<p><code>in</code> is a boolean operator that tests membership in a sequence.
We used it previously with strings, but it also works with lists and other
sequences:</p>

<pre class="python-interpreter">
>>> horsemen = ['war', 'famine', 'pestilence', 'death']
>>> 'pestilence' in horsemen
True
>>> 'debauchery' in horsemen
False
</pre>

<p>Since <q>pestilence</q> is a member of the <code>horsemen</code> list, the
<code>in</code> operator returns <code>True</code>.  Since <q>debauchery</q> is 
not in the list, <code>in</code> returns <code>False</code>.</p>

<p>We can use the <code>not</code> in combination with <code>in</code> to test
whether an element is not a member of a list:</p>

<pre class="python">
>>> 'debauchery' not in horsemen
True
</pre>


<h2>Lists and <code>for</code> loops</h2>
<span class="index" value="for loop" />
<span class="index" value="list!for loop" />
<span class="index" value="traversal" />

<p>The <code>for</code> loop also works with lists.  The generalized syntax of
a <code>for</code> loop is:</p>

<pre>
for VARIABLE in LIST:
    BODY
</pre>

<p>This statement is equivalent to:</p>

<pre class="python">
i = 0
while i &lt; len(LIST):
    VARIABLE = LIST[i]
    BODY
    i = i + 1
</pre>

<p>The <code>for</code> loop is more concise because we can eliminate the loop
variable, <code>i</code>.  Here is the previous loop written with a
<code>for</code> loop.</p>

<pre class="python">
for horseman in horsemen:
    print horseman
</pre>

<p>It almost reads like English: <q>For (every) horseman in (the list of)
horsemen, print (the name of the) horseman.</q></p>

<p>Any list expression can be used in a <code>for</code> loop:</p>

<pre class="python">
for number in range(20):
    if number % 2 == 0:
        print  number
   
for fruit in ["banana", "apple", "quince"]:
    print "I like to eat " + fruit + "s!"
</pre>

<p>The first example prints all the even numbers between one and nineteen.
The second example expresses enthusiasm for various fruits.</p>


<h2>List operations</h2>
<span class="index" value="list operation" />
<span class="index" value="operation!list" />

<p>The <code>+</code> operator concatenates lists:</p>

<span class="index" value="concatenation!list" />

<pre class="python-interpreter">
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print c
[1, 2, 3, 4, 5, 6]
</pre>

<p>Similarly, the <code>*</code> operator repeats a list a given number of
times:</p>

<span class="index" value="repetition!list" />

<pre class="python-interpreter">
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
</pre>

<p>The first example repeats <code>[0]</code> four times.  The second example
repeats the list <code>[1, 2, 3]</code> three times.</p>


<h2>List slices</h2>
<span class="index" value="slice" />
<span class="index" value="list!slice" />

<p>The slice operations we saw with strings also work on lists:</p>

<pre class="python-interpreter">
>>> a_list = ['a', 'b', 'c', 'd', 'e', 'f']
>>> a_list[1:3]
['b', 'c']
>>> a_list[:4]
['a', 'b', 'c', 'd']
>>> a_list[3:]
['d', 'e', 'f']
>>> a_list[:]
['a', 'b', 'c', 'd', 'e', 'f']
</pre>


<h2>Lists are mutable</h2>
<span class="index" value="mutable" />
<span class="index" value="sequence!mutable" />
<span class="index" value="data type!mutable" />

<p>Unlike strings, lists are <b>mutable</b>, which means we can change their
elements.  Using the bracket operator on the left side of an assignment, we can update one of the elements:</p>

<pre class="python-interpreter">
>>> fruit = ["banana", "apple", "quince"]
>>> fruit[0] = "pear"
>>> fruit[-1] = "orange"
>>> print fruit
['pear', 'apple', 'orange']
</pre>

<p>The bracket operator applied to a list can appear anywhere in an expression.
When it appears on the left side of an assignment, it changes one of the
elements in the list, so the one-eth element of <code>numbers</code>, which
used to be 123, is now 5.  An assignment to an element of a list is called
<b>item assignment</b>.  Item assignment does not work for strings:</p>

<pre class="python-interpreter">
>>> my_string = 'TEST'
>>> my_string[2] = 'X'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'str' object does not support item assignment
</pre>

<p>but it does for lists:</p>

<pre class="python-interpreter">
>>> my_list = ['T', 'E', 'S', 'T']
>>> my_list[2] = 'X'
>>> my_list
['T', 'E', 'X', 'T']
</pre>

<p>With the slice operator we can update several elements at once:</p>

<pre class="python-interpreter">
>>> a_list = ['a', 'b', 'c', 'd', 'e', 'f']
>>> a_list[1:3] = ['x', 'y']
>>> print a_list
['a', 'x', 'y', 'd', 'e', 'f']
</pre>

<p>We can also remove elements from a list by assigning the empty list to
them:</p>

<pre class="python-interpreter">
>>> a_list = ['a', 'b', 'c', 'd', 'e', 'f']
>>> a_list[1:3] = []
>>> print a_list
['a', 'd', 'e', 'f']
</pre>

<p>And we can add elements to a list by squeezing them into an empty slice at
the desired location:</p>

<pre class="python-interpreter">
>>> a_list = ['a', 'd', 'f']
>>> a_list[1:1] = ['b', 'c']
>>> print a_list
['a', 'b', 'c', 'd', 'f']
>>> a_list[4:4] = ['e']
>>> print a_list
['a', 'b', 'c', 'd', 'e', 'f']
</pre>


<h2>List deletion</h2>
<span class="index" value="deletion!list" />
<span class="index" value="list deletion" />

<p>Using slices to delete list elements can be awkward, and therefore
error-prone.  Python provides an alternative that is more readable.</p>

<p><code>del</code> removes an element from a list:</p>

<pre class="python-interpreter">
>>> a = ['one', 'two', 'three']
>>> del a[1]
>>> a
['one', 'three']
</pre>

<p>As you might expect, <code>del</code> handles negative indices and causes a
runtime error if the index is out of range.</p>

<p>You can use a slice as an index for <code>del</code>:</p>

<pre class="python-interpreter">
>>> a_list = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del a_list[1:5]
>>> print a_list
['a', 'f']
</pre>

<p>As usual, slices select all the elements up to, but not including, the
second index.</p>


<h2>Converting strings to lists</h2>
<span class="index" value="function!list" />
<span class="index" value="join function" />

<p>Python has a command called <code>list</code> that takes a sequence
type as an argument and creates a list out of its elements.
</p>

<pre class="python-interpreter">
>>> list("Crunchy Frog")
['C', 'r', 'u', 'n', 'c', 'h', 'y', ' ', 'F', 'r', 'o', 'g']
</pre>

<p>There is also a <code>str</code> command that takes any Python value as an
argument and returns a string representation of it.
</p>

<pre class="python-interpreter">
>>> str(5)
'5'
>>> str(None)
'None'
>>> str(list("nope"))
"['n', 'o', 'p', 'e']"
</pre>

<p>As we can see from the last example, <code>str</code> can't be used to join
a list of characters together.  To do this we could use the <code>join</code>
function in the <code>string</code> module:
</p>

<pre class="python-interpreter">
>>> import string
>>> char_list = list("Frog")
>>> char_list
['F', 'r', 'o', 'g']
>>> string.join(char_list, '')
'Frog'
</pre>

<p><code>string.join</code> takes two arguments: a list of strings and a
<em>seperator</em> which will be placed between each element in the list in the
resultant string.</p>

<pre class="python-interpreter">
>>> import string
>>> words = ['crunchy', 'raw', 'unboned', 'real', 'dead', 'frog']
>>> string.join(words, ' ')
'crunchy raw unboned real dead frog'
>>> string.join(words, '**')
'crunchy**raw**unboned**real**dead**frog'
</pre>


<h2>Objects and values</h2>
<span class="index" value="object" />
<span class="index" value="value" />

<p>If we execute these assignment statements,</p>

<pre class="python">
a = "banana"
b = "banana"
</pre>

<p>we know that <code>a</code> and <code>b</code> will refer to a string with
the letters <code>"banana"</code>.  But we can't tell whether they point to the 
<em>same</em> string.</p>

<p>There are two possible states:</p>

<img src="illustrations/list1.png" />

<p>In one case, <code>a</code> and <code>b</code> refer to two different things
that have the same value.  In the second case, they refer to the same thing.
These <q>things</q> have names---they are called <b>objects</b>.
An object is something a variable can refer to.</p>

<p>Every object has a unique <b>identifier</b>, which we can obtain
with the <code>id</code> function.  By printing the identifier of <code>a</code>
and <code>b</code>, we can tell whether they refer to the same object.</p>

<pre class="python-interpreter">
>>> id(a)
135044008
>>> id(b)
135044008
</pre>

<p>In fact, we get the same identifier twice, which means that Python only
created one string, and both <code>a</code> and <code>b</code> refer to it.
Your actual id value will be probably be different.</p>

<p>Interestingly, lists behave differently.  When we create two lists, we get
two objects:</p>

<pre class="python-interpreter">
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> id(a)
135045528
>>> id(b)
135041704
</pre>

<p>So the state diagram looks like this:</p>

<img src="illustrations/list2.png" />

<p><code>a</code> and <code>b</code> have the same value but do not refer to
the same object.</p>


<h2>Aliasing</h2>
<span class="index" value="aliasing" />
<span class="index" value="reference!aliasing" />

<p>Since variables refer to objects, if we assign one variable to another, both 
variables refer to the same object:</p>

<pre class="python-interpreter">
>>> a = [1, 2, 3]
>>> b = a
>>> id(a) == id(b)
True
</pre>

<p>In this case, the state diagram looks like this:</p>

<img src="illustrations/list3.png" />

<p>Because the same list has two different names, <code>a</code> and
<code>b</code>, we say that it is <b>aliased</b>.  Changes made with
one alias affect the other:</p>

<pre class="python-interpreter">
>>> b[0] = 5
>>> print a
[5, 2, 3]
</pre>

<p>Although this behavior can be useful, it is sometimes unexpected or
undesirable.  In general, it is safer to avoid aliasing when you are working
with mutable objects.  Of course, for immutable objects, there's no problem.
That's why Python is free to alias strings when it sees an opportunity to
economize.</p>


<h2>Cloning lists</h2>
<span class="index" value="list!cloning" />
<span class="index" value="cloning" />

<p>If we want to modify a list and also keep a copy of the original, we need to 
be able to make a copy of the list itself, not just the reference.  This
process is sometimes called <b>cloning</b>, to avoid the ambiguity of 
the word <q>copy.</q></p>

<p>The easiest way to clone a list is to use the slice operator:</p>

<pre class="python-interpreter">
>>> a = [1, 2, 3]
>>> b = a[:]
>>> print b
[1, 2, 3]
</pre>

<p>Taking any slice of <code>a</code> creates a new list.  In this case the
slice happens to consist of the whole list.</p>

<p>Now we are free to make changes to <code>b</code> without worrying about
<code>a</code>:</p>

<pre class="python-interpreter">
>>> b[0] = 5
>>> print a
[1, 2, 3]
</pre>


<h2>List parameters</h2>
<span class="index" value="list!as parameter" />
<span class="index" value="parameter" />
<span class="index" value="parameter!list" />

<p>Passing a list as an argument actually passes a reference to the list, not a 
copy of the list.  For example, the function <code>head</code> takes a list as
an argument and returns the first element:</p>

<pre class="python">
def head(a_list):
    return a_list[0]
</pre>

<p>Here's how it is used:</p>

<pre class="python-interpreter">
>>> numbers = [1, 2, 3]
>>> head(numbers)
1
</pre>

<p>The parameter <code>a_list</code> and the variable <code>numbers</code> are
aliases for the same object.  The state diagram looks like this:</p>

<img src="illustrations/stack5.png" />

<p>Since the list object is shared by two frames, we drew it between them.</p>

<p>If a function modifies a list parameter, the caller sees the change.  For
example, <code>delete_head</code> removes the first element from a list:</p>

<pre class="python">
def delete_head(a_list):
    del a_list[0]
</pre>

<p>Here's how <code>delete_head</code> is used:</p>

<pre class="python-interpreter">
>>> numbers = [1, 2, 3]
>>> delete_head(numbers)
>>> print numbers
[2, 3]
</pre>

<p>If a function returns a list, it returns a reference to the list.  For
example, <code>tail</code> returns a list that contains all but the first
element of the given list:</p>

<pre class="python">
def tail(a_list):
    return a_list[1:]
</pre>

<p>Here's how <code>tail</code> is used:</p>

<pre class="python-interpreter">
>>> numbers = [1, 2, 3]
>>> rest = tail(numbers)
>>> print rest
[2, 3]
</pre>

<p>Because the return value was created with the slice operator, it is a new
list.  Creating <code>rest</code>, and any subsequent changes to
<code>rest</code>, have no effect on <code>numbers</code>.</p>


<h2>Nested lists</h2>
<a name="nested lists" />
<span class="index" value="nested list" />
<span class="index" value="list!nested" />

<p>A nested list is a list that appears as an element in another list.  In this 
list, the element with index 3 is a nested list:</p>

<pre class="python-interpreter">
>>> nested = ["hello", 2.0, 5, [10, 20]]
</pre>

<p>If we print <code>nested[3]</code>, we get <code>[10, 20]</code>.  To
extract an element from the nested list, we can proceed in two steps:</p>

<pre class="python-interpreter">
>>> elem = nested[3]
>>> elem[0]
10
</pre>

<p>Or we can combine them:</p>

<pre class="python-interpreter">
>>> nested[3][1]
20
</pre>

<p>Bracket operators evaluate from left to right, so this expression gets the
three-eth element of <code>nested</code> and extracts the one-eth element from
it.</p>


<h2>Matrixes</h2>
<span class="index" value="matrix" />
<span class="index" value="list!nested" />

<p>Nested lists are often used to represent matrices.  For example, the
matrix:</p>

<img src="illustrations/matrix.png" />

<p>might be represented as:</p>

<pre class="python-interpreter">
>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</pre>

<p><code>matrix</code> is a list with three elements, where each element is a
row of the matrix.  We can select an entire row from the matrix in the usual
way:</p>

<pre class="python-interpreter">
>>> matrix[1]
[4, 5, 6]
</pre>

<p>Or we can extract a single element from the matrix using the double-index
form:</p>

<pre class="python-interpreter">
>>> matrix[1][1]
5
</pre>

<p>The first index selects the row, and the second index selects the column.
Although this way of representing matrices is common, it is not the only
possibility.  A small variation is to use a list of columns instead of a list
of rows.  Later we will see a more radical alternative using a dictionary.</p>

<span class="index" value="dictionary" />
<span class="index" value="row" />
<span class="index" value="column" />


<h2>Strings and lists</h2>
<span class="index" value="split function" />

<p>Two of the most useful functions in the <code>string</code> module involve
lists of strings.  The <code>split</code> function breaks a string into a list
of words.  By default, any number of whitespace characters is considered a word 
boundary:</p>

<pre class="python-interpreter">
>>> import string
>>> song = "The rain in Spain..."
>>> string.split(song)
['The', 'rain', 'in', 'Spain...']
</pre>

<p>An optional argument called a <b>delimiter</b> can be used to
specify which characters to use as word boundaries.  The following example uses 
the string <code>ai</code> as the delimiter:</p>

<pre class="python-interpreter">
>>> string.split(song, 'ai')
['The r', 'n in Sp', 'n...']
</pre>

<p>Notice that the delimiter doesn't appear in the list.</p>

<p>The <code>join</code> function we saw in section 9.10 is the inverse of
<code>split</code>.</p>


<h2>The <code>sys</code> module and <code>argv</code></h2>
<span class="index" value="sys module" />
<span class="index" value="module!sys" />
<span class="index" value="argv" />
<span class="index" value="command line arguments" />

<p>The <code>sys</code> module contains a variable named <code>argv</code>,
which holds a list of strings read in from the <b>command line</b> when
a Python script is run.  These <b>command line arguments</b> can be used to
pass information into a program at the same time it is invoked.</p>

<pre class="python">
#
# demo_argv.py
#
import sys

print "And the command-line arguments are:"
for i in range(len(sys.argv)):
    print "    argument number %d is %s" % (i, sys.argv[i])
</pre>

<p>Running this program from the unix command prompt demonstrates how
<code>sys.argv</code> works:</p>

<pre class="shell">
$ python demo_argv.py this and that 1 2 3
And the command-line arguments are:
    argument number 0 is demo_argv.py
    argument number 1 is this
    argument number 2 is and
    argument number 3 is that
    argument number 4 is 1
    argument number 5 is 2
    argument number 6 is 3
$ 
</pre>

<p>Arguments are seperated by white space.  If you want an argument with white
space in it, use quotes:</p>

<pre class="shell">
$ python demo_argv.py "this and" that "1 2" 3
And the command-line arguments are:
    argument number 0 is demo_argv.py
    argument number 1 is this and
    argument number 2 is that
    argument number 3 is 1 2
    argument number 4 is 3
$ 
</pre>


<h2>Reading and writing text files</h2>
<span class="index" value="file" />

<p>While a program is running, its data is in memory.  When the program ends,
or the computer shuts down, data in memory disappears.  To store data
permanently, you have to put it in a <b>file</b>.  Files are usually stored on
a hard drive, usb drive, or CD.</p>

<p>When there are a large number of files, they are often organized into
<b>directories</b> (also called <q>folders</q>).  Each file is identified by a
unique name, or a combination of a file name and a directory name.</p>

<p>By reading and writing files, programs can exchange information with each
other and generate printable formats like PDF.</p>

<p>Working with files is a lot like working with a notebook.  To use a
notebook, you have to open it.  When you're done, you have to close it.  While
the notebook is open, you can either write in it or read from it.  In either
case, you know where you are in the notebook.  You can read the whole notebook
in its natural order or you can skip around.</p>

<p>All of this applies to files as well.  To open a file, you specify its name
and indicate whether you want to read or write.</p>

<p>Opening a file creates a file object.  In this example, the variable
<code>f</code> refers to the new file object.</p>

<pre class="python-interpreter">
>>> f = open('test.dat', 'w')
>>> print f
&lt;open file 'test.dat', mode 'w' at 0x2aaaaab80cd8&gt;
</pre>

<p>The open function takes two arguments.  The first is the name of the file,
and the second is the <b>mode</b>.  Mode <code>'w'</code> means that we are
opening the file for writing.</p>

<p>If there is no file named <code>test.dat</code>, it will be created.  If
there already is one, it will be replaced by the file we are writing.</p>

<p>When we print the file object, we see the name of the file, the mode, and
the location of the object.</p>

<p>To put data in the file we invoke the <code>write</code> method on the file
object:</p>

<pre class="python-interpreter">
>>> f.write("Now is the time")
>>> f.write("to close the file")
</pre>

<p>Closing the file tells the system that we are done writing and makes the
file available for reading:</p>

<pre class="python-interpreter">
>>> f.close()
</pre>

<p>Now we can open the file again, this time for reading, and read the contents 
into a string.  This time, the mode argument is <code>'r'</code> for reading:
</p>

<pre class="python-interpreter">
>>> f = open('test.dat', 'r')
</pre>

<p>If we try to open a file that doesn't exist, we get an error:</p>

<span class="index" value="runtime error" />

<pre class="python-interpreter">
>>> f = open('test.cat', 'r')
IOError: [Errno 2] No such file or directory: 'test.cat'
</pre>

<p>Not surprisingly, the <code>read</code> method reads data from the file.
With no arguments, it reads the entire contents of the file into a single
string:</p>

<pre class="python-interpreter">
>>> text = f.read()
>>> print text
Now is the timeto close the file
</pre>

<p>There is no space between <q>time</q> and <q>to</q> because we did not write 
a space between the strings.</p>

<p><code>read</code> can also take an argument that indicates how many
characters to read:</p>

<pre class="python-interpreter">
>>> f = open('test.dat', 'r')
>>> print f.read(5)
Now i
</pre>

<p>If not enough characters are left in the file, <code>read</code> returns the 
remaining characters.  When we get to the end of the file, <code>read</code>
returns the empty string:</p>

<pre class="python-interpreter">
>>> print f.read(1000006)
s the timeto close the file
>>> print f.read()
   
>>>
</pre>

<p>The following function copies a file, reading and writing up to fifty
characters at a time.  The first argument is the name of the original file; the 
second is the name of the new file:</p>

<pre class="python">
def copy_file(old_file, new_file):
    f1 = open(old_file, 'r')
    f2 = open(new_file, 'w')
    while True:
        text = f1.read(50)
        if text == "":
            break
        f2.write(text)
    f1.close()
    f2.close()
    return
</pre>

<p>This functions continues looping, reading 50 characters from <code>f1</code>
and writing the same 50 charaters to <code>f2</code> until the end of
<code>f1</code> is reached, at which point <code>text</code> is empty and the
<code>break</code> statement is executed.</p>


<h2>Text files</h2>
<span class="index" value="text file" />
<span class="index" value="file!text" />

<p>A <b>text file</b> is a file that contains printable characters and
whitespace, organized into lines separated by newline characters.  Since Python 
is specifically designed to process text files, it provides methods that make
the job easy.</p>

<p>To demonstrate, we'll create a text file with three lines of text separated
by newlines:</p>

<pre class="python-interpreter">
>>> f = open("test.dat","w")
>>> f.write("line one\nline two\nline three\n")
>>> f.close()
</pre>

<p>The <code>readline</code> method reads all the characters up to and
including the next newline character:</p>

<pre class="python-interpreter">
>>> f = open("test.dat","r")
>>> print f.readline()
line one
   
>>>
</pre>

<p><code>readlines</code> returns all of the remaining lines as a list of
strings:</p>

<pre class="python-interpreter">
>>> print f.readlines()
['line two\012', 'line three\012']
</pre>

<p>In this case, the output is in list format, which means that the strings
appear with quotation marks and the newline character appears as the escape
sequence <code>\\012</code>.</p>

<p>At the end of the file, <code>readline</code> returns the empty string
and <code>readlines</code> returns the empty list:</p>

<pre class="python-interpreter">
>>> print f.readline()
   
>>> print f.readlines()
[]
</pre>

<p>The following is an example of a line-processing program.
<code>filterFile</code> makes a copy of <code>oldFile</code>, omitting any
lines that begin with <code>#</code>:</p>

<pre class="python">
def filterFile(oldFile, newFile):
    f1 = open(oldFile, "r")
    f2 = open(newFile, "w")
    while True:
        text = f1.readline()
        if text == "":
           break
        if text[0] == '#':
           continue
        f2.write(text)
    f1.close()
    f2.close()
    return
</pre>

<p>The <code>continue</code> statement ends the current iteration of the loop,
but continues looping.  The flow of execution moves to the top of the loop,
checks the condition, and proceeds accordingly.</p>

<span class="index" value="continue statement" />
<span class="index" value="statement!continue" />

<p>Thus, if <code>text</code> is the empty string, the loop exits.  If the
first character of <code>text</code> is a hash mark, the flow of execution goes 
to the top of the loop.  Only if both conditions fail do we copy
<code>text</code> into the new file.</p>


<h2>Writing variables</h2>
<span class="index" value="format operator" />
<span class="index" value="format string" />
<span class="index" value="operator!format" />

<p>The argument of <code>write</code> has to be a string, so if we want to put
other values in a file, we have to convert them to strings first.  The easiest
way to do that is with the <code>str</code> function:</p>

<pre class="python-interpreter">
>>> x = 52
>>> f.write (str(x))
</pre>

<p>An alternative is to use the <b>format operator</b>,
<code>%</code>.  When applied to integers, <code>%</code> is the modulus
operator.  But when the first operand is a string, <code>%</code> is the format 
operator.</p>

<p>The first operand is the <b>format string</b>, and the second
operand is a tuple of expressions.  The result is a string that contains
the values of the expressions, formatted according to the format string.</p>

<p>As a simple example, the <b>format sequence</b> <code>"%d"</code>
means that the first expression in the tuple should be formatted as an integer. 
Here the letter <em>d</em> stands for <q>decimal</q>:</p>

<pre class="python-interpreter">
>>> cars = 52
>>> "%d" % cars
'52'
</pre>

<p>The result is the string <code>'52'</code>, which is not to be confused
with the integer value <code>52</code>.</p>

<p>A format sequence can appear anywhere in the format string, so we can embed
a value in a sentence:</p>

<pre class="python-interpreter">
>>> cars = 52
>>> "In July we sold %d cars." % cars
'In July we sold 52 cars.'
</pre>

<p>The format sequence <code>"%f"</code> formats the next item in the tuple as
a floating-point number, and <code>"%s"</code> formats the next item as a
string:</p>

<pre class="python-interpreter">
>>> "In %d days we made %f million %s." % (34,6.1,'dollars')
'In 34 days we made 6.100000 million dollars.'
</pre>

<p>By default, the floating-point format prints six decimal places.</p>

<p>The number of expressions in the tuple has to match the number of format
sequences in the string.  Also, the types of the expressions have to match the
format sequences:</p>

<span class="index" value="runtime error" />

<pre class="python-interpreter">
>>> "%d %d %d" % (1,2)
TypeError: not enough arguments for format string
>>> "%d" % 'dollars'
TypeError: illegal argument type for built-in operation
</pre>

<p>In the first example, there aren't enough expressions; in the second, the
expression is the wrong type.</p>

<p>For more control over the format of numbers, we can specify the number of
digits as part of the format sequence:</p>

<pre class="python-interpreter">
>>> "%6d" % 62
'    62'
>>> "%12f" % 6.1
'    6.100000'
</pre>

<p>The number after the percent sign is the minimum number of spaces the number 
will take up.  If the value provided takes fewer digits, leading spaces are
added.  If the number of spaces is negative, trailing spaces are added:</p>

<pre class="python-interpreter">
>>> "%-6d" % 62
'62    '
</pre>

<p>For floating-point numbers, we can also specify the number of digits after
the decimal point:</p>

<pre class="python-interpreter">
>>> "%12.2f" % 6.1
'        6.10'
</pre>

<p>In this example, the result takes up twelve spaces and includes two digits
after the decimal.  This format is useful for printing dollar amounts with the
decimal points aligned.</p>

<span class="index" value="dictionary" />

<p>For example, imagine a dictionary that contains student names as keys and
hourly wages as values.  Here is a function that prints the contents of the
dictionary as a formatted report:</p>

<pre class="python">
def report (wages) :
    students = wages.keys()
    students.sort()
    for student in students:
        print "%-20s %12.02f" % (student, wages[student])
</pre>

<p>To test this the function, we'll create a small dictionary and print the
contents:</p>

<pre class="python-interpreter">
>>> wages = {'mary': 6.23, 'joe': 5.45, 'joshua': 4.25}
>>> report (wages)
joe                          5.45
joshua                       4.25
mary                         6.23
</pre>

<p>By controlling the width of each value, we guarantee that the columns will
line up, as long as the names contain fewer than twenty-one characters and the
wages are less than one billion dollars an hour.</p>


<h2>Directories</h2>
<span class="index" value="directory" />

<p>When you create a new file by opening it and writing, the new file goes in
the current directory (wherever you were when you ran the program).  Similarly, 
when you open a file for reading, Python looks for it in the current directory.
</p>

<p>If you want to open a file somewhere else, you have to specify the
<b>path</b> to the file, which is the name of the directory
(or folder) where the file is located:</p>

<pre class="python-interpreter">
>>>   f = open("/usr/share/dict/words","r")
>>>   print f.readline()
Aarhus
</pre>

<p>This example opens a file named <code>words</code> that resides in a
directory named <code>dict</code>, which resides in <code>share</code>, which
resides in <code>usr</code>, which resides in the top-level directory of the
system, called <code>/</code>.</p>

<span class="index" value="path" />
<span class="index" value="delimiter" />

<p>You cannot use <code>/</code> as part of a filename; it is reserved as a
delimiter between directory and filenames.</p>

<p>The file <code>/usr/share/dict/words</code> contains a list of words
in alphabetical order, of which the first is the name of a Danish university.
</p>

<h2>Glossary</h2>
<span class="index" value="list" />
<span class="index" value="index" />
<span class="index" value="sequence" />
<span class="index" value="element" />
<span class="index" value="nested list" />
<span class="index" value="step size" />
<span class="index" value="list traversal" />
<span class="index" value="mutable type" />
<span class="index" value="object" />
<span class="index" value="aliasing" />
<span class="index" value="clone" />
<span class="index" value="delimiter" />
<span class="index" value="file" />
<span class="index" value="directory" />
<span class="index" value="path" />

<dl>
<dt>list:</dt>
<dd>A named collection of objects, where each object is identified by an index.
</dd>

<dt>index:</dt>
<dd>An integer variable or value that indicates an element of a list.</dd>

<dt>element:</dt>
<dd>One of the values in a list (or other sequence).  The bracket operator
selects elements of a list.</dd>

<dt>sequence:</dt>
<dd>Any of the data types that consist of an ordered set of elements, with each 
element identified by an index.</dd>

<dt>nested list:</dt>
<dd>A list that is an element of another list.</dd>

<dt>step size:</dt>
<dd>The interval between successive elements of a linear sequence.  The third
(and optional argument) to the <code>range</code> function is called the
step size. If not specified, it defaults to 1.</dd>

<dt>list traversal:</dt>
<dd>The sequential accessing of each element in a list.</dd>

<dt>mutable type:</dt>
<dd>A data type in which the elements can be modified.  All mutable types are
compound types.  Lists are mutable data types; strings are not.</dd>

<dt>object:</dt>
<dd>A thing to which a variable can refer.</dd>

<dt>aliases:</dt>
<dd>Multiple variables that contain references to the same object.</dd>

<dt>clone:</dt>
<dd>To create a new object that has the same value as an existing object.
Copying a reference to an object creates an alias but doesn't clone the object.
</dd>

<dt>delimiter:</dt>
<dd>A character or string used to indicate where a string should be split.</dd>

<dt>file:</dt>
<dd>A named entity, usually stored on a hard drive, floppy disk, or CD-ROM,
that contains a stream of characters.</dd>

<dt>directory:</dt>
<dd>A named collection of files, also called a folder.</dd>

<dt>mode:</dt>
<dd>A distinct method of operation within a computer program.  Files in Python
can be openned in one of three modes: read ('r'), write ('w'), and append ('a').
</dd>

<dt>path:</dt>
<dd>A sequence of directory names that specifies the exact location of a file.
</dd>

<dt>text file:</dt>
<dd>A file that contains printable characters organized into lines separated
by newline characters.</dd>

<dt>continue statement:</dt>
<dd>A statement that causes the current iteration of a loop to end.  The flow
of execution goes to the top of the loop, evaluates the condition, and
proceeds accordingly.</dd>
</dl>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
Write a loop that traverses:
<pre class="python">
['spam!', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
</pre>
and prints the length of each element.  What happens if you send an integer
to <code>len</code>?
</div></li>

<li><div class="exercise">
<pre class="python">
a = [1, 2, 3]
b = a[:]
b[0] = 5
</pre>
Draw a state diagram for <code>a</code> and <code>b</code> before and after
the third line is executed.
</div></li>

<li><div class="exercise">
<pre class="python">
import string

song = "The rain in Spain..."
</pre>
Describe the relationship between <code>string.join(string.split(song))</code>
and <code>song</code>.  Are they the same for all strings?  When would they be
different?
</div></li>
</ol>


</body>
</html>
