<html>
<head>
  <title>Case Study: Catch</title>
</head>
<body>

<h1>Case Study: Catch</h1>

<h2>Getting Started</h2>

<p>In our first case study we will build a small video game using the
facilities in the gasp package.  The game will shoot a ball across a window
from left to right and you will manipulate a <q>mitt</q> at the right side of
the window to catch it. From this program you will a chance to see a bit how
animated game programs work.</p>


<h2>Using <code>while</code> to move a ball</h2>

<p><code>while</code> statements can be used with <code>gasp</code> to add
motion to a program.  The program below moves a black ball across an 800x600
pixel graphics canvas:</p>

<pre class='python'>
from gasp import *

begin_graphics(800, 600, title="Catch", background=color.yellow)

x = 10
y = 300
ball = Circle((x, y), 10, filled=True)
dx = 4
dy = 1

while x &lt; 790:
    x += dx
    y += dy
    move_to(ball, (x, y))
    sleep(0.02)

end_graphics()
</pre>

<p>As the ball moves across the screen, you will see a graphics window that
looks like this:</p>

<img src="illustrations/gasp03.png" />

<p>Trace the first few iterations of this program to be sure you see what is
happening to the variables <code>x</code> and <code>y</code>.</p>

<p>Some new things to learn about GASP from this example:</p>

<ul>
  <li><code>begin_graphics</code> can take arguments for width, height,
  title, and background color of the graphics canvas.</li>

  <li>Adding <code>filled=True</code> to <code>Circle(...)</code> makes
  the resulting circle solid.</li>

  <li><code>ball = Circle</code> stores the circle (we will talk later
  about what a circle actually is) in a variable named <code>ball</code>
  so that it can be referenced later.</li>

  <li>The <code>move_to</code> function in GASP allows a programmer to
  pass in a shape (the ball in this case) and a location, and moves the
  shape to that location.</li>

  <li>The <code>sleep</code> function takes a time value in seconds as
  an argument and pauses execution of the program for that length of time.
  In general computers do things much to fast to allow you to interact with
  them.  We can slow things down by making the computer sleep a bit at the
  right place.</li>
</ul>


<h2>Looking at key strokes</h2>

<p>Inside your while loop place the following</p>

<pre class="shell">
   key = key_pressed()
   if key : print key
</pre>

<p>Run the program again pressing some keys. Look at the output in the Python
Shell window coming from the print statement. The keys pressed are nicely
returned as strings in a list.  We will used this feature to control our mitt.
</p>


<h2>Catching the ball</h2>

<p>Let's define a mitt as a larger circle at the lower right hand corner of the window. Put these 3 lines where you defined the ball</p>

<pre class="shell">
   mittX = 600
   mittY = 10
   mitt  = Circle((mittX,mittY),10)
</pre>

<p>Next replace the "if key : print key" with the following.</p>

<pre class="shell">
  if key :
     if key == 'down' : mittY -= 10
     if key == 'up'   : mittY += 10
     move_to(mitt, (mittX,mittY))
</pre>

<p>Now run the program and hit the up and down keys while the ball is moving across the screen. What happens to the mitt? Are you able to catch the ball? How could the program be modified to tell?</p>

<p>Well, if at any point ballX is equal to mittX and ballY is equal to mittY then the ball is exactly in the center of the mitt. But you might want to give yourself (the player) more slack than that. Discuss ways of doing that. Make your program print "Caught it!" or "Missed" after the ball has passed off the screen.</p>

<h2>Imperfect pitches</h2>

<p>We can add a bit of randomness to the game with the gasp function "random_between". Try the following in the Python Shell window.</p>

<pre class="shell">
   >>> from gasp import *
   >>> print random_between(-5, 5)
   >>> print random_between(-5, 5)
   >>> etc.
</pre>

<p>Each time the function is called a more or less random integer is chosen between -5 and 5. Let's use this to add some "spin" to the ball. Where ballX is being incremented, change the value of ballY too.</p>

<pre class="shell">
  ballX += 10
  ballY -= random_between(-5,5)
  move_to(ball, (ballX, ballY))
</pre>

<p>Another option might be to call random_between just once to establish a constant Y increment. This puts the ball on a slope. Try it.</p>


<h2>Creating a main loop</h2>

<p>Iteration is useful for enabling users to control how many times parts of a
program are executed.</p>

<pre class='python'>
def play_game():
    print "I'm playing... Oh what fun!"

choice = 'y' 

while choice == 'y':
    play_game()
    choice = raw_input("Would you like to play again? (y/n): ")
</pre>

<p>The variable <code>choice</code> is initialized to <code>'y'</code>.
This makes the condition of the while loop true the first time it is evaluated,
and assures that users get to play the game at least once.  After the game
finishes (and soon the call to <code>play_game()</code> will do something more
then print a message), users will be asked if they would like to play again. 
As long as they keep answering with 'y', they can continue playing.</p>

<pre class='shell'>
I'm playing... Oh what fun!
Would you like to play again? (y/n): y
I'm playing... Oh what fun!
Would you like to play again? (y/n): y
I'm playing... Oh what fun!
Would you like to play again? (y/n): n
</pre>


<h2>Glossary</h2>

<dl>
<dt>:</dt>
<dd>.</dd>
</dl>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
</div></li>

<li><div class="exercise">
</div></li>

<li><div class="exercise">
</div></li>

</ol>

</body>
</html>
