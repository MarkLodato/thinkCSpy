<html>
<head>
  <title>Dictionaries</title>
</head>
<body>

<h1>Dictionaries</h1>
<span class="index" value="index" />
<span class="index" value="dictionary" />
<span class="index" value="data type!dictionary" />
<span class="index" value="mapping type" />
<span class="index" value="type!mapping" />
<span class="index" value="key" />
<span class="index" value="key-value pair" />

<p>All of the compound data types we have studied in detail so far---strings,
lists, and tuples---are sequence types, which use integers as indices to
access the values they contain within them.</p>

<p><b>Dictionaries</b> are a different kind of compound type.  They are
Python's built-in <b>mapping type</b>.  They map <b>keys</b>, which can be any
immutable type, to values, which can be any type, just like the values of a
list or tuple.</p>

<p>As an example, we will create a dictionary to translate English words into
Spanish.  For this dictionary, the keys are strings.</p>

<p>One way to create a dictionary is to start with the empty dictionary and add 
<b>key-value pairs</b>.  The empty dictionary is denoted <code>{}</code>:</p>

<pre class="python-interpreter">
>>> eng2sp = {}
>>> eng2sp['one'] = 'uno'
>>> eng2sp['two'] = 'dos'
</pre>

<p>The first assignment creates a dictionary named <code>eng2sp</code>; the
other assignments add new key-value pairs to the dictionary.  We can print the
current value of the dictionary in the usual way:</p>

<pre class="python-interpreter">
>>> print eng2sp
{'two': 'dos', 'one': 'uno'}
</pre>

<p>The key-value pairs of the dictionary are seperated by commas.  Each pair
contains a key and a value separated by a colon.</p>

<p>The order of the pairs may not be what you expected.  Python uses complex
algorithms to determine where the key-value pairs are stored in a dictionary.
For our purposes we can think of this ordering as unpredicatable.</p> 

<p>Another way to create a dictionary is to provide a list of key-value pairs
using the same syntax as the previous output:</p>

<pre class="python-interpreter">
>>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}
</pre>

<p>It doesn't matter what order we write the pairs.  The values in a dictionary
are accessed with keys, not with indices, so there is no need to care about
ordering.</p> 

<p>Here is how we use a key to look up the corresponding value:</p>

<pre class="python-interpreter">
>>> print eng2sp['two']
'dos'
</pre>

<p>The key <code>'two'</code> yields the value <code>'dos'</code>.</p>


<h2>Dictionary operations</h2>
<span class="index" value="dictionary!operation" />
<span class="index" value="operation!dictionary" />

<p>The <code>del</code> statement removes a key-value pair from a dictionary.
For example, the following dictionary contains the names of various fruits and
the number of each fruit in stock:</p>

<pre class="python-interpreter">
>>> inventory = {'apples': 430, 'bananas': 312, 'oranges': 525, 'pears': 217}
>>> print inventory
{'oranges': 525, 'apples': 430, 'pears': 217, 'bananas': 312}
</pre>

<p>If someone buys all of the pears, we can remove the entry from the
dictionary:</p>

<pre class="python-interpreter">
>>> del inventory['pears']
>>> print inventory
{'oranges': 525, 'apples': 430, 'bananas': 312}
</pre>

<p>Or if we're expecting more pears soon, we might just change the value
associated with pears:</p>

<pre class="python-interpreter">
>>> inventory['pears'] = 0
>>> print inventory
{'oranges': 525, 'apples': 430, 'pears': 0, 'bananas': 312}
</pre>

<p>The <code>len</code> function also works on dictionaries; it returns the
number of key-value pairs:</p>

<pre class="python-interpreter">
>>> len(inventory)
4
</pre>


<h2>Dictionary methods</h2>
<span class="index" value="dictionary!method" />
<span class="index" value="method!dictionary" />
<span class="index" value="method" />
<span class="index" value="method!invocation" />
<span class="index" value="invoking method" />

<p>Dictionaries have a number of useful built-in methods</p>

<p>The <code>keys</code> method takes a dictionary and returns a list of its
keys.</p>

<pre class="python-interpreter">
>>> eng2sp.keys()
['three', 'two', 'one']
</pre>

<p>As we saw earlier with strings and lists, dictionary methods use dot
notation, which specifies the name of the method to the right of the dot and
the name of the object on which to apply the method immediately to the left
of the dot.  The parentheses indicate that this method takes no parameters.</p>

<p>A method call is called an <b>invocation</b>; in this case, we would say
that we are invoking the <code>keys</code> method on the object
<code>eng2sp</code>. As we will see in a few chapters when we talk about object 
oriented programming, the object on which a method is invoked is actually the
first argument to the method.</p>

<p>The <code>values</code> method is similar; it returns a list of the values
in the dictionary:</p>

<pre class="python-interpreter">
>>> eng2sp.values()
['tres', 'dos', 'uno']
</pre>

<p>The <code>items</code> method returns both, in the form of a list of
tuples---one for each key-value pair:</p>

<pre class="python-interpreter">
>>> eng2sp.items()
[('three', 'tres'), ('two', 'dos'), ('one', 'uno')]
</pre>

<p>The <code>has_key</code> method takes a key as an argument and returns
<code>True</code> if the key appears in the dictionary and <code>False</code>
otherwise:</p>

<pre class="python-interpreter">
>>> eng2sp.has_key('one')
True
>>> eng2sp.has_key('deux')
False
</pre>

<p>This method can be very useful, since looking up a non-existant key in a
dictionary causes a runtime error:</p>

<pre class="python-interpreter">
>>> eng2esp['dog']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'dog'
>>> 
</pre>

<span class="index" value="runtime error" />


<h2>Aliasing and copying</h2>
<span class="index" value="aliasing" />
<span class="index" value="copying" />
<span class="index" value="cloning" />

<p>Because dictionaries are mutable, you need to be aware of aliasing.
Whenever two variables refer to the same object, changes to one affect the
other.</p>

<p>If you want to modify a dictionary and keep a copy of the original, use the
<code>copy</code> method.  For example, <code>opposites</code> is a dictionary
that contains pairs of opposites:</p>

<pre class="python-interpreter">
>>> opposites = {'up': 'down', 'right': 'wrong', 'true': 'false'}
>>> alias = opposites
>>> copy = opposites.copy()
</pre>

<p><code>alias</code> and <code>opposites</code> refer to the same object;
<code>copy</code> refers to a fresh copy of the same dictionary.  If we modify
<code>alias</code>, <code>opposites</code> is also changed:</p>

<pre class="python-interpreter">
>>> alias['right'] = 'left'
>>> opposites['right']
'left'
</pre>

<p>If we modify <code>copy</code>, <code>opposites</code> is unchanged:</p>

<pre class="python-interpreter">
>>> copy['right'] = 'privilege'
>>> opposites['right']
'left'
</pre>


<h2>Sparse matrices </h2>
<span class="index" value="matrix!sparse" />
<span class="index" value="nested list" />
<span class="index" value="list!nested" />

<p>We previously used a list of lists to represent a matrix.  That is a good
choice for a matrix with mostly nonzero values, but consider a
<a href="http://en.wikipedia.org/wiki/Sparse_matrix">sparse matrix</a>
like this one:</p>

<img src="illustrations/sparse.png" />

<p>The list representation contains a lot of zeroes:</p>

<pre class="python">
matrix = [[0, 0, 0, 1, 0],
          [0, 0, 0, 0, 0],
          [0, 2, 0, 0, 0],
          [0, 0, 0, 0, 0],
          [0, 0, 0, 3, 0]]
</pre>

<p>An alternative is to use a dictionary.  For the keys, we can use tuples
that contain the row and column numbers.  Here is the dictionary
representation of the same matrix:</p>

<pre class="python">
matrix = {(0, 3): 1, (2, 1): 2, (4, 3): 3}
</pre>

<p>We only need three key-value pairs, one for each nonzero element of the
matrix.  Each key is a tuple, and each value is an integer.</p>

<p>To access an element of the matrix, we could use the <code>[]</code>
operator:</p>

<pre class="python">
matrix[(0, 3)]
1
</pre>

<p>Notice that the syntax for the dictionary representation is not the
same as the syntax for the nested list representation.  Instead of
two integer indices, we use one index, which is a tuple of integers.</p>

<p>There is one problem.  If we specify an element that is zero, we get an
error, because there is no entry in the dictionary with that key:</p>

<span class="index" value="runtime error" />

<pre class="python-interpreter">
>>> matrix[(1, 3)]
KeyError: (1, 3)
</pre>

<p>The <code>get</code> method solves this problem:</p>

<pre class="python">
>>> matrix.get((0, 3), 0)
1
</pre>

<p>The first argument is the key; the second argument is the value
<code>get</code> should return if the key is not in the dictionary:</p>

<pre class="python">
>>> matrix.get((1, 3), 0)
0
</pre>

<p><code>get</code> definitely improves the semantics of accessing a sparse
matrix.  Shame about the syntax.</p>


<h2>Hints</h2>
<span class="index" value="hint" />
<span class="index" value="Fibonacci function" />

<p>If you played around with the <code>fibonacci</code> function from
the last chapter, you might have noticed that the bigger the argument you
provide, the longer the function takes to run.  Furthermore, the run time
increases very quickly.  On one of our machines, <code>fibonacci(20)</code>
finishes instantly, <code>fibonacci(30)</code> takes about a second, and
<code>fibonacci(40)</code> takes roughly forever.</p>

<p>To understand why, consider this <b>call graph</b> for <code>fibonacci</code>
with <code>n = 4</code>:</p>

<img src="illustrations/fibonacci.png" />

<p>A call graph shows a set function frames, with lines connecting each frame
to the frames of the functions it calls.  At the top of the graph,
<code>fibonacci</code> with <code>n = 4</code> calls <code>fibonacci</code>
with <code>n = 3</code> and <code>n = 2</code>.  In turn,
<code>fibonacci</code> with <code>n = 3</code> calls <code>fibonacci</code>
with <code>n = 2</code> and <code>n = 1</code>.  And so on.</p>

<span class="index" value="function frame" />
<span class="index" value="frame" />
<span class="index" value="call graph" />

<p>Count how many times <code>fibonacci(0)</code> and <code>fibonacci(1)</code> 
are called.  This is an inefficient solution to the problem, and it gets far
worse as the argument gets bigger.</p>

<p>A good solution is to keep track of values that have already been computed
by storing them in a dictionary.  A previously computed value that is stored
for later use is called a <b>hint</b>.  Here is an implementation of
<code>fibonacci</code> using hints:</p>

<pre class="python">
previous = {0: 0, 1: 1}
   
def fibonacci(n):
    if previous.has_key(n):
        return previous[n]
    else:
        new_value = fibonacci(n-1) + fibonacci(n-2)
        previous[n] = new_value
        return new_value
</pre>

<p>The dictionary named <code>previous</code> keeps track of the Fibonacci
numbers we already know.  We start with only two pairs: 0 maps to 1; and 1 maps 
to 1.</p>

<p>Whenever <code>fibonacci</code> is called, it checks the dictionary to
determine if it contains the result.  If it's there, the function can return
immediately without making any more recursive calls.  If not, it has to compute 
the new value.  The new value is added to the dictionary before the function
returns.</p>

<p>Using this version of <code>fibonacci</code>, our machines can compute
<code>fibonacci(100)</code> in an eyeblink.
</p>

<pre class="python-interpreter">
>>> fibonacci(100)
354224848179261915075L
</pre>

<p>The <code>L</code> at the end of the number indicates that it is a
<code>long</code> integer.
</p>


<h2>Long integers</h2>
<span class="index" value="long integer" />
<span class="index" value="data type!long integer" />
<span class="index" value="integer!long" />

<p>Python provides a type called <code>long</code> that can handle any size
integer (limited only by the amount of memory you have on your computer).
</p>

<p>There are three ways to create a <code>long</code> value.  The first one is
to compute an arithmetic expression too large to fit inside an <code>int</code>.
We already saw this in the <code>fibonacci(100)</code> example above.
Another way is to write an integer with a capital <code>L</code> at the
end of your number:</p>

<pre class="python-interpreter">
>>> type(1L)
&lt;type 'long'>
</pre>

<p>The third is to call <code>long</code> with the value to be converted as
an argument. <code>long</code>, just like <code>int</code> and
<code>float</code>, can convert <code>int</code>s, <code>floats</code>, and
even strings of digits to long integers:</p>

<pre class="python-interpreter">
>>> long(7)
7L
>>> long(3.9)
3L
>>> long('59')
59L
</pre>

<span class="index" value="type coercion" />
<span class="index" value="coercion!type" />


<h2>Counting letters</h2>
<span class="index" value="counting" />
<span class="index" value="histogram" />
<span class="index" value="compression" />

<p>In Chapter 7, we wrote a function that counted the number of occurrences of
a letter in a string.  A more general version of this problem is to form a
histogram of the letters in the string, that is, how many times each letter
appears.</p>

<p>Such a histogram might be useful for compressing a text file.  Because
different letters appear with different frequencies, we can compress a file by
using shorter codes for common letters and longer codes for letters that
appear less frequently.</p>

<p>Dictionaries provide an elegant way to generate a histogram:</p>

<pre class="python-interpreter">
>>> letter_counts = {}
>>> for letter in "Mississippi":
...   letter_counts[letter] = letter_counts.get (letter, 0) + 1
...
>>> letter_counts
{'M': 1, 's': 4, 'p': 2, 'i': 4}
</pre>

<p>We start with an empty dictionary.  For each letter in the string, we find
the current count (possibly zero) and increment it.  At the end, the dictionary 
contains pairs of letters and their frequencies.</p>

<p>It might be more appealing to display the histogram in alphabetical order.
We can do that with the <code>items</code> and <code>sort</code> methods:</p>

<pre class="python-interpreter">
>>> letter_items = letter_counts.items()
>>> letter_items.sort()
>>> print letter_items
[('M', 1), ('i', 4), ('p', 2), ('s', 4)]
</pre>

<span class="index" value="method!list" />
<span class="index" value="list method" />


<h2>Case Study: Robots</h2>

<h3>The game</h3>

<p>In this case study we will write a version of the classic console based
game, <a href="http://en.wikipedia.org/wiki/Robots_(computer_game)">robots</a>.
</p>
<p>
Robots is a turn-based game in which the protagonist, you, are trying to stay
alive while being chased by stupid, but relentless robots.  Each robot moves
one square toward you each time you move.  If they catch you, you are dead,
but if they collide they die, leaving a pile of dead robot junk in their wake.
If other robots collide with the piles of junk, they die.
</p>
<p>
The basic strategy is to position yourself so that the robots collide with each 
other and with piles of junk as they move toward you.  To make the game
playable, you also are given the ability to teleport to another location on the 
screen -- 3 times safely and randomly thereafter, so that you don't just get
forced into a corner and loose every time.
</p>


<h3>Setting up the world and the main loop</h3>

<p>
Let's start with a program that places the player on the screen and has a
function to move her around in response to keys pressed:
</p>

<pre class="python">
#
# robots.py
#
from gasp import *

SCREEN_WIDTH = 640
SCREEN_HEIGHT = 480
GRID_WIDTH = SCREEN_WIDTH/10 - 1
GRID_HEIGHT = SCREEN_HEIGHT/10 - 1


def place_player():
    x = random.randint(0, GRID_WIDTH)
    y = random.randint(0, GRID_HEIGHT)
    return {'shape': Circle((10*x+5, 10*y+5), 5, filled=True), 'x': x, 'y': y}


def move_player(player):
    update_when('key_pressed')
    if key_pressed('escape'):
        return True
    elif key_pressed('4'):
        if player['x'] &gt; 0: player['x'] -= 1
    elif key_pressed('7'):
        if player['x'] &gt; 0: player['x'] -= 1
        if player['y'] &lt; GRID_HEIGHT: player['y'] += 1
    elif key_pressed('8'):
        if player['y'] &lt; GRID_HEIGHT: player['y'] += 1
    elif key_pressed('9'):
        if player['x'] &lt; GRID_WIDTH: player['x'] += 1
        if player['y'] &lt; GRID_HEIGHT: player['y'] += 1
    elif key_pressed('6'):
        if player['x'] &lt; GRID_WIDTH: player['x'] += 1
    elif key_pressed('3'):
        if player['x'] &lt; GRID_WIDTH: player['x'] += 1
        if player['y'] &gt; 0: player['y'] -= 1
    elif key_pressed('2'):
        if player['y'] &gt; 0: player['y'] -= 1
    elif key_pressed('1'):
        if player['x'] &gt; 0: player['x'] -= 1
        if player['y'] &gt; 0: player['y'] -= 1
    else:
        return False

    move_to(player['shape'], (10*player['x']+5, 10*player['y']+5))

    return False


def play_game():
    begin_graphics(SCREEN_WIDTH, SCREEN_HEIGHT)
    player = place_player()
    finished = False
    while not finished:
        finished = move_player(player)
    end_graphics()


if __name__ == '__main__':
    play_game()
</pre>

<p>Programs like this one that involve interacting with the user through
<b>events</b> such as key presses and mouse clicks are called
<b><a href="http://en.wikipedia.org/wiki/Event_driven_programming">event-driven programs</a></b>.</p>

<p>The main <b>event loop</b> at this stage is simply:</p>

<pre class="python">
    while not finished:
        finished = move_player(player)
</pre>

<p>The event handling is done inside the <code>move_player</code> function.
<code>update_when('key_pressed')</code> waits until a key has been pressed
before moving to the next statement.  The multi-way branching statement then
handles the all keys relevent to game play.</p>

<p>Pressing the escape key causes <code>move_player</code> to return true,
making <code>not finished</code> false, thus exiting the main loop and ending
the game.  The 4, 7, 8, 9, 6, 3, 2, and 1 keys all cause the player to move
in the appropriate direction, if she isn't blocked by the edge of a window.
</p>  


<h2>Glossary</h2>
<span class="index" value="dictionary" />
<span class="index" value="mapping type" />
<span class="index" value="key" />
<span class="index" value="key-value pair" />
<span class="index" value="hint" />
<span class="index" value="event" />
<span class="index" value="event-driven program" />
<span class="index" value="event loop" />

<dl>
<dt>dictionary:</dt>
<dd>A collection of key-value pairs that maps from keys to values.  The keys
can be any immutable type, and the values can be any type.</dd>

<dt>mapping type:</dt>
<dd>
A mapping type is a data type comprised of a collection of keys and associated
values.   Python's only built-in mapping type is the dictionary.  Dictionaries
implement the 
<a href="http://en.wikipedia.org/wiki/Associative_array">associative array</a>
abstract data type.
</dd>

<dt>key:</dt>
<dd>A data item that is <em>mapped to</em> a value in a dictionary.  Keys
are used to look up values in a dictionary.</dd>

<dt>key-value pair:</dt>
<dd>One of the pairs of items in a dictionary.  Values are looked up in a
dictionary by key.</dd>

<dt>hint:</dt>
<dd>Temporary storage of a precomputed value to avoid redundant computation.

<dt>event:</dt>
<dd>A signal such as a keyboard press, mouse click, or message from another
program.</dd>

<dt>event-driven program:</dt>
<dd></dd>

<dt>event loop:</dt>
<dd>A programming construct that waits for events and processes them.</dd>
</dd>

<dt>overflow:</dt>
<dd>A numerical result that is too large to be represented in a numerical
format.</dd>
</dl>


<h2>Exercises</h2>
<ol>

<li><div class="exercise">
<p>Write a program that reads in a string on the command line and returns a
table of the letters of the alphabet in alphabetical order which occur in
the string together with the number of times each letter occurs.  Case
should be ignored.   A sample run of the program would look this this:</p>

<pre class="shell">
$ python letter_counts.py "ThiS is String with Upper and lower case Letters."
a  2
c  1
d  1
e  5
g  1
h  2
i  4
l  2
n  2
o  1
p  2
r  4
s  5
t  5
u  1
w  2
$
</pre>
</div></li>


<li><div class="exercise">
Give the Python interpreter's response to each of the following from a
continuous interpreter session:
<ol style="list-style-type: lower-alpha;">
  <li><pre class='python-interpreter'>
  >>> d = {'apples': 15, 'bananas': 35, 'grapes': 12} 
  >>> d['banana'] 
  </pre></li>

  <li><pre class='python-interpreter'>
  >>> d['oranges'] = 20
  >>> len(d) 
  </pre></li>

  <li><pre class='python-interpreter'>
  >>> d.has_key('grapes')
  </pre></li>

  <li><pre class='python-interpreter'>
  >>> d['pears']
  </pre></li>

  <li><pre class='python-interpreter'>
  >>> d.get('pears', 0)
  </pre></li>

  <li><pre class='python-interpreter'>
  >>> fruits = d.keys()
  >>> fruits.sort()
  >>> print fruits
  </pre></li>

  <li><pre class='python-interpreter'>
  >>> del d['apples']
  >>> d.has_key('apples') 
  </pre></li>
</ol>
Be sure you understand why you get each result.  Then apply what you have
learned to fill in the body of the function below:
<pre class='python'>
def add_fruit(inventory, fruit, quantity=0):
    """
    Adds quantity of fruit to inventory. 

      >>> new_inventory = {}
      >>> add_fruit(new_inventory, 'strawberries', 10)
      >>> new_inventory.has_key('strawberries')
      True
      >>> new_inventory['strawberries']
      10
      >>> add_fruit(new_inventory, 'strawberries', 25)
      >>> new_inventory['strawberries']       
    """
</pre>
Your solution should pass the doctests.
</div></li>

<li><div class="exercise">
Write a program called <code>alice_words.py</code> that creates a text
file named <code>alice_words.txt</code> containing an alphabetical listing
of all the words found in
<a href="resources/ch10/alice_in_wonderland.txt">alice_in_wonderland.txt</a>
together with the number of times each word occurs.  The first 10 lines of your 
output file should look something like this:
<pre class='shell'>
Word              Count
=======================
a                 631
a-piece           1
abide             1
able              1
about             94
above             3
absence           1
absurd            2
</pre>
How many times does the word, <code>alice</code>, occur in the book?
</div></li>

<li><div class="exercise">
What is the longest word in <q>Alice in Wonderland</q>?  How many charactes
does it have?
</div></li>

<li><div class="exercise">
Laptops usually have smaller keyboards than desktop computers that do not
include a seperate numeric keypad.  Modify the robots program so that it uses
'a', 'q', 'w', 'e', 'd', 'c', 'x', and 'z' instead of '4', '7', '8', '9', '6',
'3', '2', and '1' so that it will work on a typical laptop keyboard.
</div></li>

</ol>

</body>
</html>
