<html>
<head>
  <title>Conditionals and recursion</title>
</head>

<body>
<h1>Conditionals and recursion</h1>

<h2>The modulus operator</h2>
<span class="index" value="modulus operator" />
<span class="index" value="operator!modulus" />

<p>The <b>modulus operator</b> works on integers (and integer
expressions) and yields the remainder when the first operand is divided by the
second.  In Python, the modulus operator is a percent sign (<code>%</code>).
The syntax is the same as for other operators:
</p>

<pre class="python-interpreter">
>>> quotient = 7 / 3
>>> print quotient
2
>>> remainder = 7 % 3
>>> print remainder
1
</pre>

<p>So 7 divided by 3 is 2 with 1 left over.</p>

<p>
The modulus operator turns out to be surprisingly useful.  For example, you
can check whether one number is divisible by another---if <code>x % y</code> is 
zero, then <code>x</code> is divisible by <code>y</code>.</p>

<p>Also, you can extract the right-most digit or digits from a number.  For
example, <code>x % 10</code> yields the right-most digit of <code>x</code> (in
base 10).  Similarly <code>x % 100</code> yields the last two digits.</p>


<h2>Boolean values and expressions</h2>
<span class="index" value="boolean value" />
<span class="index" value="boolean expression" />
<span class="index" value="value!boolean" />
<span class="index" value="expression!boolean" />
<span class="index" value="logical operator" />
<span class="index" value="operator!logical" />

<p>The Python type for storing true and false values is called
<code>bool</code>, named after the British mathematician, George Boole.
George Boole created <em>Boolean algebra</em>, which is the basis of all modern 
computer arithmetic.
</p>

<p>There are only two <b>boolean values</b>: <code>True</code> and
<code>False</code>.  Capitalization is important, since <code>true</code>
and <code>false</code> are not boolean values.
</p>

<pre class="python-interpreter">
>>> type(True)
&lt;type 'bool'>
>>> type(true)
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
NameError: name 'true' is not defined
</pre>

<p>
A <b>boolean expression</b> is an expression that evaluates to a
boolean value.  The operator <code>==</code> compares two values and produces
a boolean value:</p>

<pre class="python-interpreter">
>>> 5 == 5
True
>>> 5 == 6
False
</pre>

<p>In the first statement, the two operands are equal, so the expression
evaluates to <code>True</code>; in the second statement, 5 is not equal to 6,
so we get <code>False</code>.</p>

<p>The <code>==</code> operator is one of the
<b>comparison operators</b>; the others are:</p>

<pre class="python">
x != y               # x is not equal to y
x &gt; y                # x is greater than y
x &lt; y                # x is less than y
x &gt;= y               # x is greater than or equal to y
x &lt;= y               # x is less than or equal to y
</pre>

<p>Although these operations are probably familiar to you, the Python symbols
are different from the mathematical symbols.  A common error is to use a single 
equal sign (<code>=</code>) instead of a double equal sign (<code>==</code>).
Remember that <code>=</code> is an assignment operator and <code>==</code> is a 
comparison operator.   Also, there is no such thing as <code>=&lt;</code> or
<code>=&gt;</code>.</p>


<h2>Logical operators</h2>
<span class="index" value="logical operator" />
<span class="index" value="operator!logical" />

<p>There are three <b>logical operators</b>: <code>and</code>,
<code>or</code>, and <code>not</code>.  The semantics (meaning) of these
operators is similar to their meaning in English.  For example, <code>x &gt; 0
and x &lt; 10</code> is true only if <code>x</code> is greater than 0
<em>and</em> less than 10.</p>

<p><code>n % 2 == 0 or n % 3 == 0</code> is true if <em>either</em> of the
conditions is true, that is, if the number is divisible by 2 <em>or</em> 3.</p>

<p>Finally, the <code>not</code> operator negates a boolean expression, so
<code>not(x &gt; y)</code> is true if <code>(x &gt; y)</code> is false,
that is, if <code>x</code> is less than or equal to <code>y</code>.</p>


<h2>Conditional execution</h2>
<a name="conditional execution" />
<span class="index" value="conditional branching" />
<span class="index" value="conditional execution" />

<p>In order to write useful programs, we almost always need the ability to
check conditions and change the behavior of the program accordingly.
<b>Conditional statements</b> give us this ability.  The simplest
form is the <code>if</code> statement:</p>

<pre class="python">
if x &gt; 0:
    print "x is positive"
</pre>

<p>The boolean expression after the <code>if</code> statement is
called the <b>condition</b>.  If it is true, then the indented
statement gets executed.  If not, nothing happens.</p>

<span class="index" value="compound statement" />
<span class="index" value="compound statement!header" />
<span class="index" value="compound statement!body" />
<span class="index" value="compound statement!statement block" />
<span class="index" value="statement!compound" />

<p>Like other compound statements, the <code>if</code> statement is made up of
a header and a block of statements:</p>

<pre class="python">
if BOOLEAN EXPRESSION:
    STATEMENTS
</pre>

<p>The header begins with the keyword <code>if</code> and ends with a colon (:).
The indented statements that follow are called a <b>block</b>.  The first
unindented statement marks the end of the block.  A statement block inside a
compound statement is called the <b>body</b> of the statement.</p>

<span class="index" value="block" />
<span class="index" value="statement!block" />
<span class="index" value="body" />

<p>There is no limit on the number of statements that can appear in the body of 
an <code>if</code> statement, but there has to be at least one.  Occasionally,
it is useful to have a body with no statements (usually as a place keeper for
code you haven't written yet).  In that case, you can use the <code>pass</code>
statement, which does nothing.</p>

<span class="index" value="pass statement" />
<span class="index" value="statement!pass" />


<h2>Alternative execution</h2>
<a name="alternative execution" />

<p>A second form of the <code>if</code> statement is alternative execution,
in which there are two possibilities and the condition determines which one
gets executed.  The syntax looks like this:</p>

<pre class="python">
if x % 2 == 0:
    print x, "is even"
else:
    print x, "is odd"
</pre>

<p>If the remainder when <code>x</code> is divided by 2 is 0, then we know that 
<code>x</code> is even, and the program displays a message to that effect.  If
the condition is false, the second set of statements is executed.  Since the
condition must be true or false, exactly one of the alternatives will be
executed.  The alternatives are called <b>branches</b>, because they
are branches in the flow of execution.</p>

<span class="index" value="branch" />

<p>As an aside, if you need to check the parity (evenness or oddness) of
numbers often, you might <q>wrap</q> this code in a function:</p>

<pre class="python">
def print_parity(x):
    if x % 2 == 0:
        print x, "is even"
    else:
        print x, "is odd"
</pre>

<p>For any value of <code>x</code>, <code>print_parity</code> displays an
appropriate message.  When you call it, you can provide any integer expression
as an argument.</p>

<pre class="python-interpreter">
>>> print_parity(17)
17 is odd.
>>> y = 41
>>> print_parity(y+1)
42 is even.
</pre>


<h2>Chained conditionals</h2>
<span class="index" value="chained conditional" />
<span class="index" value="conditional!chained" />

<p>Sometimes there are more than two possibilities and we need more than two
branches.  One way to express a computation like that is a
<b>chained conditional</b>:</p>

<pre class="python">
if x &lt; y:
    print x, "is less than", y
elif x &gt; y:
    print x, "is greater than", y
else:
    print x, "and", y, "are equal"
</pre>

<p><code>elif</code> is an abbreviation of <q>else if.</q>  Again, exactly one
branch will be executed.  There is no limit of the number of <code>elif</code>
statements but only a single (and optional) <code>else</code> statement is
allowed and it must be the last branch in the statement:</p>

<pre class="python">
if choice == 'A':
    functionA()
elif choice == 'B':
    functionB()
elif choice == 'C':
    functionC()
else:
    print "Invalid choice."
</pre>

<p>Each condition is checked in order.  If the first is false, the next is
checked, and so on.  If one of them is true, the corresponding branch executes, 
and the statement ends.  Even if more than one condition is true, only the
first true branch executes.</p>


<h2>Nested conditionals</h2>

<p>One conditional can also be nested within another.  We could have written
the trichotomy example as follows:</p>

<pre class="python">
if x == y:
    print x, "and", y, "are equal"
else:
    if x &lt; y:
        print x, "is less than", y
    else:
        print x, "is greater than", y
</pre>

<p>The outer conditional contains two branches.  The first branch contains a
simple output statement.  The second branch contains another <code>if</code>
statement, which has two branches of its own.  Those two branches are both
output statements, although they could have been conditional statements as
well.</p>

<p>Although the indentation of the statements makes the structure apparent,
nested conditionals become difficult to read very quickly. In general, it is a
good idea to avoid them when you can.</p>

<p>Logical operators often provide a way to simplify nested conditional
statements.  For example, we can rewrite the following code using a
single conditional:</p>

<pre class="python">
if 0 &lt; x:
    if x &lt; 10:
        print "x is a positive single digit."
</pre>

<p>The <code>print</code> statement is executed only if we make it past both
the conditionals, so we can use the <code>and</code> operator:</p>

<pre class="python-interpreter">
if 0 &lt; x and x &lt; 10:
    print "x is a positive single digit."
</pre>

<p>These kinds of conditions are common, so Python provides an alternative
syntax that is similar to mathematical notation:</p>

<pre class="python-interpreter">
if 0 &lt; x &lt; 10:
    print "x is a positive single digit."
</pre>

<p>This condition is semantically the same as the compound boolean expression
and the nested conditional.</p>


<h2>The <code>return</code> statement</h2>
<span class="index" value="return statement" />
<span class="index" value="statement!return" />

<p>The <code>return</code> statement allows you to terminate the execution of a
function before you reach the end.  One reason to use it is if you detect an
error condition:</p>

<pre class="python">
def print_square_root(x):
    if x &lt;= 0:
        print "Positive numbers only, please."
        return

    result = x**0.5
    print "The square root of x is", result
</pre>

<p>The function <code>print_square_root</code> has a parameter named
<code>x</code>.  The first thing it does is check whether <code>x</code> is
less than or equal to 0, in which case it displays an error message and then
uses <code>return</code> to exit the function. The flow of execution
immediately returns to the caller, and the remaining lines of the function are
not executed.</p>


<h2>Recursion</h2>
<a name="recursion" />
<span class="index" value="recursion" />

<p>We mentioned that it is legal for one function to call another, and you have 
seen several examples of that.  We neglected to mention that it is also legal
for a function to call itself.  It may not be obvious why that is a good thing, 
but it turns out to be one of the most magical and interesting things a
program can do.  For example, look at the following function:</p>

<pre class="python">
def countdown(n):
    if n == 0:
        print "Blastoff!"
    else:
        print n
        countdown(n-1)
</pre>

<p><code>countdown</code> expects the parameter, <code>n</code>, to be a
positive integer.  If <code>n</code> is 0, it outputs the word,
<q>Blastoff!</q> Otherwise, it outputs <code>n</code> and then calls a function 
named <code>countdown</code>---itself---passing <code>n-1</code> as an
argument.</p>

<p>What happens if we call this function like this:</p>

<pre class="python-interpreter">
>>> countdown(3)
</pre>

<blockquote>
The execution of <code>countdown</code> begins with <code>n</code> set to 3, 
and since <code>n</code> is not 0, it outputs the value 3, and then calls
itself...

<blockquote>
The execution of <code>countdown</code> begins with <code>n</code> set to 2,
and since <code>n</code> is not 0, it outputs the value 2, and then calls
itself...

<blockquote>
The execution of <code>countdown</code> begins with <code>n</code> set to 1,
and since <code>n</code> is not 0, it outputs the value 1, and then calls
itself...

<blockquote>
The execution of <code>countdown</code> begins with <code>n</code> set to 0,
and since <code>n</code> is 0, it outputs the word, <q>Blastoff!</q> and then
returns.
</blockquote>

The <code>countdown</code> that got <code>n</code> set to 1 returns.
</blockquote>

The <code>countdown</code> that got <code>n</code> set to 2 returns.
</blockquote>

The <code>countdown</code> that got <code>n</code> set to 3 returns.
</blockquote>

<p>And then you're back in <code>__main__</code> (what a trip).  So, the
total output looks like this:</p>

<pre class="shell">
3
2
1
Blastoff!
</pre>

<p>As a second example, look again at the functions <code>new_line</code> and
<code>three_lines</code>:</p>

<pre class="python">
def new_line():
    print

def three_lines():
    new_line()
    new_line()
    new_line()
</pre>

<p>Although these work, they would not be much help if we wanted to output 2
newlines, or 106.  A better alternative would be this:</p>

<pre class="python">
def n_lines(n):
    if n &gt; 0:
        print
        n_lines(n-1)
</pre>

<p>This program is similar to <code>countdown</code>; as long as <code>n</code> 
is greater than 0, it outputs one newline and then calls itself to output
<code>n-1</code> additional newlines.  Thus, the total number of newlines is
<code>1 + (n - 1)</code> which, if you do your algebra right, comes out to
<code>n</code>.</p>

<p>The process of a function calling itself is <b>recursion</b>, and
such functions are said to be recursive.  The statement in which the function
calls itself is the <b>recursive call</b>.</p>

<span class="index" value="recursion" />
<span class="index" value="recursive call" />
<span class="index" value="function!recursive" />
<span class="index" value="call!recursive" />


<h2>Stack diagrams for recursive functions</h2>
<span class="index" value="stack diagram" />
<span class="index" value="function frame" />
<span class="index" value="frame" />

<p>In the last chapter, we used a stack diagram to represent the state of a
program during a function call.  The same kind of diagram can help interpret a
recursive function.</p>

<p>Every time a function gets called, Python creates a new function frame,
which contains the function's local variables and parameters.  For a recursive
function, there might be more than one frame on the stack at the same time.</p>

<p>This figure shows a stack diagram for <code>countdown</code> called with
<code>n = 3</code>:</p>

<img src="illustrations/stack2.png" />

<p>As usual, the top of the stack is the frame for <code>__main__</code>.
It is empty because we did not create any variables in <code>__main__</code> 
or pass any parameters to it.</p>

<p>The four <code>countdown</code> frames have different values for the
parameter <code>n</code>.  The bottom of the stack, where <code>n</code> equals
0, is called the <b>base case</b>.  It does not make a recursive
call, so there are no more frames.</p>

<span class="index" value="base case" />
<span class="index" value="recursion!base case" />


<h2>Infinite recursion</h2>
<span class="index" value="infinite recursion" />
<span class="index" value="recursion!infinite" />
<span class="index" value="runtime error" />
<span class="index" value="error!runtime" />
<span class="index" value="traceback" />

<p>If a recursion never reaches a base case, it goes on making recursive calls
forever, and the program never terminates.  This is known as
<b>infinite recursion</b>, and it is generally not considered
a good idea.  Here is a minimal program with an infinite recursion:</p>

<pre class="python">
def recurse():
    recurse()
</pre>

<p>In most programming environments, a program with infinite recursion does not 
really run forever.  Python reports an error message when the maximum recursion 
depth is reached:</p>

<pre class="shell">
File "&lt;stdin&gt;", line 2, in recurse
(98 repetitions omitted)
File "&lt;stdin&gt;", line 2, in recurse
RuntimeError: maximum recursion depth exceeded
</pre>

<p>This traceback is a little bigger than the one we saw in the previous
chapter.  When the error occurs, there are 100 <code>recurse</code> frames on
the stack!</p>


<h2>Tail recursion</h2>
<span class="index" value="tail recursion" />
<p>
In each of the examples of recursive functions above, the recursive
call is the last statement in the function.  This is called
<b>tail recursion</b>, and from a software engineering point of
view it is a bad thing to do.  Later we will see a better way to write
the functions above using <em>iteration</em>.  Iteration is more efficient
both in terms of speed and memory usage than tail recursion.
</p>

<p>
There are plenty of cases, however, where using recursion is the best way
to go, both in terms of computational elegance and efficiency.  We will
learn more about such cases when we talk about nested lists and trees. 
</p>


<h2>Keyboard input</h2>

<p>In chapter 2 we were introduced to Python's built-in functions that get
input from the keyboard: <code>raw_input</code> and <code>input</code>.
Now let's look at these again in greater depth.</p>

<p>When either of these functions are called, the program stops and waits for
the user to type something.  When the user presses Return or the Enter key, the 
program resumes and <code>raw_input</code>
returns what the user typed as a <code>string</code>:</p>

<pre class="python-interpreter">
>>> my_input = raw_input()
What are you waiting for?
>>> print my_input
What are you waiting for?
</pre>

<p>Before calling <code>raw_input</code>, it is a good idea to print a message
telling the user what to input.  This message is called a <code>prompt</code>.
We can supply a prompt as an argument to <code>raw_input</code>:</p>

<span class="index" value="prompt" />

<pre class="python-interpreter">
>>> name = raw_input("What...is your name? ")
What...is your name? Arthur, King of the Britons!
>>> print name
Arthur, King of the Britons!
</pre>

<p>If we expect the response to be an integer, we can use the
<code>input</code> function which interprets the response as a Python value:
</p>

<pre class="python">
prompt = "What...is the airspeed velocity of an unladen swallow?\n"
speed = input(prompt)
</pre>

<p>If the user types a string of digits, it is converted to an integer and
assigned to <code>speed</code>.  Unfortunately, if the user types characters
that do not make up a valid Python expression, the program crashes:</p>

<pre class="python-interpreter">
>>> speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
...
SyntaxError: invalid syntax
</pre>

<p>To avoid this kind of error, it is generally a good idea to use
<code>raw_input</code> to get a string and then use conversion functions to
convert to other types.</p>


<h2>Glossary</h2>
<span class="index" value="modulus operator" />
<span class="index" value="boolean expression" />
<span class="index" value="expression!boolean" />
<span class="index" value="conditional statement" />
<span class="index" value="statement!conditional" />
<span class="index" value="condition" />
<span class="index" value="compound statement" />
<span class="index" value="branch" />
<span class="index" value="body" />
<span class="index" value="block" />
<span class="index" value="nesting" />
<span class="index" value="recursion" />
<span class="index" value="base case" />
<span class="index" value="infinite recursion" />
<span class="index" value="prompt" />

<dl>
<dt>modulus operator:</dt>
<dd>An operator, denoted with a percent sign (<code>%</code>), that works on
integers and yields the remainder when one number is divided by another.</dd>

<dt>boolean value:</dt>
<dd>There are exactly two boolean values: <code>True</code> and
<code>False</code>.  Boolean values result when a boolean expression is
evaluated by the Python interepreter.  They have type <code>bool</code>.
</dd>

<dt>boolean expression:</dt>
<dd>An expression that is either true or false.</dd>

<dt>comparison operator:</dt>
<dd> One of the operators that compares two
values: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, 
<code>&gt;=</code>, and <code>&lt;=</code>.</dd>

<dt>logical operator:</dt>
<dd>One of the operators that combines boolean expressions: <code>and</code>,
<code>or</code>, and <code>not</code>.</dd>

<dt>conditional statement:</dt>
<dd>A statement that controls the flow of execution depending on some
condition.</dd>

<dt>condition:</dt>
<dd>The boolean expression in a conditional statement that determines which
branch is executed.</dd>

<dt>compound statement:</dt>
<dd>A statement that consists of a header and a body.  The header ends with a
colon (:).  The body is indented relative to the header.</dd>

<dt>block:</dt>
<dd>A group of consecutive statements with the same indentation.</dd>

<dt>body:</dt>
<dd>The block in a compound statement that follows the header.</dd>

<dt>nesting:</dt>
<dd>One program structure within another, such as a conditional statement
inside a branch of another conditional statement.</dd>

<dt>recursion:</dt>
<dd>The process of calling the function that is currently executing.</dd>

<dt>recursive call:</dt>
<dd>The statement in a recursive function with is a call to itself.</dd>

<dt>base case:</dt>
<dd>A branch of the conditional statement in a recursive function that does not 
result in a recursive call.</dd>

<dt>infinite recursion:</dt>
<dd>A function that calls itself recursively without ever reaching the base
case.  Eventually, an infinite recursion causes a runtime error.</dd>

<dt>prompt:</dt>
<dd>A visual cue that tells the user to input data.</dd>
</dl>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
<pre class="python">
if x &lt; y:
    print x, "is less than", y
elif x &gt; y:
    print x, "is greater than", y
else:
    print x, "and", y, "are equal"
</pre>
<em>Wrap</em> this code in a function called <code>compare(x, y)</code>.
<em>Call</em> <code>compare</code> three times: one each where the first
<em>argument</em> is less than, greater than, and equal to the second
argument.
</div></li>

<li><div class="exercise">
<pre class="python">
if choice == 'A':
    functionA()
elif choice == 'B':
    functionB()
elif choice == 'C':
    functionC()
else:
    print "Invalid choice."
</pre>
Wrap this code in a function called <code>dispatch(choice)</code>.
</div></li>

<li><div class="exercise">
Write a function with infinite recursion and run it in the Python interpreter.
</div></li>

<li><div class="exercise">
Draw a stack diagram for <code>n_lines</code> called with <code>n</code> set to
4.
</div></li>
</ol>

</body>
</html>
