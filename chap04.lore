<html>
<head>
  <title>Conditionals and recursion</title>
</head>

<body>
<h1>Conditionals and recursion</h1>

<h2>The modulus operator</h2>
<span class="index" value="modulus operator" />
<span class="index" value="operator!modulus" />

<p>The <b>modulus operator</b> works on integers (and integer
expressions) and yields the remainder when the first operand is divided by the
second.  In Python, the modulus operator is a percent sign (<code>%</code>).
The syntax is the same as for other operators:
</p>

<pre class="python-interpreter">
>>> quotient = 7 / 3
>>> print quotient
2
>>> remainder = 7 % 3
>>> print remainder
1
</pre>

<p>So 7 divided by 3 is 2 with 1 left over.</p>

<p>
The modulus operator turns out to be surprisingly useful.  For example, you
can check whether one number is divisible by another---if <code>x % y</code> is 
zero, then <code>x</code> is divisible by <code>y</code>.</p>

<p>Also, you can extract the right-most digit or digits from a number.  For
example, <code>x % 10</code> yields the right-most digit of <code>x</code> (in
base 10).  Similarly <code>x % 100</code> yields the last two digits.</p>


<h2>Boolean values and expressions</h2>
<span class="index" value="boolean value" />
<span class="index" value="boolean expression" />
<span class="index" value="value!boolean" />
<span class="index" value="expression!boolean" />
<span class="index" value="logical operator" />
<span class="index" value="operator!logical" />

<p>The Python type for storing true and false values is called
<code>bool</code>, named after the British mathematician, George Boole.
George Boole created <em>Boolean algebra</em>, which is the basis of all modern 
computer arithmetic.
</p>

<p>There are only two <b>boolean values</b>: <code>True</code> and
<code>False</code>.  Capitalization is important, since <code>true</code>
and <code>false</code> are not boolean values.
</p>

<pre class="python-interpreter">
>>> type(True)
&lt;type 'bool'>
>>> type(true)
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
NameError: name 'true' is not defined
</pre>

<p>
A <b>boolean expression</b> is an expression that evaluates to a
boolean value.  The operator <code>==</code> compares two values and produces
a boolean value:</p>

<pre class="python-interpreter">
>>> 5 == 5
True
>>> 5 == 6
False
</pre>

<p>In the first statement, the two operands are equal, so the expression
evaluates to <code>True</code>; in the second statement, 5 is not equal to 6,
so we get <code>False</code>.</p>

<p>The <code>==</code> operator is one of the
<b>comparison operators</b>; the others are:</p>

<pre class="python">
x != y               # x is not equal to y
x &gt; y                # x is greater than y
x &lt; y                # x is less than y
x &gt;= y               # x is greater than or equal to y
x &lt;= y               # x is less than or equal to y
</pre>

<p>Although these operations are probably familiar to you, the Python symbols
are different from the mathematical symbols.  A common error is to use a single 
equal sign (<code>=</code>) instead of a double equal sign (<code>==</code>).
Remember that <code>=</code> is an assignment operator and <code>==</code> is a 
comparison operator.   Also, there is no such thing as <code>=&lt;</code> or
<code>=&gt;</code>.</p>


<h2>Logical operators</h2>
<span class="index" value="logical operator" />
<span class="index" value="operator!logical" />

<p>There are three <b>logical operators</b>: <code>and</code>,
<code>or</code>, and <code>not</code>.  The semantics (meaning) of these
operators is similar to their meaning in English.  For example, <code>x &gt; 0
and x &lt; 10</code> is true only if <code>x</code> is greater than 0
<em>and</em> less than 10.</p>

<p><code>n % 2 == 0 or n % 3 == 0</code> is true if <em>either</em> of the
conditions is true, that is, if the number is divisible by 2 <em>or</em> 3.</p>

<p>Finally, the <code>not</code> operator negates a boolean expression, so
<code>not(x &gt; y)</code> is true if <code>(x &gt; y)</code> is false,
that is, if <code>x</code> is less than or equal to <code>y</code>.</p>


<h2>Conditional execution</h2>
<a name="conditional execution" />
<span class="index" value="conditional branching" />
<span class="index" value="conditional execution" />

<p>In order to write useful programs, we almost always need the ability to
check conditions and change the behavior of the program accordingly.
<b>Conditional statements</b> give us this ability.  The simplest
form is the <code>if</code> statement:</p>

<pre class="python">
if x &gt; 0:
    print "x is positive"
</pre>

<p>The boolean expression after the <code>if</code> statement is
called the <b>condition</b>.  If it is true, then the indented
statement gets executed.  If not, nothing happens.</p>

<span class="index" value="compound statement" />
<span class="index" value="compound statement!header" />
<span class="index" value="compound statement!body" />
<span class="index" value="compound statement!statement block" />
<span class="index" value="statement!compound" />

<p>The syntax for an <code>if</code> statement looks like this:</p>

<pre class="python">
if BOOLEAN EXPRESSION:
    STATEMENTS
</pre>

<p>As with the function definition from last chapter and other compound
statements, the <code>if</code> statement consistes of a header and a
body.  The header begins with the keyword <code>if</code> followed by
a <em>boolean expression</em> and ends with a colon (:).</p>

<p>The indented statements that follow are called a <b>block</b>.  The first
unindented statement marks the end of the block.  A statement block inside a
compound statement is called the <b>body</b> of the statement.</p>

<p>Each of the statements inside the body are executed in order if the boolean
expression evaluates to <code>True</code>.   The entire block is skipped if the 
boolean expression evaluates to <code>False</code>.</p>

<span class="index" value="block" />
<span class="index" value="statement!block" />
<span class="index" value="body" />

<p>There is no limit on the number of statements that can appear in the body of 
an <code>if</code> statement, but there has to be at least one.  Occasionally,
it is useful to have a body with no statements (usually as a place keeper for
code you haven't written yet).  In that case, you can use the <code>pass</code>
statement, which does nothing.</p>

<pre class="python">
if True:          # This is always true
    pass          # so this is always executed, but it does nothing
</pre>

<span class="index" value="pass statement" />
<span class="index" value="statement!pass" />


<h2>Alternative execution</h2>
<a name="alternative execution" />

<p>A second form of the <code>if</code> statement is alternative execution,
in which there are two possibilities and the condition determines which one
gets executed.  The syntax looks like this:</p>

<pre class="python">
if x % 2 == 0:
    print x, "is even"
else:
    print x, "is odd"
</pre>

<p>If the remainder when <code>x</code> is divided by 2 is 0, then we know that 
<code>x</code> is even, and the program displays a message to that effect.  If
the condition is false, the second set of statements is executed.  Since the
condition must be true or false, exactly one of the alternatives will be
executed.  The alternatives are called <b>branches</b>, because they
are branches in the flow of execution.</p>

<span class="index" value="branch" />

<p>As an aside, if you need to check the parity (evenness or oddness) of
numbers often, you might <q>wrap</q> this code in a function:</p>

<pre class="python">
def print_parity(x):
    if x % 2 == 0:
        print x, "is even"
    else:
        print x, "is odd"
</pre>

<p>For any value of <code>x</code>, <code>print_parity</code> displays an
appropriate message.  When you call it, you can provide any integer expression
as an argument.</p>

<pre class="python-interpreter">
>>> print_parity(17)
17 is odd.
>>> y = 41
>>> print_parity(y+1)
42 is even.
</pre>


<h2>Chained conditionals</h2>
<span class="index" value="chained conditional" />
<span class="index" value="conditional!chained" />

<p>Sometimes there are more than two possibilities and we need more than two
branches.  One way to express a computation like that is a
<b>chained conditional</b>:</p>

<pre class="python">
if x &lt; y:
    print x, "is less than", y
elif x &gt; y:
    print x, "is greater than", y
else:
    print x, "and", y, "are equal"
</pre>

<p><code>elif</code> is an abbreviation of <q>else if</q>.  Again, exactly one
branch will be executed.  There is no limit of the number of <code>elif</code>
statements but only a single (and optional) <code>else</code> statement is
allowed and it must be the last branch in the statement:</p>

<pre class="python">
if choice == 'A':
    functionA()
elif choice == 'B':
    functionB()
elif choice == 'C':
    functionC()
else:
    print "Invalid choice."
</pre>

<p>Each condition is checked in order.  If the first is false, the next is
checked, and so on.  If one of them is true, the corresponding branch executes, 
and the statement ends.  Even if more than one condition is true, only the
first true branch executes.</p>


<h2>Nested conditionals</h2>

<p>One conditional can also be <b>nested</b> within another.  We could have
written the trichotomy example as follows:</p>

<pre class="python">
if x == y:
    print x, "and", y, "are equal"
else:
    if x &lt; y:
        print x, "is less than", y
    else:
        print x, "is greater than", y
</pre>

<p>The outer conditional contains two branches.  The first branch contains a
simple output statement.  The second branch contains another <code>if</code>
statement, which has two branches of its own.  Those two branches are both
output statements, although they could have been conditional statements as
well.</p>

<p>Although the indentation of the statements makes the structure apparent,
nested conditionals become difficult to read very quickly. In general, it is a
good idea to avoid them when you can.</p>

<p>Logical operators often provide a way to simplify nested conditional
statements.  For example, we can rewrite the following code using a
single conditional:</p>

<pre class="python">
if 0 &lt; x:
    if x &lt; 10:
        print "x is a positive single digit."
</pre>

<p>The <code>print</code> statement is executed only if we make it past both
the conditionals, so we can use the <code>and</code> operator:</p>

<pre class="python-interpreter">
if 0 &lt; x and x &lt; 10:
    print "x is a positive single digit."
</pre>

<p>These kinds of conditions are common, so Python provides an alternative
syntax that is similar to mathematical notation:</p>

<pre class="python-interpreter">
if 0 &lt; x &lt; 10:
    print "x is a positive single digit."
</pre>

<p>This condition is semantically the same as the compound boolean expression
and the nested conditional.</p>


<h2>The <code>return</code> statement</h2>
<span class="index" value="return statement" />
<span class="index" value="statement!return" />

<p>The <code>return</code> statement allows you to terminate the execution of a
function before you reach the end.  One reason to use it is if you detect an
error condition:</p>

<pre class="python">
def print_square_root(x):
    if x &lt;= 0:
        print "Positive numbers only, please."
        return

    result = x**0.5
    print "The square root of x is", result
</pre>

<p>The function <code>print_square_root</code> has a parameter named
<code>x</code>.  The first thing it does is check whether <code>x</code> is
less than or equal to 0, in which case it displays an error message and then
uses <code>return</code> to exit the function. The flow of execution
immediately returns to the caller, and the remaining lines of the function are
not executed.</p>


<h2>Recursion</h2>
<a name="recursion" />
<span class="index" value="recursion" />

<p>We mentioned that it is legal for one function to call another, and you have 
seen several examples of that.  We neglected to mention that it is also legal
for a function to call itself.  It may not be obvious why that is a good thing, 
but it turns out to be one of the most magical and interesting things a
program can do.  For example, look at the following function:</p>

<pre class="python">
def countdown(n):
    if n == 0:
        print "Blastoff!"
    else:
        print n
        countdown(n-1)
</pre>

<p><code>countdown</code> expects the parameter, <code>n</code>, to be a
positive integer.  If <code>n</code> is 0, it outputs the word,
<q>Blastoff!</q> Otherwise, it outputs <code>n</code> and then calls a function 
named <code>countdown</code>---itself---passing <code>n-1</code> as an
argument.</p>

<p>What happens if we call this function like this:</p>

<pre class="python-interpreter">
>>> countdown(3)
</pre>

<blockquote>
The execution of <code>countdown</code> begins with <code>n</code> set to 3, 
and since <code>n</code> is not 0, it outputs the value 3, and then calls
itself...

<blockquote>
The execution of <code>countdown</code> begins with <code>n</code> set to 2,
and since <code>n</code> is not 0, it outputs the value 2, and then calls
itself...

<blockquote>
The execution of <code>countdown</code> begins with <code>n</code> set to 1,
and since <code>n</code> is not 0, it outputs the value 1, and then calls
itself...

<blockquote>
The execution of <code>countdown</code> begins with <code>n</code> set to 0,
and since <code>n</code> is 0, it outputs the word, <q>Blastoff!</q> and then
returns.
</blockquote>

The <code>countdown</code> that got <code>n</code> set to 1 returns.
</blockquote>

The <code>countdown</code> that got <code>n</code> set to 2 returns.
</blockquote>

The <code>countdown</code> that got <code>n</code> set to 3 returns.
</blockquote>

<p>And then you're back in <code>__main__</code> (what a trip).  So, the
total output looks like this:</p>

<pre class="shell">
3
2
1
Blastoff!
</pre>

<p>As a second example, look again at the functions <code>new_line</code> and
<code>three_lines</code>:</p>

<pre class="python">
def new_line():
    print

def three_lines():
    new_line()
    new_line()
    new_line()
</pre>

<p>Although these work, they would not be much help if we wanted to output 2
newlines, or 106.  A better alternative would be this:</p>

<pre class="python">
def n_lines(n):
    if n &gt; 0:
        print
        n_lines(n-1)
</pre>

<p>This program is similar to <code>countdown</code>; as long as <code>n</code> 
is greater than 0, it outputs one newline and then calls itself to output
<code>n-1</code> additional newlines.  Thus, the total number of newlines is
<code>1 + (n - 1)</code> which, if you do your algebra right, comes out to
<code>n</code>.</p>

<p>The process of a function calling itself is <b>recursion</b>, and
such functions are said to be recursive.  The statement in which the function
calls itself is the <b>recursive call</b>.</p>

<span class="index" value="recursion" />
<span class="index" value="recursive call" />
<span class="index" value="function!recursive" />
<span class="index" value="call!recursive" />


<h2>Stack diagrams for recursive functions</h2>
<span class="index" value="stack diagram" />
<span class="index" value="function frame" />
<span class="index" value="frame" />

<p>In the last chapter, we used a stack diagram to represent the state of a
program during a function call.  The same kind of diagram can help interpret a
recursive function.</p>

<p>Every time a function gets called, Python creates a new function frame,
which contains the function's local variables and parameters.  For a recursive
function, there might be more than one frame on the stack at the same time.</p>

<p>This figure shows a stack diagram for <code>countdown</code> called with
<code>n = 3</code>:</p>

<img src="illustrations/stack2.png" />

<p>As usual, the top of the stack is the frame for <code>__main__</code>.
It is empty because we did not create any variables in <code>__main__</code> 
or pass any parameters to it.</p>

<p>The four <code>countdown</code> frames have different values for the
parameter <code>n</code>.  The bottom of the stack, where <code>n</code> equals
0, is called the <b>base case</b>.  It does not make a recursive
call, so there are no more frames.</p>

<span class="index" value="base case" />
<span class="index" value="recursion!base case" />


<h2>Infinite recursion</h2>
<span class="index" value="infinite recursion" />
<span class="index" value="recursion!infinite" />
<span class="index" value="runtime error" />
<span class="index" value="error!runtime" />
<span class="index" value="traceback" />

<p>If a recursion never reaches a base case, it goes on making recursive calls
forever, and the program never terminates.  This is known as
<b>infinite recursion</b>, and it is generally not considered
a good idea.  Here is a minimal program with an infinite recursion:</p>

<pre class="python">
def recurse():
    recurse()
</pre>

<p>In most programming environments, a program with infinite recursion does not 
really run forever.  Python reports an error message when the maximum recursion 
depth is reached:</p>

<pre class="shell">
File "&lt;stdin&gt;", line 2, in recurse
(98 repetitions omitted)
File "&lt;stdin&gt;", line 2, in recurse
RuntimeError: maximum recursion depth exceeded
</pre>

<p>This traceback is a little bigger than the one we saw in the previous
chapter.  When the error occurs, there are 100 <code>recurse</code> frames on
the stack!</p>


<h2>Tail recursion</h2>
<span class="index" value="tail recursion" />
<p>
In each of the examples of recursive functions above, the recursive
call is the last statement in the function.  This is called
<b>tail recursion</b>, and from a software engineering point of
view it is a bad thing to do.  Later we will see a better way to write
the functions above using <em>iteration</em>.  Iteration is more efficient
both in terms of speed and memory usage than tail recursion.
</p>

<p>
There are plenty of cases, however, where using recursion is the best way
to go, both in terms of computational elegance and efficiency.  We will
learn more about such cases when we talk about nested lists and trees. 
</p>


<h2>Keyboard input</h2>

<p>In chapter 2 we were introduced to Python's built-in functions that get
input from the keyboard: <code>raw_input</code> and <code>input</code>.
Now let's look at these again in greater depth.</p>

<p>When either of these functions are called, the program stops and waits for
the user to type something.  When the user presses Return or the Enter key, the 
program resumes and <code>raw_input</code> returns what the user typed as a
<code>string</code>:</p>

<pre class="python-interpreter">
>>> my_input = raw_input()
What are you waiting for?
>>> print my_input
What are you waiting for?
</pre>

<p>Before calling <code>raw_input</code>, it is a good idea to print a message
telling the user what to input.  This message is called a <b>prompt</b>.
We can supply a prompt as an argument to <code>raw_input</code>:</p>

<span class="index" value="prompt" />

<pre class="python-interpreter">
>>> name = raw_input("What...is your name? ")
What...is your name? Arthur, King of the Britons!
>>> print name
Arthur, King of the Britons!
</pre>

<p>Notice that the prompt is a string, so it must be enclosed in parenthesis.
</p>

<p>If we expect the response to be an integer, we can use the
<code>input</code> function which evaluates the response as a Python
expression:</p>

<pre class="python">
prompt = "What...is the airspeed velocity of an unladen swallow?\n"
speed = input(prompt)
</pre>

<p>If the user types a string of digits, it is converted to an integer and
assigned to <code>speed</code>.  Unfortunately, if the user types characters
that do not make up a valid Python expression, the program crashes:</p>

<pre class="python-interpreter">
>>> speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
...
SyntaxError: invalid syntax
</pre>

<p>In the last example, if the user had made the response a valid Python
expression by putting quotes around it, it would not have given an error:
</p>

<pre class="python-interpreter">
>>> speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
"What do you mean, an African or a European swallow?"
>>> speed
'What do you mean, an African or a European swallow?'
>>>
</pre>

<p>To avoid this kind of error, it is a good idea to use <code>raw_input</code> 
to get a string and then use conversion commands to convert it to other types.
</p>


<h2>Type conversion</h2>
<span class="index" value="converstion!type" />
<span class="index" value="type converstion" />

<p>Each Python type comes with a built-in command that attemps to convert values
of another type into that type.  The <code>int(ARGUMENT)</code> command, for
example, takes any value and converts it to an integer, if possible, or
complains otherwise:</p>

<pre class="python-interpreter">
>>> int("32")
32
>>> int("Hello")
ValueError: invalid literal for int() with base 10: 'Hello'
</pre>

<p><code>int</code> can also convert floating-point values to integers, but
remember that it truncates the fractional part:</p>

<pre class="python-interpreter">
>>> int(-2.3)
-2
>>> int(3.99999)
3
>>> int("42")
42
>>> int(1.0)
1
</pre>

<p>The <code>float(ARGUMENT)</code> command converts integers and strings to
floating-point numbers:</p>

<pre class="python-interpreter">
>>> float(32)
32.0
>>> float("3.14159")
3.14159
>>> float(1)
1.0
</pre>

<p>It may seem odd that Python distinguishes the integer value <code>1</code>
from the floating-point value <code>1.0</code>.  They may represent the same
number, but they belong to different types.  The reason is that they
are represented differently inside the computer.</p>

<p>The <code>str(ARGUMENT)</code> command converts any argument given to it to
type <code>string</code>:</p>

<pre class="python-interpreter">
>>> str(32)
'32'
>>> str(3.14149)
'3.14149'
>>> str(True)
'True'
>>> str(true)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'true' is not defined
</pre>

<p><code>str(ARGUMENT)</code> with work with any value and convert it into
a string.  As mentioned earlier, <code>True</code> is boolean value;
<code>true</code> is not.</p>

<p>For boolean values, the situation is especially interesting:</p>

<pre class="python-interpreter">
>>> bool(1)
True
>>> bool(0)
False
>>> bool("Ni!")
True
>>> bool("")
False
>>> bool(3.14159)
True
>>> bool(0.0)
False
</pre>

<p>Python assigns boolean values to values of other types.  For numerical
types like integers and floating-points, zero values are false and non-zero
values are true.  For strings, empty strings are false and non-empty strings
are true.</p>


<h2>Glossary</h2>
<span class="index" value="modulus operator" />
<span class="index" value="boolean expression" />
<span class="index" value="expression!boolean" />
<span class="index" value="conditional statement" />
<span class="index" value="statement!conditional" />
<span class="index" value="condition" />
<span class="index" value="compound statement" />
<span class="index" value="branch" />
<span class="index" value="body" />
<span class="index" value="block" />
<span class="index" value="branch" />
<span class="index" value="chained conditional" />
<span class="index" value="nesting" />
<span class="index" value="recursion" />
<span class="index" value="base case" />
<span class="index" value="infinite recursion" />
<span class="index" value="tail recursion" />
<span class="index" value="prompt" />
<span class="index" value="type conversion" />

<dl>
<dt>modulus operator:</dt>
<dd>An operator, denoted with a percent sign (<code>%</code>), that works on
integers and yields the remainder when one number is divided by another.</dd>

<dt>boolean value:</dt>
<dd>There are exactly two boolean values: <code>True</code> and
<code>False</code>.  Boolean values result when a boolean expression is
evaluated by the Python interepreter.  They have type <code>bool</code>.
</dd>

<dt>boolean expression:</dt>
<dd>An expression that is either true or false.</dd>

<dt>comparison operator:</dt>
<dd> One of the operators that compares two
values: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, 
<code>&gt;=</code>, and <code>&lt;=</code>.</dd>

<dt>logical operator:</dt>
<dd>One of the operators that combines boolean expressions: <code>and</code>,
<code>or</code>, and <code>not</code>.</dd>

<dt>conditional statement:</dt>
<dd>A statement that controls the flow of execution depending on some
condition.</dd>

<dt>condition:</dt>
<dd>The boolean expression in a conditional statement that determines which
branch is executed.</dd>

<dt>block:</dt>
<dd>A group of consecutive statements with the same indentation.</dd>

<dt>body:</dt>
<dd>The block of statements in a compound statement that follows the header.
</dd>

<dt>branch:</dt>
<dd>One of the possible paths of the flow of execution determined by 
conditional execution.</dd>

<dt>chained conditional:</dt>
<dd>A conditional branch with more than two possible flows of execution.
In Python chained conditionals are written with
<code class="Python">if ... elif ... else</code> statements.</dd>

<dt>nesting:</dt>
<dd>One program structure within another, such as a conditional statement
inside a branch of another conditional statement.</dd>

<dt>recursion:</dt>
<dd>The process of calling the function that is currently executing.</dd>

<dt>recursive call:</dt>
<dd>The statement in a recursive function with is a call to itself.</dd>

<dt>base case:</dt>
<dd>A branch of the conditional statement in a recursive function that does not 
result in a recursive call.</dd>

<dt>infinite recursion:</dt>
<dd>A function that calls itself recursively without ever reaching the base
case.  Eventually, an infinite recursion causes a runtime error.</dd>

<dt>tail recursion:</dt>
<dd>A recursive call that occurs as the last statement (at the tail) of a
recursive function.  Tail recursion is considered bad practice in Python
programs since a logically equivalent function can be written using
<em>iteration</em> which is more efficient.</dd>

<dt>prompt:</dt>
<dd>A visual cue that tells the user to input data.</dd>

<dt>type conversion:</dt>
<dd>An explicit statement that takes a value of one type and computes a
corresponding value of another type.</dd>
</dl>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
<p>Try to evaluate the following numerical expressions in your head, then use
the Python interpreter to check your results:</p>
  <ol style="list-style-type: lower-alpha;">
    <li><code>>>> 5 % 2</code></li>
    <li><code>>>> 9 % 5</code></li>
    <li><code>>>> 15 % 12</code></li>
    <li><code>>>> 12 % 15</code></li>
    <li><code>>>> 6 % 6</code></li>
    <li><code>>>> 0 % 7</code></li>
    <li><code>>>> 7 % 0</code></li>
  </ol>
<p>What happened with the last example?  Why?  If you were able to correctly
anticipate the computer's response in all but the last one, it is time to move
on.  If not, take time now to make up examples of your own.  Explore the
modulus operator until you are confident you understand how it works.</p>
</div></li>

<li><div class="exercise">
<pre class="python">
if x &lt; y:
    print x, "is less than", y
elif x &gt; y:
    print x, "is greater than", y
else:
    print x, "and", y, "are equal"
</pre>
<em>Wrap</em> this code in a function called <code>compare(x, y)</code>.
<em>Call</em> <code>compare</code> three times: one each where the first
<em>argument</em> is less than, greater than, and equal to the second
argument.
</div></li>

<li><div class="exercise">
<p>
To better understand boolean expressions, it is helpful to construct
truth tables.  Two boolean expressions are <em>logically equivalent</em>
if and only if they have the same truth table.
</p>
<p>
The following Python script prints out the truth table for the
any boolean expression in two variables: p and q:
</p>
<pre class="python">
expression = raw_input("Enter a boolean expression in two variables, p and q: ")

print " p      q      %s"  % expression
length = len( " p      q      %s"  % expression)
print length*"="

for p in True, False:
    for q in True, False:
        print "%-7s %-7s %-7s" % (p, q, eval(expression))
</pre>
<p>
You will learn how this script works in later chapters.  For now, you will
use it to learn about boolean expressions.  Copy this program to a file named
<code>p_and_q.py</code>, then run it from the command line and give it:
<code>p or q</code>, when prompted for a boolean expression.  You should
get the following output:
</p>
<pre class="boxed">
 p      q      p or q
=====================
True    True    True   
True    False   True   
False   True    True   
False   False   False
</pre>
<p>
Run <code>p_and_q.py</code> with the following boolean expressions,
recording the truth table produced each time:
</p>
  <ol style="list-style-type: lower-alpha;">
    <li>not(p or q)</li>
    <li>p and q</li>
    <li>not(p and q)</li>
    <li>not(p) or not(q)</li>
    <li>not(p) and not(q)</li>
  </ol> 
<p>
Which of these are logically equivalent?
</p>
</div></li>

<li><div class="exercise">
<pre class="python">
if choice == 'A':
    functionA()
elif choice == 'B':
    functionB()
elif choice == 'C':
    functionC()
else:
    print "Invalid choice."
</pre>
<p>
Wrap this code in a function called <code>dispatch(choice)</code>. Then
define <code>functionA</code>, <code>functionB</code>, and
<code>functionC</code> so that they print out a message saying they were
called.  For example:
</p>
<pre class="python">
def functionA():
    print "functionA was called..."
</pre>
<p>
Put the four functions (<code>dispatch</code>, <code>functionA</code>,
<code>functionB</code>, and <code>functionC</code> into a script named
<code>ch4prob4.py</code>.  At the bottom of this script add a call to
<code>dispatch('B')</code>.  Your output should be:
</p>
<pre class="boxed">
functionB was called...
</pre>
<p>
Finally, modify the script so that user can enter 'A', 'B', or 'C'.
</p>
</div></li>

<li><div class="exercise">
Write a function with infinite recursion and run it in the Python interpreter.
</div></li>

<li><div class="exercise">
<p>
Write a function named <code>is_divisable_by_3</code> that takes a single
integer as an argument and prints "This number is divisable by three." if
the argument is evenly divisable by 3 and "This number is not divisable by
three." otherwise.
</p>
<p>
Now write a similar function named <code>is_divisable_by_5</code>.
</p>
</div></li>

<li><div class="exercise">
<p>
Generalize the functions you wrote in the previous exercise into a function
named <code>is_divisable_by_n(x, n)</code> that takes two integer arguments
and prints out whether the first is divisable by the second.  A sample
run could look like this:
</p>
<pre class="python">
is_divisable_by_n(20, 4)
Yes, 20 is divisable by 4
</pre>
</div></li>

<li><div class="exercise">
Draw a stack diagram for <code>n_lines</code> called with <code>n</code> set to
4.
</div></li>

<li><div class="exercise">
What will be the output of the following?
<pre class="python">
if "Ni!":
    print 'We are the Knights who say, "Ni!"'
else:
    print "Stop it! No more of this!"

if 0:
    print "And now for something completely different..."
else:
    print "What's all this, then?"
</pre>

Explain what happened and why it happened.
</div></li>
</ol>

</body>
</html>
