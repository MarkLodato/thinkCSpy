<html>
<head>
  <title>Recursion and exceptions</title>
</head>
<body>

<h1>Recursion and exceptions</h1>
<a name="recursionchap" />


<h2>Tuples and mutability</h2>
<span class="index" value="tuple" />
<span class="index" value="immutable" />
<span class="index" value="mutable" />
<span class="index" value="data type!tuple" />
<span class="index" value="data type!immutable" />
<span class="index" value="sequence!immutable" />

<p>So far, you have seen two compound types: strings, which are made up of
characters; and lists, which are made up of elements of any type.  One of the
differences we noted is that the elements of a list can be modified, but the
characters in a string cannot.  In other words, strings are
<b>immutable</b> and lists are <b>mutable</b>.</p>

<p>A <b>tuple</b> is a type in Python that like a list is a sequence of items
of any type.  Unlike lists, however, tuples are immutable.</p>

<p>Syntactically, a tuple is a comma-separated sequence of values:</p>

<pre class="python-interpreter">
>>> tup = 2, 4, 6, 8, 10
</pre>

<p>Although it is not necessary, it is conventional to enclose tuples in
parentheses:</p>

<pre class="python-interpreter">
>>> tup = (2, 4, 6, 8, 10)
</pre>

<p>To create a tuple with a single element, we have to include the final
comma:</p>

<pre class="python-interpreter">
>>> tup = (5,)
>>> type(tup)
&lt;type 'tuple'>
</pre>

<p>Without the comma, Python treats <code>(5)</code> as an integer in
parentheses:</p>

<pre class="python-interpreter">
>>> tup = (5)
>>> type(tup)
&lt;type 'int'&gt;
</pre>

<p>Syntax issues aside, tuples support the same sequence operations as 
strings and lists.  The index operator selects an element from a tuple.</p>

<pre class="python-interpreter">
>>> tup = ('a', 'b', 'c', 'd', 'e')
>>> tup[0]
'a'
</pre>

<p>And the slice operator selects a range of elements.</p>

<pre class="python-interpreter">
>>> tup[1:3]
('b', 'c')
</pre>

<p>But if we try to use item assignment to modify one of the elements of the
tuple, we get an error:
</p>
<span class="index" value="runtime error" />

<pre class="python-interpreter">
>>> tup[0] = 'X'
TypeError: 'tuple' object does not support item assignment
</pre>

<p>Of course, even if we can't modify the elements of a tuple, we can replace
it with a different tuple:</p>

<pre class="python-interpreter">
>>> tup = ('X',) + tup[1:]
>>> tup
('X', 'b', 'c', 'd', 'e')
</pre>

<p>Alternatively, we could first convert it to a list, modify it, and convert
it back into a tuple:</p>

<pre class="python-interpreter">
>>> tup = ('X', 'b', 'c', 'd', 'e')
>>> tup = list(tup)
>>> tup
['X', 'b', 'c', 'd', 'e']
>>> tup[0] = 'a'
>>> tup = tuple(tup)
>>> tup
('a', 'b', 'c', 'd', 'e')
</pre>


<h2>Tuple assignment</h2>
<a name="tuple assignment" />
<span class="index" value="tuple assignment" />
<span class="index" value="assignment!tuple" />

<p>Once in a while, it is useful to swap the values of two variables.  With
conventional assignment statements, we have to use a temporary variable.  For
example, to swap <code>a</code> and <code>b</code>:</p>

<pre class="python">
temp = a
a = b
b = temp
</pre>

<p>If we have to do this often, this approach becomes cumbersome.  Python
provides a form of <b>tuple assignment</b> that solves this problem
neatly:</p>

<pre class="python">
a, b = b, a
</pre>

<p>The left side is a tuple of variables; the right side is a tuple of values.  
Each value is assigned to its respective variable.  All the expressions on the
right side are evaluated before any of the assignments.  This feature makes
tuple assignment quite versatile.</p>

<p>Naturally, the number of variables on the left and the number of values on
the right have to be the same:</p>

<pre class="python-interpreter">
>>> a, b, c, d = 1, 2, 3
ValueError: need more than 3 values to unpack 
</pre>


<h2>Tuples as return values</h2>
<span class="index" value="tuple" />
<span class="index" value="value!tuple" />
<span class="index" value="return value!tuple" />
<span class="index" value="function!tuple as return value" />

<p>Functions can return tuples as return values.  For example, we could write a 
function that swaps two parameters:</p>

<pre class="python">
def swap(x, y):
    return y, x
</pre>

<p>Then we can assign the return value to a tuple with two variables:</p>

<pre class="python">
a, b = swap(a, b)
</pre>

<p>In this case, there is no great advantage in making <code>swap</code> a
function.  In fact, there is a danger in trying to encapsulate
<code>swap</code>, which is the following tempting mistake:</p>

<pre class="python">
def swap(x, y):      # incorrect version
     x, y = y, x
</pre>

<p>If we call this function like this:</p>

<pre class="python">
swap(a, b)
</pre>

<p>then <code>a</code> and <code>x</code> are aliases for the same value.
Changing <code>x</code> inside <code>swap</code> makes <code>x</code> refer to
a different value, but it has no effect on <code>a</code> in
<code>__main__</code>.  Similarly, changing <code>y</code> has no effect on
<code>b</code>.</p>

<p>This function runs without producing an error message, but it doesn't do
what we intended.  This is an example of a semantic error.</p>
<span class="index" value="semantic error" />


<h2>Pure functions and modifiers revisited</h2>
<span class="index" value="modifier" />
<span class="index" value="function type!modifier" />
<span class="index" value="side effect" />
<span class="index" value="pure function" />
<span class="index" value="function type!pure" />

<p>In chapter 9 we discussed <em>pure functions</em> and <em>modifiers</em>
as related to lists.  Since tuples are immutable we can not write modifiers
on them.</p>

<p>Here is a modifier that inserts a new value into the middle of a list:</p>

<pre class="python">
#
# seqtools.py
#

def insert_in_middle(val, lst):
    middle = len(lst)/2
    lst[middle:middle] = [val]
</pre>

<p>We can run it to see that it works:</p>

<pre class="python-interpreter">
>>> from seqtools import *
>>> my_list = ['a', 'b', 'd', 'e']
>>> insert_in_middle('c', my_list)
>>> my_list
['a', 'b', 'c', 'd', 'e']
</pre>

<p>If we try to use it with a tuple, however, we get an error:</p>

<pre class="python-interpreter">
>>> my_tuple = ('a', 'b', 'd', 'e')
>>> insert_in_middle('c', my_tuple)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "seqtools.py", line 7, in insert_in_middle
    lst[middle:middle] = [val]
TypeError: 'tuple' object does not support item assignment
>>> 
</pre>

<p>The problem is that tuples are immutable, and don't support slice
assignment.  A simple solution to this problem is to make
<code>insert_in_middle</code> a pure function:</p>

<pre class="python">
def insert_in_middle(val, tup):
    middle = len(tup)/2
    return tup[:middle] + (val,) + tup[middle:]
</pre>

<p>This version now works for tuples, but not for lists or strings.  If we
want a version that works for all sequence types, we need a way to encapsulate
our value into the correct sequence type.  A small helper function does the
trick:</p>

<pre class="python">
def encapsulate(val, seq):
    if type(seq) == type(""):
        return str(val)
    if type(seq) == type([]):
        return [val]
    return (val,) 
</pre>

<p>Now we can write <code>insert_in_middle</code> to work with each of the
built-in sequence types:</p>

<pre class="python">
def insert_in_middle(val, seq):
    middle = len(seq)/2
    return seq[:middle] + encapsulate(val, seq) + seq[middle:]
</pre>

<p>The last two versions of <code>insert_in_middle</code> are pure functions.
They don't have any side effects.  Adding <code>encapsulate</code> and the
last version of <code>insert_in_middle</code> to the <code>seqtools.py</code>
module, we can test it:</p>

<pre class="python-interpreter">
>>> from seqtools import *
>>> my_string = 'abde'
>>> my_list = ['a', 'b', 'd', 'e']
>>> my_tuple = ('a', 'b', 'd', 'e')
>>> insert_in_middle('c', my_string)
'abcde'
>>> insert_in_middle('c', my_list)
['a', 'b', 'c', 'd', 'e']
>>> insert_in_middle('c', my_tuple)
('a', 'b', 'c', 'd', 'e')
>>> my_string
'abde'
</pre>

<p>The values of <code>my_string</code>, <code>my_list</code>, and
<code>my_tuple</code> are not changed.  If we want to use
<code>insert_in_middle</code> to change them, we have to assign the value
returned by the function call back to the variable:</p>

<pre class="python-interpreter">
>>> my_string = insert_in_middle('c', my_string)
>>> my_string
'abcde' 
</pre>


<h2>Recursive data structures</h2>
<a name="recursion" />
<span class="index" value="data structure" />
<span class="index" value="recursive definition" />
<span class="index" value="definition!recursive" />
<span class="index" value="recursive data structure" />
<span class="index" value="data structure!recursive" />

<p>All of the Python data types we have seen can be grouped inside lists and
tuples in a variety of ways.  Lists and tuples can also be nested, providing
myriad possibilities for organizing data.  The organization of data for the
purpose of making it easier to use is called a <b>data structure</b>.</p>

<p>It's election time and we are helping to compute the votes as they come in.
Votes arriving from individual wards, precincts, municipalities, counties,
and states are sometimes reported as a sum total of votes and sometimes as a
list of subtotals of votes.  After considering how best to store the tallies,
we decide to use a <em>nested number list</em>, which we define as follows:</p>

<p>A <em>nested number list</em> is a list whose elements are either:</p>
<ol style="list-style-type: lower-alpha">
  <li>numbers</li>
  <li>nested number lists</li>
</ol>

<p>Notice that the term, <q>nested number list</q> is used in its own
definition.  <b>Recursive definitions</b> like this are quite common in
mathematics and computer science.  They provide a concise and powerful way to
describe <b>recursive data structures</b> that are partially composed of
smaller and simpler instances of themselves.  The definition is not circular,
since at some point we will reach a list that does not have any lists as
elements.</p>

<p>Now suppose our job is to write a function that will sum all of the values
in a nested number list.  Python has a built-in function which finds the sum of 
a sequence of numbers:</p>

<pre class="python-interpreter">
>>> sum([1, 2, 8])
11
>>> sum((3, 5, 8.5))
16.5
>>>
</pre>

<p>For our <em>nested number list</em>, however, <code>sum</code> will not
work:</p> 

<pre class="python-interpreter">
>>> sum([1, 2, [11, 13], 8])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'int' and 'list'
>>> 
</pre>

<p>The problem is that the third element of this list, <code>[11, 13]</code>,
is itself a list, which can not be added to <code>1</code>, <code>2</code>,
and <code>8</code>.
</p>


<h2>Recursion</h2>
<span class="index" value="recursion" />
<span class="index" value="recursive function" />
<span class="index" value="function!recursive" />

<p>To sum all the numbers in our recursive nested number list we need to
traverse the list, visiting each of the elements within its nested structure,
adding any numeric elements to our sum, and <em>repeating this process</em>
with any elements which are lists.</p>

<p>Modern programming languages generally support <b>recursion</b>, which
means that functions can <em>call themselves</em> within their definitions.
Thanks to recursion, the Python code needed to sum the values of a nested
number list is surprisingly short:</p>

<pre class="python">
def recursive_sum(nested_num_list):
    sum = 0
    for element in nested_num_list:
        if type(element) == type([]):
            sum = sum + recursive_sum(element)
        else:
            sum = sum + element
    return sum
</pre>

<p>The body of <code>recursive_sum</code> consists mainly of a <code>for</code>
loop that traverses <code>nested_num_list</code>.  If <code>element</code> is a 
numerical value (the <code>else</code> branch), it is simply added to
<code>sum</code>.  If <code>element</code> is a list, then
<code>recursive_sum</code> is called again, with the element as an argument.
</p>

<p>Recursion is truly one of the most beautiful and elegant tools in computer
science.</p>

<p>A slightly more complicated problem is finding the largest value in our
nested number list:</p>

<pre class="python">
def recursive_max(nested_num_list):
    """
      >>> recursive_max([2, 9, [1, 13], 8, 6])
      13
      >>> recursive_max([2, [[100, 7], 90], [1, 13], 8, 6])
      100
      >>> recursive_max([2, [[13, 7], 90], [1, 100], 8, 6])
      100
      >>> recursive_max([[[13, 7], 90], 2, [1, 100], 8, 6])
      100
    """
    largest = nested_num_list[0]
    while type(largest) == type([]):
        largest = largest[0]

    for element in nested_num_list:
        if type(element) == type([]):
            max_of_elem = recursive_max(element)
            if largest &lt; max_of_elem:
                largest = max_of_elem
        else:                           # element is not a list
            if largest &lt; element:
                largest = element

    return largest
</pre>

<p>Doctests are included to provide examples of <code>recursive_max</code>
at work.</p>

<p>The added twist to this problem is finding a numerical value for
initializing <code>largest</code>.  We can't just use
<code>nested_num_list[0]</code>, since that my be either a number or a list.
To solve this problem we use a while loop that assigns <code>largest</code>
to the first numerical value no matter how deeply it is nested.</p>

<p>The two examples above each have a <b>base case</b> which does not lead to
a recursive call: the case where the element is a number and not a list.
Without a base case, you have <b>infinite recursion</b>, and your program will
not work.  Python stops after reaching a maximum recursion depth and
returns a runtime error.</p>

<p>Write the following in a file named <code>infinite_recursion.py</code>:</p>

<pre class="python">
def recursion_depth(number):
    print "Recursion depth number %d." % number
    recursion_depth(number + 1)

recursion_depth(0)
</pre>
 
<p>At the unix command prompt in the same directory in which you saved your
program, type the following:</p>

<pre class="shell">
python infinite_recursion.py
</pre>

<p>After watching the messages flash by, you will be presented with the end
of a long traceback that ends in with the following:</p>

<pre class='shell'>
  ...
  File "infinite_recursion.py", line 3, in recursion_depth
    recursion_depth(number + 1)
RuntimeError: maximum recursion depth exceeded
</pre>

<p>We would certainly never want something like this to happen to a user of
one of our programs, so before finishing our discussion of recursion, let's 
take a detour to discuss how errors like this are handled in Python.</p>


<h2>Exceptions</h2>
<span class="index" value="exception" />
<span class="index" value="traceback" />
<span class="index" value="handle an exception" />
<span class="index" value="exception handling" />
<span class="index" value="try statement" />
<span class="index" value="statement!try" />
<span class="index" value="except statement" />
<span class="index" value="statement!except" />
<span class="index" value="raise exception" />

<p>Whenever a runtime error occurs, it creates an <b>exception</b>.  The
program stops running at this point and Python prints out the traceback,
which ends with the exception which occured.</p>

<p>For example, dividing by zero creates an exception:</p>

<pre class="python-interpreter">
>>> print 55/0
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ZeroDivisionError: integer division or modulo by zero
>>>
</pre>

<p>So does accessing a nonexistent list item:</p>

<pre class="python-interpreter">
>>> a = []
>>> print a[5]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: list index out of range
>>>
</pre>

<p>Or trying to make an item assignment on a tuple:</p>

<pre class="python">
>>> tup = ('a', 'b', 'd', 'd')
>>> tup[2] = 'c' 
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'tuple' object does not support item assignment
>>>
</pre>

<p>In each case, the error message on the last line has two parts: the type of
error before the colon, and specifics about the error after the colon.</p>

<p>Sometimes we want to execute an operation that might cause an exception, but 
we don't want the program to stop.  We can <b>handle the exception</b> using
the <code>try</code> and <code>except</code> statements.</p>

<p>For example, we might prompt the user for the name of a file and then try to 
open it.  If the file doesn't exist, we don't want the program to crash; we
want to handle the exception:</p>

<pre class="python">
filename = raw_input('Enter a file name: ')
try:
    f = open (filename, "r")
except:
    print 'There is no file named', filename
</pre>

<p>The <code>try</code> statement executes the statements in the first block.
If no exceptions occur, it ignores the <code>except</code> statement.  If any
exception occurs, it executes the statements in the <code>except</code> branch
and then continues.</p>

<p>We can encapsulate this capability in a function: <code>exists</code> takes
a filename and returns true if the file exists, false if it doesn't:</p>

<pre class="python">
def exists(filename):
    try:
        f = open(filename)
        f.close()
        return 1
    except:
        return 0
</pre>

<p>You can use multiple <code>except</code> blocks to handle different kinds of
exceptions.  The <em>Python Reference Manual</em> has the details.</p>

<p>If your program detects an error condition, you can make it
<b>raise</b> an exception.  Here is an example that gets input from
the user and checks for the value 17.  Assuming that 17 is not valid input for
some reason, we raise an exception.</p>

<pre class="python">
def inputNumber():
    x = input('Pick a number: ')
    if x == 17:
        raise 'BadNumberError', '17 is a bad number'
    return x
</pre>

<p>The <code>raise</code> statement takes two arguments: the exception type and 
specific information about the error.  <code>BadNumberError</code> is a new
kind of exception we invented for this application.</p>

<p>If the function that called <code>inputNumber</code> handles the error, then 
the program can continue; otherwise, Python prints the error message and exits:
</p>

<pre class="python-interpreter">
>>> inputNumber()
Pick a number: 17
BadNumberError: 17 is a bad number
</pre>

<p>The error message includes the exception type and the additional information 
you provided.</p>

<p>When a recursive call occurs as the last line of a function definition, it
is refered to as <b>tail recursion</b>.</p>

<p>Here is a version of the <code>countdown</code> function from chapter 6
written using tail recursion:</p>

<pre class="python">
def countdown(n):
    if n == 0:
        print "Blastoff!"
    else:
        print n
        countdown(n-1)
</pre> 

<p>Any computation that can be made using iteration can also be made using
recursion.</p>

<p>Tail recursion is considered a bad practice in languages like Python,
however, since it uses more system resources than the equivalent iterative
solution.</p>


<h2>List comprehensions</h2>
<span class="index" value="list comprehension" />

<p>A <b>list comprehension</b> is a syntactic construct that enables lists
to be created from other lists using a compact, mathematical syntax:</p>

<pre class="python-interpreter">
>>> numbers = [1, 2, 3, 4]
>>> [x**2 for x in numbers]
[1, 4, 9, 16]
>>> [x**2 for x in numbers if x**2 &gt; 8]
[9, 16] 
>>> [(x, x**2, x**3) for x in numbers]
[(1, 1, 1), (2, 4, 8), (3, 9, 27), (4, 16, 64)]
>>> files = ['bin', 'Data', 'Desktop', '.bashrc', '.ssh', '.vimrc']
>>> [name for name in files if name[0] != '.']
['bin', 'Data', 'Desktop']
>>> letters = ['a', 'b', 'c']
>>> [n*letter for n in numbers for letter in letters]
['a', 'b', 'c', 'aa', 'bb', 'cc', 'aaa', 'bbb', 'ccc', 'aaaa', 'bbbb', 'cccc']
>>>
</pre>

<p>The general syntax for a list comprehension expression is:</p>

<pre class="python">
[<em>expr</em> for <em>item1</em> in <em>seq1</em> for <em>item2</em> in <em>seq2</em> ... for <em>itemx</em> in <em>seqx</em> if <em>condition</em>]
</pre>

<p>This list expression has the same effect as:</p>

<pre class="python">
output_sequence = []
for <em>item1</em> in <em>seq1</em>:
    for <em>item2</em> in <em>seq2</em>:
        ...
            for <em>itemx</em> in <em>seqx</em>:
                if <em>condition</em>:
                    output_sequence.append(<em>expr</em>)
</pre>

<p>As you can see, the list comprehension is much more compact.</p>


<h2>Mini case study: tree</h2>

<p>The following program implements a subset of the behavior of the Unix
<a href="http://en.wikipedia.org/wiki/Tree_(Unix)">tree</a> program.</p>

<pre class='python'>
#!/usr/bin/env python

import os
import sys


def getroot():
    if len(sys.argv) == 1:
        path = ''
    else:
        path = sys.argv[1]

    if os.path.isabs(path):
        tree_root = path
    else:
        tree_root = os.path.join(os.getcwd(), path)

    return tree_root


def getdirlist(path):
    dirlist = os.listdir(path)
    dirlist = [name for name in dirlist if name[0] != '.']
    dirlist.sort()
    return dirlist


def traverse(path, prefix='|--', s='.\n', f=0, d=0):
    dirlist = getdirlist(path)

    for num, file in enumerate(dirlist):
        lastprefix = prefix[:-3] + '`--'
        dirsize = len(dirlist)

        if num &lt; dirsize - 1:
            s += '%s %s\n' % (prefix, file)
        else:
            s += '%s %s\n' % (lastprefix, file)
        path2file = os.path.join(path, file)

        if os.path.isdir(path2file):
            d += 1
            if getdirlist(path2file):
                s, f, d = traverse(path2file, '|   ' + prefix, s, f, d)
        else:
            f += 1

    return s, f, d


if __name__ == '__main__':
    root =  getroot()
    tree_str, files, dirs = traverse(root)

    if dirs == 1:
        dirstring = 'directory'
    else:
        dirstring = 'directories'
    if files == 1:
        filestring = 'file'
    else:
        filestring = 'files'

    print tree_str
    print '%d %s, %d %s' % (dirs, dirstring, files, filestring)
</pre>

<p>You will be asked to explore this program in several of the exercises
below.</p>


<h2>Glossary</h2>
<span class="index" value="mutable type" />
<span class="index" value="immutable type" />
<span class="index" value="tuple" />
<span class="index" value="tuple assignment" />
<span class="index" value="assignment!tuple" />
<span class="index" value="module" />
<span class="index" value="import statement" />
<span class="index" value="recursive definition" />
<span class="index" value="recursion" />
<span class="index" value="base case" />
<span class="index" value="infinite recursion" />
<span class="index" value="exception" />
<span class="index" value="try statement" />
<span class="index" value="raise exception" />
<span class="index" value="handle exception" />
<span class="index" value="except statement" />
<span class="index" value="tail recursion" />
<span class="index" value="list comprehension" />

<dl>
<dt>immutable type:</dt>
<dd>A type in which the elements cannot be modified.  Assignments to elements
or slices of immutable types cause an error.</dd>

<dt>mutable type:</dt>
<dd>A data type in which the elements can be modified.  All mutable types are
compound types.  Lists and dictionaries (see next chapter) are mutable data
types; strings and tuples are not.</dd>

<dt>tuple:</dt>
<dd>A sequence type that is similar to a list except that it is immutable.
Tuples can be used wherever an immutable type is required, such as a key in a
dictionary.</dd>

<dt>tuple assignment:</dt>
<dd>An assignment to all of the elements in a tuple using a single assignment
statement. Tuple assignment occurs in parallel rather than in sequence, making
it useful for swapping values.</dd>

<dt>module:</dt>
<dd>A file containing definitions and statements intended to be
<em>imported</em> by other programs.  File names for Python modules must end in 
a <code>.py</code> file extention, and the module name is the filename without
the extention.</dd>

<dt>recursive definition:</dt>
<dd>A definition which defines something in terms of itself. To be useful it
must include <em>base cases</em> which are not recursive.  In this way it
differs from a <em>circular definition</em>.  Recursive definitions often
provide an elegant way to express complex data structures.</dd> 

<dt>recursion:</dt>
<dd>The process of calling the function that is currently executing.</dd>

<dt>recursive call:</dt>
<dd>The statement in a recursive function with is a call to itself.</dd>

<dt>base case:</dt>
<dd>A branch of the conditional statement in a recursive function that does not
result in a recursive call.</dd>

<dt>infinite recursion:</dt>
<dd>A function that calls itself recursively without ever reaching the base
case.  Eventually, an infinite recursion causes a runtime error.</dd>

<dt>exception:</dt>
<dd>An error that occurs at runtime.</dd>

<dt>handle:</dt>
<dd>To prevent an exception from terminating a program using the
<code>try</code> and <code>except</code> statements.</dd>

<dt>raise:</dt>
<dd>To signal an exception using the <code>raise</code> statement.</dd>

<dt>tail recursion:</dt>
<dd>A recursive call that occurs as the last statement (at the tail) of a
function definition.  Tail recursion is considered bad practice in Python
programs since a logically equivalent function can be written using
<em>iteration</em> which is more efficient (see the Wikipedia article on
<a href="http://en.wikipedia.org/wiki/Tail_recursion">tail recursion</a>
for more information).
</dd>

<dt>list comprehension:</dt>
<dd>A syntactic construct which enables lists to be generated from other
lists using a syntax analogous to the mathematical
<a href="http://en.wikipedia.org/wiki/Set-builder_notation">set-builder
notation</a>.
</dd>
</dl>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
<pre class="python">
def swap(x, y):      # incorrect version
     print  "before swap statement: id(x):", id(x), "id(y):", id(y)
     x, y = y, x
     print  "after swap statement: id(x):", id(x), "id(y):", id(y)

a, b = 0, 1
print  "before swap function call: id(a):", id(a), "id(b):", id(b)
swap(a, b)
print  "after swap function call: id(a):", id(a), "id(b):", id(b)
</pre>
Run this program and describe the results.  Use the results to explain why
this version of <code>swap</code> does not work as intended.  What will be
the values of <code>a</code> and <code>b</code> after the call to
<code>swap</code>?
</div></li>

<li><div class="exercise">
Create a module named <code>seqtools.py</code>.   Add the functions
<code>encapsulate</code> and <code>insert_in_middle</code> from the chapter.
Add doctests which test that these two functions work as intended with all
three sequence types.
</div></li>

<li><div class="exercise">
Add each of the following functions to <code>seqtools.py</code>:
<pre class="python">
def make_empty(seq):
    """
      >>> make_empty([1, 2, 3, 4])
      []
      >>> make_empty(('a', 'b', 'c'))
      ()
      >>> make_empty("No, not me!")
      ''
    """

def insert_at_end(val, seq):
    """
      >>> insert_at_end(5, [1, 3, 4, 6])
      [1, 3, 4, 6, 5]
      >>> insert_at_end('x', 'abc')
      'abcx'
      >>> insert_at_end(5, (1, 3, 4, 6))
      (1, 3, 4, 6, 5)
    """

def insert_in_front(val, seq):
    """
      >>> insert_in_front(5, [1, 3, 4, 6])
      [5, 1, 3, 4, 6]
      >>> insert_in_front(5, (1, 3, 4, 6))
      (5, 1, 3, 4, 6)
      >>> insert_in_front('x', 'abc')
      'xabc'
    """

def index_of(val, seq, start=0):
    """
      >>> index_of(9, [1, 7, 11, 9, 10])
      3
      >>> index_of(5, (1, 2, 4, 5, 6, 10, 5, 5))
      3
      >>> index_of(5, (1, 2, 4, 5, 6, 10, 5, 5), 4)
      6
      >>> index_of('y', 'happy birthday')
      4
      >>> index_of('banana', ['apple', 'banana', 'cherry', 'date'])
      1
      >>> index_of(5, [2, 3, 4])
      -1
      >>> index_of('b', ['apple', 'banana', 'cherry', 'date'])
      -1
    """

def remove_at(index, seq):
    """
      >>> remove_at(3, [1, 7, 11, 9, 10])
      [1, 7, 11, 10]
      >>> remove_at(5, (1, 4, 6, 7, 0, 9, 3, 5))
      (1, 4, 6, 7, 0, 3, 5)
      >>> remove_at(2, "Yomrktown")
      'Yorktown'
    """

def remove_val(val, seq):
    """
      >>> remove_val(11, [1, 7, 11, 9, 10])
      [1, 7, 9, 10]
      >>> remove_val(15, (1, 15, 11, 4, 9))
      (1, 11, 4, 9)
      >>> remove_val('what', ('who', 'what', 'when', 'where', 'why', 'how'))
      ('who', 'when', 'where', 'why', 'how')
    """

def remove_all(val, seq):
    """
      >>> remove_all(11, [1, 7, 11, 9, 11, 10, 2, 11])
      [1, 7, 9, 10, 2]
      >>> remove_all('i', 'Mississippi')
      'Msssspp'
    """

def count(val, seq):
    """
      >>> count(5, (1, 5, 3, 7, 5, 8, 5))
      3
      >>> count('s', 'Mississippi')
      4
      >>> count((1, 2), [1, 5, (1, 2), 7, (1, 2), 8, 5])
      2
    """

def reverse(seq):
    """
      >>> reverse([1, 2, 3, 4, 5])
      [5, 4, 3, 2, 1]
      >>> reverse(('shoe', 'my', 'buckle', 2, 1))
      (1, 2, 'buckle', 'my', 'shoe')
      >>> reverse('Python')
      'nohtyP'
    """

def sort_sequence(seq):
    """
      >>> sort_sequence([3, 4, 6, 7, 8, 2])
      [2, 3, 4, 6, 7, 8]
      >>> sort_sequence((3, 4, 6, 7, 8, 2))
      (2, 3, 4, 6, 7, 8)
      >>> sort_sequence("nothappy")
      'ahnoppty'
    """

if __name__ == "__main__":
    import doctest
    doctest.testmod()
</pre>
As usual, work on each of these one at a time until they pass all of the
doctests.
</div></li>

<li><div class="exercise">
Write a function, <code>recursive_min</code>, that returns the smallest value
in a nested number list:
<pre class="python">
def recursive_min(nested_num_list):
    """
      >>> recursive_min([2, 9, [1, 13], 8, 6])
      1
      >>> recursive_min([2, [[100, 1], 90], [10, 13], 8, 6])
      1
      >>> recursive_min([2, [[13, -7], 90], [1, 100], 8, 6])
      -7
      >>> recursive_min([[[-13, 7], 90], 2, [1, 100], 8, 6])
      -13
    """
</pre>
Your function should pass the doctests.
</div></li>

<li><div class="exercise">
Write a function <code>recursive_count</code> that returns the number of
occurances of <code>target</code> in <code>nested_number_list</code>: 
<pre class="python">
def recursive_count(target, nested_num_list):
    """
      >>> recursive_count(2, [2, 9, [2, 1, 13, 2], 8, [2, 6]])
      4
      >>> recursive_count(7, [[9, [7, 1, 13, 2], 8], [7, 6]])
      2
      >>> recursive_count(15, [[9, [7, 1, 13, 2], 8], [2, 6]])
      0
      >>> recursive_count(5, [[5, [5, [1, 5], 5], 5], [5, 6]])
      6
    """
</pre>
As usual, your function should pass the doctests.
</div></li>

<li><div class="exercise">
Write a function <code>flatten</code> that returns a simple list of numbers
containing all the values in a <code>nested_number_list</code>: 
<pre class="python">
def flatten(nested_num_list):
    """
      >>> flatten([2, 9, [2, 1, 13, 2], 8, [2, 6]])
      [2, 9, 2, 1, 13, 2, 8, 2, 6]
      >>> flatten([[9, [7, 1, 13, 2], 8], [7, 6]])
      [9, 7, 1, 13, 2, 8, 7, 6]
      >>> flatten([[9, [7, 1, 13, 2], 8], [2, 6]])
      [9, 7, 1, 13, 2, 8, 2, 6]
      >>> flatten([[5, [5, [1, 5], 5], 5], [5, 6]])
      [5, 5, 1, 5, 5, 5, 5, 6]
    """
</pre>
Run your function to confirm that the doctests pass.
</div></li>

<li><div class="exercise">
Write a function that uses <code>input_number</code> to input a number from the 
keyboard and that handles the <code>BadNumberError</code> exception.
</div></li>

<li><div class="exercise">
Give the Python interpreter's response to each of the following:
<ol style="list-style-type: lower-alpha">
<li><pre class="python-interpreter">
>>> nums = [1, 2, 3, 4]
>>> [x**3 for x in nums]
</pre></li>

<li><pre class="python-interpreter">
>>> nums = [1, 2, 3, 4]
>>> [x**2 for x in nums if x**2 != 4]
</pre></li>

<li><pre class="python-interpreter">
>>> nums = [1, 2, 3, 4]
>>> [(x, y) for x in nums for y in nums]
</pre></li>

<li><pre class="python-interpreter">
>>> nums = [1, 2, 3, 4]
>>> [(x, y) for x in nums for y in nums if x != y]
</pre></li>
</ol>
You should anticipate the results <em>before</em> you try them in the
interpreter.
</div></li>

</ol>

</body>
</html>
