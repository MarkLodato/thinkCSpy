<html>
<head>
  <title>Stacks</title>
</head>
<body>

<h1>Stacks</h1>


<h2>Abstract data types</h2>
<span class="index" value="abstract data type" />
<span class="index" value="ADT" />
<span class="index" value="encapsulation" />

<p>The data types you have seen so far are all concrete, in the sense that we
have completely specified how they are implemented.  For example, the
<code>Card</code> class represents a card using two integers.  As we discussed
at the time, that is not the only way to represent a card; there are many
alternative implementations.</p>

<p>An <b>abstract data type</b>, or ADT, specifies a set of
operations (or methods) and the semantics of the operations (what they do), but 
it does not not specify the implementation of the operations.  That's what
makes it abstract.</p>

<p>Why is that useful?</p>

<ol>
<li>It simplifies the task of specifying an algorithm if you can denote the
operations you need without having to think at the same time about how the
operations are performed.</li>

<li>Since there are usually many ways to implement an ADT, it might be useful
to write an algorithm that can be used with any of the possible
implementations.</li>

<li>Well-known ADTs, such as the Stack ADT in this chapter, are often
implemented in standard libraries so they can be written once and used by many
programmers.</li>

<li>The operations on ADTs provide a common high-level language for specifying
and talking about algorithms.</li>
</ol>

<p>When we talk about ADTs, we often distinguish the code that uses the ADT,
called the <b>client</b> code, from the code that implements the ADT, 
called the <b>provider</b> code.</p>

<span class="index" value="client" />
<span class="index" value="provider" />


<h2>The Stack ADT</h2>
<span class="index" value="stack" />
<span class="index" value="collection" />
<span class="index" value="ADT!Stack" />

<p>In this chapter, we will look at one common ADT, the <b>stack</b>. 
A stack is a collection, meaning that it is a data structure that contains
multiple elements.  Other collections we have seen include dictionaries and
lists.</p>

<span class="index" value="interface" />

<p>An ADT is defined by the operations that can be performed on it, which is
called an <b>interface</b>.  The interface for a stack consists of
these operations:</p>

<dl>
<dt><code>__init__</code>:</dt>
<dd>Initialize a new empty stack.</dd>

<dt><code>push</code>:</dt>
<dd>Add a new item to the stack.</dd>

<dt><code>pop</code>:</dt>
<dd>Remove and return an item from the stack.  The item that is returned is
always the last one that was added.</dd>

<dt><code>isEmpty</code>:</dt>
<dd>Check whether the stack is empty.</dd>
</dl>

<p>A stack is sometimes called a <q>last in, first out</q> or LIFO data
structure, because the last item added is the first to be removed.</p>


<h2>Implementing stacks with Python lists</h2>
<span class="index" value="Stack" />
<span class="index" value="class!Stack" />
<span class="index" value="generic data structure" />
<span class="index" value="data structure!generic" />

<p>The list operations that Python provides are similar to the operations that
define a stack.  The interface isn't exactly what it is supposed to be, but we
can write code to translate from the Stack ADT to the built-in operations.</p>

<p>This code is called an <b>implementation</b> of the Stack ADT.
In general, an implementation is a set of methods that satisfy the syntactic
and semantic requirements of an interface.</p>

<p>Here is an implementation of the Stack ADT that uses a Python list:</p>

<pre class="python">
class Stack :
    def __init__(self):
        self.items = []
   
    def push(self, item):
        self.items.append(item)
   
    def pop(self):
        return self.items.pop()
   
    def isEmpty(self):
        return (self.items == [])
</pre>

<p>A <code>Stack</code> object contains an attribute named <code>items</code>
that is a list of items in the stack.  The initialization method sets
<code>items</code> to the empty list.</p>

<p>To push a new item onto the stack, <code>push</code> appends it onto
<code>items</code>.  To pop an item off the stack, <code>pop</code> uses the
homonymous (<em>same-named</em>) list method to remove and return the last item 
on the list.</p>

<p>Finally, to check if the stack is empty, <code>isEmpty</code> compares
<code>items</code> to the empty list.</p>

<span class="index" value="veneer" />

<p>An implementation like this, in which the methods consist of simple
invocations of existing methods, is called a <b>veneer</b>.  In real
life, veneer is a thin coating of good quality wood used in furniture-making to 
hide lower quality wood underneath.  Computer scientists use this metaphor to
describe a small piece of code that hides the details of an implementation and
provides a simpler, or more standard, interface.</p>


<h2>Pushing and popping</h2>
<span class="index" value="push" />
<span class="index" value="pop" />
<span class="index" value="generic data structure" />
<span class="index" value="data structure!generic" />

<p>A stack is a <b>generic data structure</b>, which means that we
can add any type of item to it.  The following example pushes two integers and
a string onto the stack:</p>

<pre class="python-interpreter">
>>> s = Stack()
>>> s.push(54)
>>> s.push(45)
>>> s.push("+")
</pre>

<p>We can use <code>isEmpty</code> and <code>pop</code> to remove and print
all of the items on the stack:</p>

<pre class="python">
while not s.isEmpty():
    print s.pop(),
</pre>

<p>The output is <code>+ 45 54</code>.  In other words, we just used a stack
to print the items backward!  Granted, it's not the standard format for
printing a list, but by using a stack, it was remarkably easy to do.</p>

<p>You should compare this bit of code to the implementation of
<code>printBackward</code> in the last chapter.  There is a natural parallel
between the recursive version of <code>printBackward</code> and the stack
algorithm here.  The difference is that <code>printBackward</code> uses the
runtime stack to keep track of the nodes while it traverses the list, and then
prints them on the way back from the recursion.  The stack algorithm does the
same thing, except that is use a <code>Stack</code> object instead of the
runtime stack.</p>


<h2>Using a stack to evaluate postfix</h2>
<span class="index" value="postfix" />
<span class="index" value="infix" />
<span class="index" value="expression" />

<p>In most programming languages, mathematical expressions are written with the 
operator between the two operands, as in <code>1+2</code>.  This format is
called <b>infix</b>.  An alternative used by some calculators is
called <b>postfix</b>.  In postfix, the operator follows the operands,
as in <code>1 2 +</code>.</p>

<p>The reason postfix is sometimes useful is that there is a natural way to
evaluate a postfix expression using a stack:</p>

<ol>
<li>Starting at the beginning of the expression, get one term (operator or
operand) at a time.
  <ol>
  <li>If the term is an operand, push it on the stack.</li>

  <li>If the term is an operator, pop two operands off the stack, perform the
  operation on them, and push the result back on the stack.</li>
  </ol>
</li>

<li>When you get to the end of the expression, there should be exactly one
operand left on the stack.  That operand is the result.</li>
</ol>


<h2>Parsing</h2>
<span class="index" value="parse" />
<span class="index" value="token" />
<span class="index" value="delimiter" />
<span class="index" value="regular expression" />

<p>To implement the previous algorithm, we need to be able to traverse a string 
and break it into operands and operators.  This process is an example of
<b>parsing</b>, and the results---the individual chunks of the
string---are called <b>tokens</b>.  You might remember these words
from Chapter 1.</p>

<p>Python provides a <code>split</code> method in both the <code>string</code>
and <code>re</code> (regular expression) modules. The function
<code>string.split</code> splits a string into a list using a single character
as a <b>delimiter</b>.  For example:</p>

<pre class="python-interpreter">
>>> import string
>>> string.split("Now is the time"," ")
['Now', 'is', 'the', 'time']
</pre>

<p>In this case, the delimiter is the space character, so the string is split
at each space.</p>

<p>The function <code>re.split</code> is more powerful, allowing us to provide
a regular expression instead of a delimiter.  A regular expression is a way of
specifying a set of strings.  For example, <code>[A-z]</code> is the set of all 
letters and <code>[0-9]</code> is the set of all numbers.  The
<code>^</code> operator negates a set, so <code>[^0-9]</code> is the set of
everything that is not a number, which is exactly the set we want to use to
split up postfix expressions:</p>

<pre class="python-interpreter">
>>> import re
>>> re.split("([^0-9])", "123+456*/")
['123', '+', '456', '*', '', '/', '']
</pre>

<p>Notice that the order of the arguments is different from
<code>string.split</code>; the delimiter comes before the string.</p>

<p>The resulting list includes the operands <code>123</code> and
<code>456</code> and the operators <code>*</code> and <code>/</code>.  It also
includes two empty strings that are inserted after the operands.</p>


<h2>Evaluating postfix</h2>

<p>To evaluate a postfix expression, we will use the parser from the previous
section and the algorithm from the section before that.  To keep things simple, 
we'll start with an evaluator that only implements the operators <code>+</code> 
and <code>*</code>:</p>

<pre class="python">
def evalPostfix(expr):
    import re
    tokenList = re.split("([^0-9])", expr)
    stack = Stack()
    for token in tokenList:
        if  token == '' or token == ' ':
            continue
        if  token == '+':
            sum = stack.pop() + stack.pop()
            stack.push(sum)
        elif token == '*':
            product = stack.pop() * stack.pop()
            stack.push(product)
        else:
            stack.push(int(token))
    return stack.pop()
</pre>

<p>The first condition takes care of spaces and empty strings.  The next two
conditions handle operators. We assume, for now, that anything else must be an
operand.  Of course, it would be better to check for erroneous input and report 
an error message, but we'll get to that later.</p>

<p>Let's test it by evaluating the postfix form of <code>(56+47)*2</code>:</p>

<pre class="python-interpreter">
>>> print evalPostfix ("56 47 + 2 *")
206
</pre>

<p>That's close enough.</p>


<h2>Clients and providers</h2>
<span class="index" value="encapsulation" />
<span class="index" value="ADT" />

<p>One of the fundamental goals of an ADT is to separate the interests of the
provider, who writes the code that implements the ADT, and the client, who uses 
the ADT.  The provider only has to worry about whether the implementation is
correct---in accord with the specification of the ADT---and not how it will be
used.</p>

<p>Conversely, the client <em>assumes</em> that the implementation of the ADT
is correct and doesn't worry about the details.  When you are using one of
Python's built-in types, you have the luxury of thinking exclusively as a
client.</p>

<p>Of course, when you implement an ADT, you also have to write client code to
test it.  In that case, you play both roles, which can be confusing.  You
should make some effort to keep track of which role you are playing at any
moment.</p>


<h2>Glossary</h2>
<span class="index" value="ADT" />
<span class="index" value="client" />
<span class="index" value="provider" />
<span class="index" value="infix" />
<span class="index" value="postfix" />
<span class="index" value="parse" />
<span class="index" value="token" />
<span class="index" value="delimiter" />

<dl>
<dt>abstract data type (ADT):</dt>
<dd>A data type (usually a collection of objects) that is defined by a set of
operations but that can be implemented in a variety of ways.</dd>

<dt>interface:</dt>
<dd>The set of operations that define an ADT.</dd>

<dt>implementation:</dt>
<dd>Code that satisfies the syntactic and semantic requirements of an
interface.</dd>

<dt>client:</dt>
<dd>A program (or the person who wrote it) that uses an ADT.</dd>

<dt>provider:</dt>
<dd>The code (or the person who wrote it) that implements an ADT.</dd>

<dt>veneer:</dt>
<dd>A class definition that implements an ADT with method definitions that are
invocations of other methods, sometimes with simple transformations.  The
veneer does no significant work, but it improves or standardizes the interface
seen by the client.</dd>

<dt>generic data structure:</dt>
<dd>A kind of data structure that can contain data of any type.</dd>

<dt>infix:</dt>
<dd>A way of writing mathematical expressions with the operators between the
operands.</dd>

<dt>postfix:</dt>
<dd>A way of writing mathematical expressions with the operators after the
operands.</dd>

<dt>parse:</dt>
<dd>To read a string of characters or tokens and analyze its grammatical
structure.</dd>

<dt>token:</dt>
<dd>A set of characters that are treated as a unit for purposes of parsing,
such as the words in a natural language.</dd>

<dt>delimiter:</dt>
<dd>A character that is used to separate tokens, such as punctuation in a
natural language.</dd>
</dl>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
<p>Apply the postfix algorithm to the expression <code>1 2 + 3 *</code>.</p>

<p>This example demonstrates one of the advantages of postfix---there is no
need to use parentheses to control the order of operations.  To get the same
result in infix, we would have to write <code>(1 + 2) * 3</code>.</p>
</div></li>

<li><div class="exercise">
Write a postfix expression that is equivalent to <code>1 + 2 * 3</code>.
</div></li>
</ol>


</body>
</html>
