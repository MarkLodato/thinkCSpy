<html>
<head>
  <title>Strings</title>
</head>
<body>

<h1>Strings</h1>
<a name="strings" />

<h2>A compound data type</h2>
<span class="index" value="compound data type" />
<span class="index" value="data type!compound" />

<p>So far we have seen five types: <code>int</code>, <code>float</code>, 
<code>bool</code>, <code>NoneType</code> and <code>str</code>.  Strings are
qualitatively different from the other four because they are made up of smaller 
pieces---characters.</p>

<span class="index" value="character" />

<p>Types that comprise smaller pieces are called <b>compound data
types</b>.  Depending on what we are doing, we may want to treat a
compound data type as a single thing, or we may want to access its parts. This
ambiguity is useful.</p>

<span class="index" value="bracket operator" />
<span class="index" value="operator!bracket" />

<p>The bracket operator selects a single character from a string:</p>

<pre class="python-interpreter">
>>> fruit = "banana"
>>> letter = fruit[1]
>>> print letter
</pre>

<p>The expression <code>fruit[1]</code> selects character number 1 from
<code>fruit</code>.  The variable <code>letter</code> refers to the result.
When we display <code>letter</code>, we get a surprise:</p>

<pre class="python-interpreter">
a
</pre>

<p>The first letter of <code>"banana"</code> is not <code>a</code>, unless you 
are a computer scientist.  For perverse reasons, computer scientists always
start counting from zero.  The 0th letter (<q>zero-eth</q>) of
<code>"banana"</code> is <code>b</code>.  The 1th letter (<q>one-eth</q>) is
<code>a</code>, and the 2th (<q>two-eth</q>) letter is <code>n</code>.</p>

<p>If you want the zero-eth letter of a string, you just put 0, or any
expression with the value 0, in the brackets:</p>

<pre class="python-interpreter">
>>> letter = fruit[0]
>>> print letter
b
</pre>

<p>The expression in brackets is called an <b>index</b>.  An index
specifies a member of an ordered set, in this case the set of characters in the 
string.  The index <em>indicates</em> which one you want, hence the name.  It
can be any integer expression.</p>

<span class="index" value="index" />


<h2>Length</h2>
<span class="index" value="string!length" />
<span class="index" value="runtime error" />

<p>The <code>len</code> function returns the number of characters in a string:
</p>

<pre class="python-interpreter">
>>> fruit = "banana"
>>> len(fruit)
6
</pre>

<p>To get the last letter of a string, you might be tempted to try something
like this:</p>

<pre class="python">
length = len(fruit)
last = fruit[length]       # ERROR!
</pre>

<p>That won't work. It causes the runtime error
<code class="shell">IndexError: string index out of range</code>.  The reason
is that there is no 6th letter in <code>"banana"</code>.  Since we started
counting at zero, the six letters are numbered 0 to 5.  To get the last
character, we have to subtract 1 from <code>length</code>:</p>

<span class="index" value="runtime error" />

<pre class="python">
length = len(fruit)
last = fruit[length-1]
</pre>

<p>Alternatively, we can use negative indices, which count backward from the
end of the string.  The expression <code>fruit[-1]</code> yields the last
letter, <code>fruit[-2]</code> yields the second to last, and so on.</p>

<span class="index" value="index!negative" />


<h2>Traversal and the <code>for</code> loop</h2>
<a name="for" />
<span class="index" value="traversal" />
<span class="index" value="loop!traversal" />
<span class="index" value="for loop" />
<span class="index" value="loop!for loop" />

<p>A lot of computations involve processing a string one character at a time.
Often they start at the beginning, select each character in turn, do something
to it, and continue until the end.  This pattern of processing is called a
<b>traversal</b>.  One way to encode a traversal is with a
<code>while</code> statement:</p>

<pre class="python">
index = 0
while index &lt; len(fruit):
    letter = fruit[index]
    print letter
    index = index + 1
</pre>

<p>This loop traverses the string and displays each letter on a line by itself. 
The loop condition is <code>index &lt; len(fruit)</code>, so when
<code>index</code> is equal to the length of the string, the condition is false,
and the body of the loop is not executed.  The last character accessed is the
one with the index <code>len(fruit)-1</code>, which is the last character in
the string.</p>

<p>Using an index to traverse a set of values is so common that Python provides 
an alternative, simpler syntax---the <code>for</code> loop:</p>

<pre class="python">
for char in fruit:
    print char
</pre>

<p>Each time through the loop, the next character in the string is assigned
to the variable <code>char</code>.  The loop continues until no characters are
left.</p>

<span class="index" value="concatenation" />
<span class="index" value="abecedarian" />
<span class="index" value="McCloskey, Robert" />
<span class="index" value="<em>Make Way for Ducklings</em>" />

<p>The following example shows how to use concatenation and a <code>for</code>
loop to generate an abecedarian series.  <q>Abecedarian</q> refers to a series
or list in which the elements appear in alphabetical order.  For example, in
Robert McCloskey's book <em>Make Way for Ducklings</em>, the names of the
ducklings are Jack, Kack, Lack, Mack, Nack, Ouack, Pack, and Quack.  This loop
outputs these names in order:</p>

<pre class="python">
prefixes = "JKLMNOPQ"
suffix = "ack"
   
for letter in prefixes:
    print letter + suffix
</pre>

<p>The output of this program is:</p>

<pre class="shell">
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
</pre>

<p>Of course, that's not quite right because <q>Ouack</q> and <q>Quack</q> are
misspelled.  You'll fix this as an exercise below.</p>


<h2>String slices</h2>
<a name="slice" />
<span class="index" value="slice" />
<span class="index" value="string!slice" />

<p>A substring of a string is called a <b>slice</b>.  Selecting a
slice is similar to selecting a character:</p>

<pre class="python-interpreter">
>>> s = "Peter, Paul, and Mary"
>>> print s[0:5]
Peter
>>> print s[7:11]
Paul
>>> print s[17:21]
Mary
</pre>

<p>The operator <code>[n:m]</code> returns the part of the string from the
<q>n-eth</q> character to the <q>m-eth</q> character, including the first but
excluding the last.  This behavior is counterintuitive; it makes more sense if
you imagine the indices pointing <em>between</em> the characters, as in the
following diagram:</p>

<img src="illustrations/banana.png" />

<p>If you omit the first index (before the colon), the slice starts at the
beginning of the string.  If you omit the second index, the slice goes to the
end of the string.  Thus:</p>

<pre class="python-interpreter">
>>> fruit = "banana"
>>> fruit[:3]
'ban'
>>> fruit[3:]
'ana'
</pre>

<p>What do you think <code>s[:]</code> means?</p>


<h2>String comparison</h2>
<span class="index" value="string comparison" />
<span class="index" value="comparison!string" />

<p>The comparison operators work on strings.  To see if two strings are equal:
</p>

<pre class="python">
if word == "banana":
    print  "Yes, we have no bananas!"
</pre>

<p>Other comparison operations are useful for putting words in alphabetical
order:</p>

<pre class="python">
if word &lt; "banana":
    print "Your word," + word + ", comes before banana."
elif word &gt; "banana":
    print "Your word," + word + ", comes after banana."
else:
    print "Yes, we have no bananas!"
</pre>

<p>You should be aware, though, that Python does not handle upper- and
lowercase letters the same way that people do.  All the uppercase letters come
before all the lowercase letters.  As a result:</p>

<pre class="shell">
Your word, Zebra, comes before banana.
</pre>

<p>A common way to address this problem is to convert strings to a standard
format, such as all lowercase, before performing the comparison.  A more
difficult problem is making the program realize that zebras are not fruit.</p>


<h2>Strings are immutable</h2>
<span class="index" value="mutable" />
<span class="index" value="immutable string" />
<span class="index" value="string!immutable" />

<p>It is tempting to use the <code>[]</code> operator on the left side of an
assignment, with the intention of changing a character in a string.  For
example:</p>

<pre class="python">
greeting = "Hello, world!"
greeting[0] = 'J'            # ERROR!
print greeting
</pre>

<p>Instead of producing the output <code>Jello, world!</code>, this code
produces the runtime error <code class="shell">TypeError: 'str' object doesn't
support item assignment</code>.
</p>

<span class="index" value="runtime error" />

<p>Strings are <b>immutable</b>, which means you can't change an
existing string.  The best you can do is create a new string that is a
variation on the original:</p>

<pre class="python">
greeting = "Hello, world!"
newGreeting = 'J' + greeting[1:]
print newGreeting
</pre>

<p>The solution here is to concatenate a new first letter onto a slice of
<code>greeting</code>.  This operation has no effect on the original string.
</p>

<span class="index" value="concatenation" />


<h2>The <code>in</code> operator</h2>
<span class="index" value="in" />
<span class="index" value="operator!in" />

<p>
The <code>in</code> operator tests if one string is a substring of another:
</p>
<pre class="python-interpreter">
>>> 'p' in 'apple'
True
>>> 'i' in 'apple'
False
>>> 'ap' in 'apple'
True
>>> 'pa' in 'apple'
False
</pre>

<p>Note that a string is a substring of itself:</p>

<pre class="python-interpreter">
>>> 'a' in 'a'
True
>>> 'apple' in 'apple'
True
</pre>

<p>Combining the <code>in</code> operator with sting concatination using
<code>+</code>, we can write a function that removes all the vowels from
a string:</p>

<pre class='python'>
def remove_vowels(s):
    vowels = "aeiouAEIOU"
    s_without_vowels = ""
    for letter in s:
        if letter not in vowels:
            s_without_vowels = s_without_vowels + letter
    return s_without_vowels 
</pre>

<p>Test this function to confirm that it does what we wanted it to do.</p> 


<h2>A <code>find</code> function</h2>
<a name="find" />
<span class="index" value="traversal" />
<span class="index" value="eureka traversal" />
<span class="index" value="pattern" />
<span class="index" value="computational pattern" />

<p>What does the following function do?</p>

<pre class="python">
def find(strng, ch):
    index = 0
    while index &lt; len(strng):
        if strng[index] == ch:
            return index
        index = index + 1
    return -1
</pre>

<p>In a sense, <code>find</code> is the opposite of the <code>[]</code>
operator.  Instead of taking an index and extracting the corresponding
character, it takes a character and finds the index where that character
appears.  If the character is not found, the function returns
<code>-1</code>.</p>

<p>This is the first example we have seen of a <code>return</code> statement
inside a loop.  If <code>strng[index] == ch</code>, the function returns
immediately, breaking out of the loop prematurely.</p>

<p>If the character doesn't appear in the string, then the program exits the
loop normally and returns <code>-1</code>.</p>

<p>This pattern of computation is sometimes called a <q>eureka</q> traversal
because as soon as we find what we are looking for, we can cry <q>Eureka!</q>
and stop looking.</p>


<h2>Looping and counting</h2>
<a name="counter" />
<span class="index" value="counter" />
<span class="index" value="pattern" />

<p>The following program counts the number of times the letter <code>a</code>
appears in a string, and is another example of the counter pattern introduced
in chapter 6:</p>

<pre class="python">
fruit = "banana"
count = 0
for char in fruit:
    if char == 'a':
        count += 1
print count
</pre>



<h2>Optional paramters</h2>
<span class="index" value="optional parameter" />
<span class="index" value="parameter!optional" />
<span class="index" value="default value" />

<p>To find the locations of the second or third occurance of a character in a
string, we can modify the <code>find</code> function, adding a third parameter
for the starting postion in the search string:</p>

<pre class="python">
def find2(strng, ch, start):
    index = start 
    while index &lt; len(strng):
        if strng[index] == ch:
            return index
        index = index + 1
    return -1
</pre>

<p>The call <code>find2('banana', 'a', 2)</code> now returns <code>3</code>,
the index of the second 'a' in 'banana'.</p>

<p>Better still, we can combine <code>find</code> and <code>find2</code> using
an <b>optional parameter</b>:</p>

<pre class="python">
def find(strng, ch, start=0):
    index = start 
    while index &lt; len(strng):
        if strng[index] == ch:
            return index
        index = index + 1
    return -1
</pre>

<p>The call <code>find('banana', 'a', 2)</code> to this version of
<code>find</code> behaves just like <code>find2</code>, while in the call
<code>find('banana', 'a')</code>, <code>start</code> will be set to the
<b>default value</b> of <code>0</code>.</p>

<p>Adding another optional parameter to <code>find</code> makes it search both
forward and backward:</p>

<pre class="python">
def find(strng, ch, start=0, step=1):
    index = start 
    while 0 &lt;= index &lt; len(strng):
        if strng[index] == ch:
            return index
        index = index + step 
    return -1
</pre>

<p>Passing in a value of <code>-1</code> for <code>step</code> will make
it search toward the beginning of the string instead of the end.  Note that we
needed to check for a lower bound for <code>index</code> in the while loop as
well as an upper bound to accomodate this change.</p>


<h2>The <code>string</code> module</h2>
<span class="index" value="module" />
<span class="index" value="string module" />
<span class="index" value="dot notation" />
<span class="index" value="type function" />
<span class="index" value="doc string" />

<p>The <code>string</code> module contains useful functions that manipulate
strings.  In recent versions of Python the 
As usual, we have to import the module before we can use it:</p>

<pre class="python-interpreter">
>>> import string
</pre>

<p>To see what is inside it, use the <code>dir</code> function with the module
name as an argument.</p>

<pre class="python-interpreter">
>>> dir(string)
</pre>

<p>which will return the list of items inside the string module:
<br /><br /><code>
['Template', '_TemplateMetaclass', '__builtins__', '__doc__', '__file__',
'__name__', '_float', '_idmap', '_idmapL', '_int', '_long', '_multimap',
'_re', 'ascii_letters', 'ascii_lowercase', 'ascii_uppercase', 'atof',
'atof_error', 'atoi', 'atoi_error', 'atol', 'atol_error', 'capitalize',
'capwords', 'center', 'count', 'digits', 'expandtabs', 'find', 'hexdigits',
'index', 'index_error', 'join', 'joinfields', 'letters', 'ljust', 'lower',
'lowercase', 'lstrip', 'maketrans', 'octdigits', 'printable', 'punctuation',
'replace', 'rfind', 'rindex', 'rjust', 'rsplit', 'rstrip', 'split',
'splitfields', 'strip', 'swapcase', 'translate', 'upper', 'uppercase',
'whitespace', 'zfill']
</code></p>

<p>To find out more about an item in this list, we can use the
<code>type</code> command.  We need to specify the module name followed by the 
item using <b>dot notation</b>.</p>

<pre class="python-interpreter">
>>> type(string.digits)
&lt;type 'str'&gt;
>>> type(string.find)
&lt;type 'function'&gt;
</pre>

<p>Since <code>string.digits</code> is a string, we can print it to see what
it contains:</p>

<pre class="python-interpreter">
>>> print string.digits
0123456789
</pre>

<p>Not surprisingly, it contains each of the decimal digits.</p>

<p><code>string.find</code> is a function which does much the same thing as the 
function we wrote.  To find out more about it, we can print out its
<b>docstring</b>, <code>__doc__</code>, which contains documentation on the
function:</p>

<pre class="python-interpreter">
>>> print string.find.__doc__
find(s, sub [,start [,end]]) -> in

    Return the lowest index in s where substring sub is found,
    such that sub is contained within s[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.

</pre>

<p>The parameters in square brackets are optional parameters.  We can use
<code>string.find</code> much as we did our own <code>find</code>:</p>

<pre class="python-interpreter">
>>> fruit = "banana"
>>> index = string.find(fruit, "a")
>>> print index
1
</pre>

<p>This example demonstrates one of the benefits of modules---they help
avoid collisions between the names of built-in functions and user-defined
functions.  By using dot notation we can specify which version of
<code>find</code> we want.</p>

<p>Actually, <code>string.find</code> is more general than our version.
it can find substrings, not just characters:</p>

<pre class="python-interpreter">
>>> string.find("banana", "na")
2
</pre>

<p>Like ours, it takes an additional argument that specifies the index at
which it should start:</p>

<pre class="python-interpreter">
>>> string.find("banana", "na", 3)
4
</pre>

<p>Unlike ours, its second optional parameter specifies the index at which
the search should end:</p>

<pre class="python-interpreter">
>>> string.find("bob", "b", 1, 2)
-1
</pre>

<p>In this example, the search fails because the letter <em>b</em> does not
appear in the index range from <code>1</code> to <code>2</code> (not including
<code>2</code>).</p>


<h2>Character classification</h2>
<a name="in" />
<span class="index" value="character classification" />
<span class="index" value="classification!character" />
<span class="index" value="uppercase" />
<span class="index" value="lowercase" />
<span class="index" value="dot notation" />
<span class="index" value="whitespace" />

<p>It is often helpful to examine a character and test whether it is upper- or
lowercase, or whether it is a character or a digit.  The <code>string</code>
module provides several constants that are useful for these purposes.  One
of these, <code>string.digits</code>, we have already seen.</p>

<p>The string <code>string.lowercase</code> contains all of the letters that
the system considers to be lowercase.  Similarly, <code>string.uppercase</code>
contains all of the uppercase letters.  Try the following and see what you get:
</p>

<pre class="python">
print string.lowercase
print string.uppercase
print string.digits
</pre>

<p>We can use these constants and <code>find</code> to classify characters. For
example, if <code>find(lowercase, ch)</code> returns a value other than
<code>-1</code>, then <code>ch</code> must be lowercase:</p>

<pre class="python">
def is_lower(ch):
    return string.find(string.lowercase, ch) != -1
</pre>

<p>Alternatively, we can take advantage of the <code>in</code> operator:</p>

<pre class="python">
def is_lower(ch):
    return ch in string.lowercase
</pre>

<p>As yet another alternative, we can use the comparison operator:</p>

<pre class="python">
def is_lower(ch):
    return 'a' &lt;= ch &lt;= 'z'
</pre>

<p>If <code>ch</code> is between <em>a</em> and <em>z</em>, it must be a
lowercase letter.</p>

<p>Another constant defined in the <code>string</code> module may surprise you
when you print it:</p>

<pre class="python-interpreter">
>>> print string.whitespace
</pre>

<p><b>Whitespace</b> characters move the cursor without printing
anything.  They create the white space between visible characters (at least on
white paper).  The constant <code>string.whitespace</code> contains all the
whitespace characters, including space, tab (\t), and newline (\n).</p>

<span class="index" value="string module" />
<span class="index" value="module!string" />

<p>There are other useful functions in the <code>string</code> module, but this
book isn't intended to be a reference manual.  On the other hand, the
<em>Python Library Reference</em> is.  Along with a wealth of other
documentation, it's available from the Python website, 
<a href="http://www.python.org">http://www.python.org</a>.</p>

<span class="index" value="Python Library Reference" />

<h2>Glossary</h2>
<span class="index" value="compound data type" />
<span class="index" value="traverse" />
<span class="index" value="index" />
<span class="index" value="slice" />
<span class="index" value="mutable" />
<span class="index" value="optional parameter" />
<span class="index" value="default value" />
<span class="index" value="dot notation" />
<span class="index" value="dot operator" />
<span class="index" value="whitespace" />

<dl>
<dt>compound data type:</dt>
<dd>A data type in which the values are made up of components, or elements,
that are themselves values.</dd>

<dt>traverse:</dt>
<dd>To iterate through the elements of a set, performing a similar operation on 
each.</dd>

<dt>index:</dt>
<dd>A variable or value used to select a member of an ordered set, such as a
character from a string.</dd>

<dt>slice:</dt>
<dd>A part of a string specified by a range of indices.</dd>

<dt>mutable:</dt>
<dd>A compound data types whose elements can be assigned new values.</dd>

<dt>optional parameter:</dt>
<dd>A parameter written in a function header with an assignment to a default
value which it will receive if no corresponding argument is given for it in
the function call.</dd>

<dt>default value:</dt>
<dd>The value given to an optional parameter if no argument for it is provided
in the function call.</dd>

<dt>dot notation</dt>
<dd>Use of the <b>dot operator</b>, <code>.</code>, to access functions inside
a module.</dd>

<dt>whitespace:</dt>
<dd>Any of the characters that move the cursor without printing visible
characters.  The constant <code>string.whitespace</code> contains all the
white-space characters.</dd>
</dl>


<h2>Exercises</h2>

<ol>
<li><div class="exercise">
Modify:
<pre class="python">
prefixes = "JKLMNOPQ"
suffix = "ack"
   
for letter in prefixes:
    print letter + suffix
</pre>
so that <code>Ouack</code> and <code>Quack</code> are spelled correctly.
</div></li>

<li><div class="exercise">
Encapsulate
<pre class="python">
fruit = "banana"
count = 0
for char in fruit:
    if char == 'a':
        count += 1
print count
</pre>
in a function named <code>count_letters</code>, and generalize it so that it
accepts the string and the letter as arguments.
</div></li>

<li><div class="exercise">
Now rewrite the <code>count_letters</code> function so that instead of
traversing the string, it repeatedly calls <code>find</code>, with the optional 
third parameter to locate new occurences of the letter being counted.
</div></li>

<li><div class="exercise">
Which version of <code>is_lower</code> do you think will be fastest?  Can you
think of other reasons besides speed to prefer one version or the other?
</div></li>

<li><div class="exercise">
Create a file named <code>string_tools.py</code> and put the following in
it:
<pre class='python'>
def reverse(s):
    """
      >>> reverse('happy')
      'yppah' 
      >>> reverse('Python')
      'nohtyP' 
      >>> reverse("")
      '' 
      >>> reverse("P")
      'p' 
    """

if __name__ == '__main__':
    import doctest
    doctest.testmod()
</pre>
Add a function body to <code>reverse</code> to make the doctests pass.
</div></li>

<li><div class="exercise">
Add <code>mirror</code> to <code>string_tools.py</code> .
<pre class='python'>
def mirror(s):
    """
      >>> mirror("good")
      'gooddoog'
      >>> mirror("yes")
      'yessey'
      >>> mirror('Python')
      'PythonnohtyP'
      >>> mirror("")
      ''
      >>> mirror("a")
      'aa'
    """
</pre>
Write a function body for it that will make it work as indicated by the
doctests.
</div></li>

<li><div class="exercise">
Include <code>remove_letter</code> in <code>string_tools.py</code> .
<pre class='python'>
def remove_letter(letter, strng):
    """
      >>> remove_letter('a', 'apple')
      'pple'
      >>> remove_letter('a', 'banana')
      'bnn'
      >>> remove_letter('z', 'banana')
      'banana'
      >>> remove_letter('i', 'Mississippi')
      'Msssspp'
    """
</pre>
Write a function body for it that will make it work as indicated by the
doctests.
</div></li>

</ol>

</body>
</html>
