<html>
<head>
  <title>Case Study: Catch</title>
</head>
<body>

<h1>Case Study: Catch</h1>

<h2>Getting Started</h2>

<p>In our first case study we will build a small video game using the
facilities in the GASP package.  The game will shoot a ball across a window
from left to right and you will manipulate a <q>mitt</q> at the right side of
the window to catch it.</p>


<h2>Using <code>while</code> to move a ball</h2>

<p><code>while</code> statements can be used with <code>gasp</code> to add
motion to a program.  The following program moves a black ball across an
800 x 600 pixel graphics canvas.  Add this to a file named
<code>pitch.py</code>:</p>

<pre class='python'>
from gasp import *

begin_graphics(800, 600, title="Catch", background=color.yellow)

ball_x = 10
ball_y = 300
ball = Circle((ball_x, ball_y), 10, filled=True)
dx = 4
dy = 1

while ball_x &lt; 810:
    ball_x += dx
    ball_y += dy
    move_to(ball, (ball_x, ball_y))
    sleep(0.01)

end_graphics()
</pre>

<p>As the ball moves across the screen, you will see a graphics window that
looks like this:</p>

<img src="illustrations/gasp03.png" />

<p>Trace the first few iterations of this program to be sure you see what is
happening to the variables <code>x</code> and <code>y</code>.</p>

<p>Some new things to learn about GASP from this example:</p>

<ul>
  <li><code>begin_graphics</code> can take arguments for width, height,
  title, and background color of the graphics canvas.</li>

  <li>Adding <code>filled=True</code> to <code>Circle(...)</code> makes
  the resulting circle solid.</li>

  <li><code>ball = Circle</code> stores the circle (we will talk later
  about what a circle actually is) in a variable named <code>ball</code>
  so that it can be referenced later.</li>

  <li>The <code>move_to</code> function in GASP allows a programmer to
  pass in a shape (the ball in this case) and a location, and moves the
  shape to that location.</li>

  <li>The <code>sleep</code> function takes a time value in seconds as
  an argument and pauses execution of the program for that length of time.
  In general computers do things much to fast to allow you to interact with
  them.  We can slow things down by making the computer sleep a bit at the
  right place.</li>
</ul>


<h2>Varying the pitches</h2>
<span class="index" value="random" />
<span class="index" value="random values" />

<p>To make our game more interesting, we want to be able to vary the speed and
direction of the ball.  GASP has a function,
<code>random_between(low, high)</code>, that returns a <b>random</b> integer
between <code>low</code> and <code>high</code>.  To see how this works,
run the following program:</p>

<pre class="python">
from gasp import *

i = 0
while i &lt; 10:
    print random_between(-5, 5)
    i += 1
</pre>

<p>Each time the function is called a more or less random integer is chosen
between -5 and 5.  When we ran this program we got:</p>

<pre class='shell'>
-2
-1
-4
1
-2
3
-5
-3
4
-5
</pre>

<p>You will probably get a different sequence of numbers.</p>

<p>Let's use <code>random_between</code> to vary the direction of the ball.
Replace the line in <code>pitch.py</code> that assigns <code>1</code>
to <code>y</code>:</p>

<pre class='python'>
dy = 1 
</pre>

<p>with an assignment to a random number between -4 and 4:</p>

<pre class='python'>
dy = random_between(-4, 4) 
</pre>


<h2>Making the ball <q>bounce</q></h2>

<p>Running this new version of the program, you will notice that ball
frequently goes off either the top or bottom edges of the screen before it
completes its journey.  To prevent this, let's make the ball <q>bounce</q>
off the edges by changing the sign of <code>dy</code> and sending the
ball back in the opposite verticle direction.</p>

<p>Add the following as the first line of the body of the while loop in
<code>pitch.py</code>:</p>

<pre class='python'>
if ball_y &gt;= 590 or ball_y &lt;= 10:
    dy *= -1
</pre>

<p>Run the program several times to see how it behaves.</p>


<h2>The <code>break</code> statement</h2>
<span class="index" value="break" />
<span class="index" value="break statement" />

<p>The <b>break</b> statement is used to immediately leave the body of a loop.  
The following program impliments simple simple guessing game:</p>

<pre class='python'>
from gasp import *

number = random_between(1, 1000)
guesses = 1
guess = input("Guess the number between 1 and 1000: ")

while guess != number:
    if guess &gt; number:
        print "Too high!"
    else:
        print "Too low!"
    guess = input("Guess the number between 1 and 1000: ")
    guesses += 1

print "\n\nCongratulations, you got it in %d guesses!\n\n" % guesses
</pre>

<p>Using a <code>break</code> statement, we can rewrite this program to
eliminate the duplication of the <code>input</code> statement:</p>

<pre class='python'>
from gasp import *

number = random_between(1, 1000)
guesses = 0

while True:
    guess = input("Guess the number between 1 and 1000: ")
    guesses += 1
    if guess &gt; number:
        print "Too high!"
    elif guess &lt; number:
        print "Too low!"
    else:
        print "\n\nCongratulations, you got it in %d guesses!\n\n" % guesses
        break
</pre>

<p>This program makes use of the mathematical law of <b>trichotomy</b> (given
real numbers a and b, a &gt; b, a &lt; b, or a = b).  While both versions of
the program are 15 lines long, it could be argued that the logic in the second
version is clearer.</p>

<p>Put this program in a file named <code>guess.py</code>.</p>


<h2>Responding to the keyboard</h2>

<p>The following program creates a circle (or <q>mitt</q>) which responds to
keyboard input.  Pressing the <code>j</code> or <code>k</code> keys moves the
mitt up and down, respectively.  Add this to a file named
<code>mitt.py</code>:</p>

<pre class='python'>
from gasp import *

begin_graphics(800, 600, title="Catch", background=color.yellow)

mitt_x = 780
mitt_y = 300
mitt = Circle((mitt_x, mitt_y), 20)

while True:
    if key_pressed('j') and mitt_y &lt;= 580:
        mitt_y += 5
    elif key_pressed('k') and mitt_y &gt;= 20:
        mitt_y -= 5
    elif key_pressed('escape'):
        break
    move_to(mitt, (mitt_x, mitt_y))
    sleep(0.01)

end_graphics()
</pre>

<p>Run <code>mitt.py</code>, pressing <code>j</code> and <code>k</code> to
move up and down the screen.</p>


<h2>Checking for collisions</h2>

<p>The following program moves two balls toward each other from opposite sides
of the screen.  When they <q>collide</q>, both balls disappear and the program
ends:</p>

<pre class='python'>
from gasp import *

def distance((x1, y1), (x2, y2)):
    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

begin_graphics(800, 600, title="Catch", background=color.yellow)

ball1_x = 10
ball1_y = 300
ball1 = Circle((ball1_x, ball1_y), 10, filled=True)
ball1_dx = 4

ball2_x = 790
ball2_y = 300
ball2 = Circle((ball2_x, ball2_y), 10)
ball2_dx = -4

while ball1_x &lt; 810:
    ball1_x += ball1_dx
    ball2_x += ball2_dx
    move_to(ball1, (ball1_x, ball1_y))
    move_to(ball2, (ball2_x, ball2_y))
    if distance((ball1_x, ball1_y), (ball2_x, ball2_y)) &lt;= 20:
        remove_from_screen(ball1)
        remove_from_screen(ball2)
        break
    sleep(0.01)

sleep(1)
end_graphics()
</pre>

<p>Put this program in a file named <code>collide.py</code> and run it.</p>


<h2>Putting the pieces together</h2>

<pre class='python'>
from gasp import *

def distance((x1, y1), (x2, y2)):
        return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

begin_graphics(800, 600, title="Catch", background=color.yellow)

ball_x = 10
ball_y = 300
ball = Circle((ball_x, ball_y), 10, filled=True)
dx = 4
dy = random_between(-4, 4) 

mitt_x = 780
mitt_y = 300
mitt = Circle((mitt_x, mitt_y), 20)

while True:
    # move the ball
    if ball_y &gt;= 590 or ball_y &lt;= 10:
        dy *= -1
    ball_x += dx
    if ball_x &gt; 810:             # the ball has gone off the screen
        break
    ball_y += dy
    move_to(ball, (ball_x, ball_y))

    # check on the mitt
    if key_pressed('j') and mitt_y &lt;= 580:
        mitt_y += 5
    elif key_pressed('k') and mitt_y &gt;= 20:
        mitt_y -= 5
    elif key_pressed('escape'):
        break
    move_to(mitt, (mitt_x, mitt_y))

    if distance((ball_x, ball_y), (mitt_x, mitt_y)) &lt;= 30:  # ball is caught
        remove_from_screen(ball)
        break

    sleep(0.01)

end_graphics()
</pre>


<h2>Displaying text</h2>

<p>This program displays scores for both a player and the computer on the
graphics screen.  It generates a random number of 0 or 1 (like flipping a coin)
and adds a point to the player if the value is 1 and to the computer if it is
not.  It then updates the display on the screen.</p> 

<pre class='python'>
from gasp import *

begin_graphics(800, 600, title="Catch", background=color.yellow)

player_score = 0
comp_score = 0

player = Text("Player: %d Points" % player_score, (10, 570), size=24)
computer = Text("Computer: %d Points" % comp_score, (640, 570), size=24)

while player_score &lt; 5 and comp_score &lt; 5:
    sleep(1)
    winner = random_between(0, 1)
    if winner:
        player_score += 1
        remove_from_screen(player)
        player = Text("Player: %d Points" % player_score, (10, 570), size=24)
    else:
        comp_score += 1
        remove_from_screen(computer)
        computer = Text("Computer: %d Points" % comp_score, (640, 570), size=24)

if player_score == 5:
    Text("Player Wins!", (340, 290), size=32)
else:
    Text("Computer Wins!", (340, 290), size=32)

sleep(4)

end_graphics()
</pre>

<p>Put this program in a file named <code>scores.py</code> and run it.</p>


<h2>Creating a main loop</h2>

<p>Iteration is useful for enabling users to control how many times parts of a
program are executed.</p>

<pre class='python'>
def play_game():
    print "I'm playing... Oh what fun!"

choice = 'y' 

while choice == 'y':
    play_game()
    choice = raw_input("Would you like to play again? (y/n): ")
</pre>

<p>The variable <code>choice</code> is initialized to <code>'y'</code>.
This makes the condition of the while loop true the first time it is evaluated,
and assures that users get to play the game at least once.  After the game
finishes (and soon the call to <code>play_game()</code> will do something more
then print a message), users will be asked if they would like to play again. 
As long as they keep answering with 'y', they can continue playing.</p>

<pre class='shell'>
I'm playing... Oh what fun!
Would you like to play again? (y/n): y
I'm playing... Oh what fun!
Would you like to play again? (y/n): y
I'm playing... Oh what fun!
Would you like to play again? (y/n): n
</pre>


<h2>Glossary</h2>
<span class="index" value="random" />
<span class="index" value="break" />
<span class="index" value="break statement" />
<span class="index" value="trichotomy" />
<span class="index" value="law of trichotomy" />

<dl>
<dt>random:</dt>
<dd>Having no specific pattern. Unpredictable. Computers are designed to be
predicatable, and it is not possible to get a truly random value from
a computer.  Certain functions produce sequences of values that appear
as if they were random, and it is these <em>psuedorandom</em> values that
we get from Python.</dd>
</dl>

<dt>trichotomy:</dt>
<dd>Given any real numbers <em>a</em> and <em>b</em>, exactly one of
the following relations holds:  <em>a &lt; b</em>, <em>a &gt; b</em>,
or <em>a = b</em>.  Thus when you can establish that two of the relations are
false, you can assume the remaining one is true.</dd>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
What happens when you press the &lt;Escape&gt; key while running
<code>mitt.py</code>? List the two lines from the program that produce this
behavior and explain how they work.
</div></li>

<li><div class="exercise">
What is the name of the counter variable in <code>guess.py</code>?  With
a proper strategy, the maximum number of guesses required to arrive at the
correct number should be 11.  What is this strategy?
</div></li>

<li><div class="exercise">
What happens when the <q>mitt</q> in <code>mitt.py</code> gets to the top or
bottom of the graphics window?  List the lines from the program that control
this behavior and explain <em>in detail</em> how they work.
</div></li>

<li><div class="exercise">
Change the value of <code>ball1_dx</code> in <code>collide.py</code> to 2.  How 
does the program behave differently?  Now change <code>ball1_dx</code> back to
4 and set <code>ball2_dx</code> to -2.  Explain <em>in detail</em> how these
changes effect the behavior of the program.
</div></li>

<li><div class="exercise">
Comment out (put a <code>#</code> in front of the statement) the
<code>break</code> statement in <code>collide.py</code>.  Do you notice any
change in the behavior of the program?  Now also comment out the 
<code>remove_from_screen(ball1)</code> statement.  What happens now?
Experiment with commenting and uncommenting the two
<code>remove_from_screen</code> statements and the <code>break</code> statement
until you can describe <em>specifically</em> how these statement work together
to produce the desired behavior in the program.
</div></li>
</ol>

</body>
</html>
