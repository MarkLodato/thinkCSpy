<html>
<head>
  <title>Case Study: Catch</title>
</head>
<body>

<h1>Case Study: Catch</h1>

<h2>Getting Started</h2>

<p>In our first case study we will build a small video game using the
facilities in the GASP package.  The game will shoot a ball across a window
from left to right and you will manipulate a <q>mitt</q> at the right side of
the window to catch it.</p>


<h2>Using <code>while</code> to move a ball</h2>

<p><code>while</code> statements can be used with <code>gasp</code> to add
motion to a program.  The following program moves a black ball across an
800 x 600 pixel graphics canvas.  Add this to a file named
<code>pitch.py</code></p>

<pre class='python'>
from gasp import *

begin_graphics(800, 600, title="Catch", background=color.yellow)

x = 10
y = 300
ball = Circle((x, y), 10, filled=True)
dx = 4
dy = 1

while x &lt; 810:
    x += dx
    y += dy
    move_to(ball, (x, y))
    sleep(0.01)

end_graphics()
</pre>

<p>As the ball moves across the screen, you will see a graphics window that
looks like this:</p>

<img src="illustrations/gasp03.png" />

<p>Trace the first few iterations of this program to be sure you see what is
happening to the variables <code>x</code> and <code>y</code>.</p>

<p>Some new things to learn about GASP from this example:</p>

<ul>
  <li><code>begin_graphics</code> can take arguments for width, height,
  title, and background color of the graphics canvas.</li>

  <li>Adding <code>filled=True</code> to <code>Circle(...)</code> makes
  the resulting circle solid.</li>

  <li><code>ball = Circle</code> stores the circle (we will talk later
  about what a circle actually is) in a variable named <code>ball</code>
  so that it can be referenced later.</li>

  <li>The <code>move_to</code> function in GASP allows a programmer to
  pass in a shape (the ball in this case) and a location, and moves the
  shape to that location.</li>

  <li>The <code>sleep</code> function takes a time value in seconds as
  an argument and pauses execution of the program for that length of time.
  In general computers do things much to fast to allow you to interact with
  them.  We can slow things down by making the computer sleep a bit at the
  right place.</li>
</ul>


<h2>Varying the pitches</h2>
<span class="index" value="random" />
<span class="index" value="random values" />

<p>To make our game more interesting, we want to be able to vary the speed and
direction of the ball.  GASP has a function,
<code>random_between(low, high)</code>, that returns a <b>random</b> integer
between <code>low</code> and <code>high</code>.  To see how this works,
run the following program:</p>

<pre class="python">
from gasp import *

i = 0
while i &lt; 10:
    print random_between(-5, 5)
    i += 1
</pre>

<p>Each time the function is called a more or less random integer is chosen
between -5 and 5.  When we ran this program we got:</p>

<pre class='shell'>
-2
-1
-4
1
-2
3
-5
-3
4
-5
</pre>

<p>You will probably get a different sequence of numbers.</p>

<p>Let's use <code>random_between</code> to vary the direction of the ball.
Replace the line in <code>pitch.py</code> that assigns <code>1</code>
to <code>y</code>:</p>

<pre class='python'>
dy = 1 
</pre>

<p>with an assignment to a random number between -4 and 4:</p>

<pre class='python'>
dy = random_between(-4, 4) 
</pre>


<h2>Making the ball <q>bounce</q></h2>

<p>Running this new version of the program, you will notice that ball
frequently goes off either the top or bottom edges of the screen before it
completes its journey.  To prevent this, let's make the ball <q>bounce</q>
off the edges by changing the sign of <code>dy</code> and sending the
ball back in the opposite verticle direction.</p>

<p>Add the following as the first line of the body of the while loop in
<code>pitch.py</code>:</p>

<pre class='python'>
if y &gt;= 590 or y &lt;= 10:
    dy *= -1
</pre>


<h2>Responding to the keyboard</h2>

<p>The following program creates a movable circle (or <q>mitt</q>) which
response to keyboard input.  Pressing the <code>j</code> or <code>k</code>
keys moves the mitt up and down, respectively.</p>

<pre class='python'>
from gasp import *

begin_graphics(800, 600, title="Catch", background=color.yellow)

mitt_x = 780
mitt_y = 300
mitt = Circle((mitt_x, mitt_y), 20)

while True:
    if key_pressed('j') and mitt_y &lt;= 580:
        mitt_y += 5
    elif key_pressed('k') and mitt_y &gt;= 20:
        mitt_y -= 5
    elif key_pressed('escape'):
        break
    move_to(mitt, (mitt_x, mitt_y))
    sleep(0.01)

end_graphics()
</pre>


<h2>Checking for collisions</h2>

<pre class='python'>
from gasp import *

def distance((x1, y1), (x2, y2)):
    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

begin_graphics(800, 600, title="Catch", background=color.yellow)

ball1_x = 10
ball1_y = 300
ball1 = Circle((ball1_x, ball1_y), 10, filled=True)
ball1_dx = 4

ball2_x = 790
ball2_y = 300
ball2 = Circle((ball2_x, ball2_y), 10)
ball2_dx = -4

while ball1_x &lt; 810:
    ball1_x += ball1_dx
    ball2_x += ball2_dx
    move_to(ball1, (ball1_x, ball1_y))
    move_to(ball2, (ball2_x, ball2_y))
    if distance((ball1_x, ball1_y), (ball2_x, ball2_y)) &lt;= 20:
        remove_from_screen(ball1)
        remove_from_screen(ball2)
        break
    sleep(0.01)

end_graphics()
</pre>


<h2>Displaying text</h2>

<pre class='python'>
from gasp import *

begin_graphics(800, 600, title="Catch", background=color.yellow)

player_score = 0
comp_score = 0

player = Text("Player: %d Points" % player_score, (10, 570), size=24)
computer = Text("Computer: %d Points" % comp_score, (640, 570), size=24)

while player_score &lt; 5 and comp_score &lt; 5:
    sleep(1)
    winner = random_between(0, 1)
    if winner:
        player_score += 1
        remove_from_screen(player)
        player = Text("Player: %d Points" % player_score, (10, 570), size=24)
    else:
        comp_score += 1
        remove_from_screen(computer)
        computer = Text("Computer: %d Points" % comp_score, (640, 570), size=24)

if player_score == 5:
    Text("Player Wins!", (340, 290), size=32)
else:
    Text("Computer Wins!", (340, 290), size=32)

sleep(4)

end_graphics()
</pre>


<h2>Creating a main loop</h2>

<p>Iteration is useful for enabling users to control how many times parts of a
program are executed.</p>

<pre class='python'>
def play_game():
    print "I'm playing... Oh what fun!"

choice = 'y' 

while choice == 'y':
    play_game()
    choice = raw_input("Would you like to play again? (y/n): ")
</pre>

<p>The variable <code>choice</code> is initialized to <code>'y'</code>.
This makes the condition of the while loop true the first time it is evaluated,
and assures that users get to play the game at least once.  After the game
finishes (and soon the call to <code>play_game()</code> will do something more
then print a message), users will be asked if they would like to play again. 
As long as they keep answering with 'y', they can continue playing.</p>

<pre class='shell'>
I'm playing... Oh what fun!
Would you like to play again? (y/n): y
I'm playing... Oh what fun!
Would you like to play again? (y/n): y
I'm playing... Oh what fun!
Would you like to play again? (y/n): n
</pre>


<h2>Glossary</h2>
<span class="index" value="random" />

<dl>
<dt>random:</dt>
<dd>Having no specific pattern. Unpredictable. Computers are designed to be
predicatable, and it is not possible to get a truly random value from
a computer.  Certain functions produce sequences of values that appear
as if they were random, and it is these <em>psuedorandom</em> values that
we get from Python.</dd>
</dl>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
</div></li>

<li><div class="exercise">
</div></li>

<li><div class="exercise">
</div></li>

</ol>

</body>
</html>
