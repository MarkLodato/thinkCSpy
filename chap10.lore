<html>
<head>
  <title>Modules and files</title>
</head>
<body>

<h1>Modules and files</h1>


<h2>The <code>sys</code> module and <code>argv</code></h2>
<span class="index" value="sys module" />
<span class="index" value="module!sys" />
<span class="index" value="argv" />
<span class="index" value="command line" />
<span class="index" value="command line arguments" />

<p>The <code>sys</code> module contains a variable named <code>argv</code>,
which holds a list of strings read in from the <b>command line</b> when
a Python script is run.  These <b>command line arguments</b> can be used to
pass information into a program at the same time it is invoked.</p>

<pre class="python">
#
# demo_argv.py
#
from sys import argv

print argv 
</pre>

<p>Running this program from the unix command prompt demonstrates how
<code>sys.argv</code> works:</p>

<pre class="shell">
$ python demo_argv.py this and that 1 2 3
['demo_argv.py', 'this', 'and', 'that', '1', '2', '3']
$ 
</pre>

<p><code>argv</code> is a list of strings.  Notice that the first element is
the name of the program.  Arguments are seperated by white space, and separated
into a list in the same way that <code>string.split</code> operates.  If you
want an argument with white space in it, use quotes:</p>

<pre class="shell">
$ python demo_argv.py "this and" that "1 2" 3
['demo_argv.py', 'this and', 'that', '1 2', '3']
$ 
</pre>


<h2>The <code>eval</code> function</h2>
<span class="index" value="eval" />
<span class="index" value="funtion!eval" />

<p>The <code>eval</code> function takes a string as an argument and
<em>evaluates</em> it as a Python expression, returning the value of the
expression.</p>

<pre class="python-interpreter">
>>> eval('4 + 5')
9
>>> thing = eval('[1, 2, 3]')
>>> type(thing)
&lt;type 'list'&gt;
>>> thing
[1, 2, 3]
</pre>

<p><code>eval</code> and <code>raw_input</code> can be used together to
safely read numeric data:</p>

<pre class="python">
def alldigits(s):
    for ch in s:
        if ch not in "0123456789":
            return False
    return True

age = input("Please enter your age: ")
while not alldigits(age) or int(age) &gt;= 0:
    age = input("Please enter your age as a positive integer: ")

age = int(age)
</pre>

<p>The boolean function <code>alldigits</code> checks whether the user
input consists of only a sequence of digits.  If the user enters
<code>ten</code> or <code>-6</code>, when propted for her age, she will be
prompted again to enter a positive integer.</p>

<p>Be advised that there are security risks associated with using
<code>eval</code> with data from untrusted sources (see the 
<a href="http://en.wikipedia.org/wiki/Eval">wikipedia article on eval</a>
for more on this).  In the example above we check to make sure the only
data evaluated consists of a string of digits."</p>

<p>Combining <code>argv</code> with <code>eval</code> we can write a handy
little command line program that prints a truth table for an arbitrary
boolean expression involving two boolean variables, <code>p</code> and
<code>q</code>:</p>

<pre class="python">
from sys import argv

def truth_table(expression):
    print "\n p      q      %s"  % expression
    length = len( " p      q      %s"  % expression)
    print length*"="

    for p in True, False:
        for q in True, False:
            print "%-7s %-7s %-7s" % (p, q, eval(expression))
    print

if len(argv) != 2:
    print "Invalid input, enter a quoted string containing a boolean"
    print "expression in p and q."
else:
    truth_table(argv[1])
</pre>

<p>Save the program above in a file named <code>truth_in_p_and_q.py</code>.
It can now be passed an arbitrary boolean expression involving boolean
variables <code>p</code> and <code>q</code> at the command line, and it
will print a truth table for the given expression:</p>

<pre class="shell">
$ python truth_in_p_and_q.py "(p and not q) or (not p and q)"

 p      q      (p and not q) or (not p and q)
=============================================
True    True    False  
True    False   True   
False   True    True   
False   False   False  

$
</pre>

<p>Note that the boolean expression needs to be enclosed in quotation marks.
</p>


<h2>Reading and writing text files</h2>
<span class="index" value="volitile memory" />
<span class="index" value="non-volitile memory" />
<span class="index" value="file" />

<p>While a program is running, its data is stored in
<em>random access memory</em> (RAM).  RAM is fast and inexpensive, but it is
also <b>volitile</b>, which means that when the program ends, or the computer
shuts down, data in RAM disappears.  To store data permanently, you have to put 
it in a <b>non-volitile</b> storage medium, such a hard drive, usb drive, or
CD-RW.</p>

<p>Data on non-volitile storage media is stored in named locations on the
media called <b>files</b>.  By reading and writing files, programs can save
information between program runs.</p>

<p>Working with files is a lot like working with a notebook.  To use a
notebook, you have to open it.  When you're done, you have to close it.  While
the notebook is open, you can either write in it or read from it.  In either
case, you know where you are in the notebook.  You can read the whole notebook
in its natural order or you can skip around.</p>

<p>All of this applies to files as well.  To open a file, you specify its name
and indicate whether you want to read or write.</p>

<p>Opening a file creates a file object.  In this example, the variable
<code>f</code> refers to the new file object.</p>

<pre class="python-interpreter">
>>> f = open('test.dat', 'w')
>>> print f
&lt;open file 'test.dat', mode 'w' at 0x2aaaaab80cd8&gt;
</pre>

<p>The open function takes two arguments.  The first is the name of the file,
and the second is the <b>mode</b>.  Mode <code>'w'</code> means that we are
opening the file for writing.</p>

<p>If there is no file named <code>test.dat</code>, it will be created.  If
there already is one, it will be replaced by the file we are writing.</p>

<p>When we print the file object, we see the name of the file, the mode, and
the location of the object.</p>

<p>To put data in the file we invoke the <code>write</code> method on the file
object:</p>

<pre class="python-interpreter">
>>> f.write("Now is the time")
>>> f.write("to close the file")
</pre>

<p>Closing the file tells the system that we are done writing and makes the
file available for reading:</p>

<pre class="python-interpreter">
>>> f.close()
</pre>

<p>Now we can open the file again, this time for reading, and read the contents 
into a string.  This time, the mode argument is <code>'r'</code> for reading:
</p>

<pre class="python-interpreter">
>>> f = open('test.dat', 'r')
</pre>

<p>If we try to open a file that doesn't exist, we get an error:</p>

<span class="index" value="runtime error" />

<pre class="python-interpreter">
>>> f = open('test.cat', 'r')
IOError: [Errno 2] No such file or directory: 'test.cat'
</pre>

<p>Not surprisingly, the <code>read</code> method reads data from the file.
With no arguments, it reads the entire contents of the file into a single
string:</p>

<pre class="python-interpreter">
>>> text = f.read()
>>> print text
Now is the timeto close the file
</pre>

<p>There is no space between <q>time</q> and <q>to</q> because we did not write 
a space between the strings.</p>

<p><code>read</code> can also take an argument that indicates how many
characters to read:</p>

<pre class="python-interpreter">
>>> f = open('test.dat', 'r')
>>> print f.read(5)
Now i
</pre>

<p>If not enough characters are left in the file, <code>read</code> returns the 
remaining characters.  When we get to the end of the file, <code>read</code>
returns the empty string:</p>

<pre class="python-interpreter">
>>> print f.read(1000006)
s the timeto close the file
>>> print f.read()
   
>>>
</pre>

<p>The following function copies a file, reading and writing up to fifty
characters at a time.  The first argument is the name of the original file; the 
second is the name of the new file:</p>

<pre class="python">
def copy_file(old_file, new_file):
    f1 = open(old_file, 'r')
    f2 = open(new_file, 'w')
    while True:
        text = f1.read(50)
        if text == "":
            break
        f2.write(text)
    f1.close()
    f2.close()
    return
</pre>

<p>This functions continues looping, reading 50 characters from <code>f1</code>
and writing the same 50 charaters to <code>f2</code> until the end of
<code>f1</code> is reached, at which point <code>text</code> is empty and the
<code>break</code> statement is executed.</p>


<h2>Text files</h2>
<span class="index" value="text file" />
<span class="index" value="file!text" />

<p>A <b>text file</b> is a file that contains printable characters and
whitespace, organized into lines separated by newline characters.  Since Python 
is specifically designed to process text files, it provides methods that make
the job easy.</p>

<p>To demonstrate, we'll create a text file with three lines of text separated
by newlines:</p>

<pre class="python-interpreter">
>>> f = open("test.dat","w")
>>> f.write("line one\nline two\nline three\n")
>>> f.close()
</pre>

<p>The <code>readline</code> method reads all the characters up to and
including the next newline character:</p>

<pre class="python-interpreter">
>>> f = open("test.dat","r")
>>> print f.readline()
line one
   
>>>
</pre>

<p><code>readlines</code> returns all of the remaining lines as a list of
strings:</p>

<pre class="python-interpreter">
>>> print f.readlines()
['line two\012', 'line three\012']
</pre>

<p>In this case, the output is in list format, which means that the strings
appear with quotation marks and the newline character appears as the escape
sequence <code>\\012</code>.</p>

<p>At the end of the file, <code>readline</code> returns the empty string
and <code>readlines</code> returns the empty list:</p>

<pre class="python-interpreter">
>>> print f.readline()
   
>>> print f.readlines()
[]
</pre>

<p>The following is an example of a line-processing program.
<code>filter</code> makes a copy of <code>old_file</code>, omitting any
lines that begin with <code>#</code>:</p>

<pre class="python">
def filter(old_file, new_file):
    f1 = open(old_file, 'r')
    f2 = open(new_file, 'w')
    while True:
        text = f1.readline()
        if text == "":
           break
        if text[0] == '#':
           continue
        f2.write(text)
    f1.close()
    f2.close()
    return
</pre>

<p>The <code>continue</code> statement ends the current iteration of the loop,
but continues looping.  The flow of execution moves to the top of the loop,
checks the condition, and proceeds accordingly.</p>

<span class="index" value="continue statement" />
<span class="index" value="statement!continue" />

<p>Thus, if <code>text</code> is the empty string, the loop exits.  If the
first character of <code>text</code> is a hash mark, the flow of execution goes 
to the top of the loop.  Only if both conditions fail do we copy
<code>text</code> into the new file.</p>


<h2>Directories</h2>
<span class="index" value="file system" />
<span class="index" value="directory" />

<p>Files on non-volitile storage media are organized by a set of rules known
as a <b>file system</b>.  File systems are made up of files and
<b>directories</b>, which are containers for both files and other directories.
</p>

<p>When you create a new file by opening it and writing, the new file goes in
the current directory (wherever you were when you ran the program).  Similarly, 
when you open a file for reading, Python looks for it in the current directory.
</p>

<p>If you want to open a file somewhere else, you have to specify the
<b>path</b> to the file, which is the name of the directory
(or folder) where the file is located:</p>

<pre class="python-interpreter">
>>>   f = open('/usr/share/dict/words', 'r')
>>>   print f.readline()
Aarhus
</pre>

<p>This example opens a file named <code>words</code> that resides in a
directory named <code>dict</code>, which resides in <code>share</code>, which
resides in <code>usr</code>, which resides in the top-level directory of the
system, called <code>/</code>.</p>

<span class="index" value="path" />
<span class="index" value="delimiter" />

<p>You cannot use <code>/</code> as part of a filename; it is reserved as a
delimiter between directory and filenames.</p>

<p>The file <code>/usr/share/dict/words</code> contains a list of words
in alphabetical order, of which the first is the name of a Danish university.
</p>


<h2>Modules</h2>
<span class="index" value="module" />
<span class="index" value="standard library" />
<span class="index" value="import" />
<span class="index" value="import statement" />
<span class="index" value="statement!import" />
<span class="index" value="namespace" />

<p>A <b>module</b> is a file containing Python definitions and statements
intended for use in other Python programs.  There are many Python modules that
come bundled with Python as part of the <b>standard library</b>.  We have seen
two of these already, the <code>math</code> module and the <code>string</code>
module.</p>

<p>All we need to create a module is a text file with a <code>.py</code>
extension on the filename:</p>

<pre class="python">
#  seqtools.py
#
def remove_at(pos, seq):
    return seq[:pos] + seq[pos+1:]
</pre>

<p>We can now use our module in both scripts and the Python shell.  To do
so, we must first <b>import</b> the module.  There are two ways to do this:
</p>

<pre class="python-interpreter">
>>> from seqtools import remove_at
>>> s = "A string!"
>>> remove_at(4, s)
'A sting!'
</pre>

<p>Using this format, we have brought the <code>remove_at</code> function
into our top level <b>namespace</b>.  The danger of this kind of import is
that if there is already another <code>remove_at</code> function imported from
another module, access to the first function will be lost.</p>

<p>The second way to import a module preserves the module's namespace, but
requires you to specify the module name when accessing things inside it:</p>

<pre class="python-interpreter">
>>> import seqtools
>>> s = "A string!"
>>> seqtools.remove_at(4, s)
'A sting!'
</pre>

<p>Notice that we do not include the <code>.py</code> file extension when
importing.  It must be there for a file to be a Python module, but it is not
included in the <b>import statement</b>.</p>

<p>The use of modules makes it possible to break up very large programs into
managable sized parts, and to keep related parts together.  Modules also help
several programmers work on the same project without having namespace clashes.
</p>


<h2>Glossary</h2>
<span class="index" value="volitile memory" />
<span class="index" value="non-volitile memory" />
<span class="index" value="file" />
<span class="index" value="directory" />
<span class="index" value="path" />

<dl>
<dt>file:</dt>
<dd>A named entity, usually stored on a hard drive, floppy disk, or CD-ROM,
that contains a stream of characters.</dd>

<dt>directory:</dt>
<dd>A named collection of files, also called a folder.</dd>

<dt>mode:</dt>
<dd>A distinct method of operation within a computer program.  Files in Python
can be openned in one of three modes: read ('r'), write ('w'), and append ('a').
</dd>

<dt>path:</dt>
<dd>A sequence of directory names that specifies the exact location of a file.
</dd>

<dt>text file:</dt>
<dd>A file that contains printable characters organized into lines separated
by newline characters.</dd>

<dt>continue statement:</dt>
<dd>A statement that causes the current iteration of a loop to end.  The flow
of execution goes to the top of the loop, evaluates the condition, and
proceeds accordingly.</dd>
</dl>


<h2>Exercises</h2>
<ol>
<li><div class="exercise">
</div></li>
</ol>


</body>
</html>
